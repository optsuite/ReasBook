#!/usr/bin/env python3
from __future__ import annotations

import argparse
from pathlib import Path


def find_repo_root(start: Path) -> Path:
    cur = start.resolve()
    for p in [cur, *cur.parents]:
        if (p / "ReasBook").is_dir() and (p / "README.md").is_file():
            return p
    raise RuntimeError(f"could not locate repository root from {start}")


def module_from_relpath(rel: Path) -> str:
    return ".".join(rel.with_suffix("").parts)


def main() -> None:
    parser = argparse.ArgumentParser(description="Generate independent Verso pages/routes for one book/paper project")
    parser.add_argument("project_dir", help="Path like ReasBook/Books/<Name> or ReasBook/Papers/<Name>")
    args = parser.parse_args()

    project_dir = Path(args.project_dir).resolve()
    repo_root = find_repo_root(project_dir)
    lean_root = repo_root / "ReasBook"

    rel_project = project_dir.relative_to(lean_root)
    if len(rel_project.parts) < 2 or rel_project.parts[0] not in {"Books", "Papers"}:
        raise RuntimeError(f"{project_dir} is not under ReasBook/Books or ReasBook/Papers")

    kind = rel_project.parts[0]
    proj_name = rel_project.parts[1]
    prefix = ".".join(rel_project.parts)

    root_mod_leaf = "Book" if kind == "Books" else "Paper"
    root_mod = f"{prefix}.{root_mod_leaf}"

    content_dir_name = "Chapters" if kind == "Books" else "Sections"
    content_dir = project_dir / content_dir_name

    entries: list[tuple[str, str, str]] = []
    if content_dir.is_dir():
        for lean_file in sorted(content_dir.rglob("*.lean")):
            rel = lean_file.relative_to(lean_root)
            mod = module_from_relpath(rel)
            rel_route = lean_file.relative_to(content_dir).with_suffix("")
            route = f"{content_dir_name.lower()}/{str(rel_route).replace('\\\\', '/').lower()}/"
            decl = "page_" + "_".join(rel_route.with_suffix("").parts).replace("-", "_").lower()
            entries.append((route, mod, decl))

    site_dir = project_dir / "ProjectSite"
    site_dir.mkdir(parents=True, exist_ok=True)

    gen_pages = site_dir / "GeneratedPages.lean"
    with gen_pages.open("w", encoding="utf-8") as f:
        f.write("-- This file is generated by scripts/gen_project_site.py.\n")
        f.write("-- Do not edit manually.\n\n")
        f.write("import SiteSupport.LiterateModule\n\n")
        f.write("namespace ProjectSite.GeneratedPages\n\n")
        f.write(f'reasbook_page homePage from {root_mod} as "{proj_name}"\n')
        for _, mod, decl in entries:
            title = mod.split(".")[-1]
            f.write(f'reasbook_page {decl} from {mod} as "{title}" with ({{showInNav := false}} : Verso.Genre.Blog.Page.Meta)\n')
        f.write("\nend ProjectSite.GeneratedPages\n")

    route_table = site_dir / "RouteTable.lean"
    with route_table.open("w", encoding="utf-8") as f:
        f.write("-- This file is generated by scripts/gen_project_site.py.\n")
        f.write("-- Do not edit manually.\n\n")
        f.write("import VersoBlog\n")
        f.write("import ProjectSite.GeneratedPages\n\n")
        f.write("open Verso Genre Blog Site Syntax\n\n")
        f.write("namespace ProjectSite.RouteTable\n\n")
        f.write("def projectSite : Site := site ProjectSite.GeneratedPages.homePage /\n")
        f.write(f'  "{root_mod_leaf.lower()}/" ProjectSite.GeneratedPages.homePage\n')
        for route, _, decl in entries:
            f.write(f'  "{route}" ProjectSite.GeneratedPages.{decl}\n')
        f.write("\nend ProjectSite.RouteTable\n")


if __name__ == "__main__":
    main()
