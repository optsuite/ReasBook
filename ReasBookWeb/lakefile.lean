import Lake
open Lake DSL

require verso from git "https://github.com/leanprover/verso.git" @ "v4.26.0"
require subverso from git "https://github.com/leanprover/subverso" @ "eb77622e97e942ba2cfe02f60637705fc2d9481b"
require MD4Lean from git "https://github.com/acmepjz/md4lean" @ "main"

package "reasbook-site" where
  version := v!"0.1.0"

lean_lib «ReasBookSite» where

@[default_target]
lean_exe "reasbook-site" where
  root := `ReasBookSite

/-- Root of the main ReasBook project (which defines Books/ and Papers/ modules). -/
def reasbookRoot : System.FilePath := "../ReasBook"

/-- Parse a generated section line of the form: `(`Module.Name, "Title"),`. -/
def parseSectionLine? (line : String) : Option (Lean.Name × String) :=
  let line := line.trim
  if !line.startsWith "(`" then
    none
  else
    match line.splitOn ", \"" with
    | [lhs, rhs] =>
      let nameStr := (lhs.drop 2).trim
      if nameStr.isEmpty then
        none
      else
        let titleRaw :=
          if rhs.endsWith "\")," then rhs.dropRight 3
          else if rhs.endsWith "\"" then rhs.dropRight 1
          else rhs
        some (nameStr.toName, titleRaw.replace "\\\"" "\"")
    | _ => none

/-- Load section metadata generated by `scripts/gen_sections.py`. -/
def loadSections (pkg : NPackage n) : IO (Array (Lean.Name × String)) := do
  let sectionsFile := pkg.dir / "ReasBookSite" / "Sections.lean"
  let content ← IO.FS.readFile sectionsFile
  let mut out : Array (Lean.Name × String) := #[]
  for line in content.splitOn "\n" do
    if let some entry := parseSectionLine? line then
      out := out.push entry
  pure out

/-- Ensure the main project has generated `+<module>:literate` JSON. -/
def buildLiterateJson (pkg : NPackage n) (mod : String) : LogIO Unit := do
  let lakeVars :=
    #["LAKE", "LAKE_HOME", "LAKE_PKG_URL_MAP",
      "LEAN_SYSROOT", "LEAN_AR", "LEAN_PATH", "LEAN_SRC_PATH",
      "LEAN_GITHASH",
      "ELAN_TOOLCHAIN", "DYLD_LIBRARY_PATH", "LD_LIBRARY_PATH"]

  let lakefile := pkg.dir / reasbookRoot / "lakefile.lean"
  let lakefile' := pkg.dir / reasbookRoot / "lakefile.toml"
  let lakeConfig := if (← lakefile.pathExists) then lakefile else lakefile'

  let toolchainFile := pkg.dir / reasbookRoot / "lean-toolchain"
  let toolchain := (← IO.FS.readFile toolchainFile).trim

  let f ← IO.FS.Handle.mk lakeConfig .read
  f.lock (exclusive := true)
  try
    let cmd := "elan"
    let args := #["run", "--install", toolchain, "lake", "build", s!"+{mod}:literate"]
    proc (quiet := true) {
      cmd, args, cwd := pkg.dir / reasbookRoot,
      env := lakeVars.map (·, none)
    }
  finally
    f.unlock

/-- Generate `Book.*` modules and a root `Book` module. -/
target genLib (pkg) : Unit := do
  -- Keep generator and `ReasBookSite/LiterateModule.lean` syntax in sync.
  let pageCmd := "reasbook_page"
  let sections ← liftM (m := LogIO) <| loadSections pkg
  let j1 ← Job.mixArray <$> sections.mapM fun (module, title) => Job.async do
    let leanModName := `Book ++ module
    let declName := `Book ++ module
    let some mod ← findModule? leanModName
      | error s!"Failed to generate {leanModName}: it has not been defined in the workspace."

    let origName := "/".intercalate (module.components.map (·.toString)) ++ ".lean"
    let origLeanFile : System.FilePath := pkg.dir / reasbookRoot / origName
    addTrace (← computeTrace <| TextFilePath.mk origLeanFile)

    let jsonSentinel := defaultBuildDir / "originals" / module.toString
    let jsonName := "/".intercalate (module.components.map (·.toString)) ++ ".json"
    let jsonFile : System.FilePath := pkg.dir / reasbookRoot / ".lake" / "build" / "literate" / jsonName

    addPureTrace (caption := "{jsonFile} exists") (← jsonFile.pathExists)

    buildFileUnlessUpToDate' jsonSentinel do
      logVerbose s!"Generating highlighting info for {module}"
      buildLiterateJson pkg module.toString
      let trace ← computeTrace (TextFilePath.mk jsonFile)
      addTrace trace
      createParentDirs jsonSentinel
      IO.FS.writeFile jsonSentinel (toString (repr trace))

    let contents := s!"import ReasBookSite.LiterateModule\n\nset_option maxHeartbeats 100000000\n\nset_option maxRecDepth 20000\n\n{pageCmd} {declName} from {module} as {repr title}\n"
    addPureTrace contents "contents"

    buildFileUnlessUpToDate' mod.leanFile do
      createParentDirs mod.leanFile
      IO.FS.writeFile mod.leanFile contents
      liftM (m := IO) <| try IO.FS.removeFile mod.oleanFile catch
        | .noFileOrDirectory .. => pure ()
        | e => throw e

  let j2 ← Job.async do
    let rootName := `Book
    let some mod ← findModule? rootName
      | error s!"Failed to generate {rootName}: it has not been defined in the workspace."
    let mut contents := ""
    for (module, title) in sections do
      contents := contents ++ s!"import {`Book ++ module} -- {title}\n"
    addPureTrace contents "contents"
    buildFileUnlessUpToDate' mod.leanFile do
      createParentDirs mod.leanFile
      IO.FS.writeFile mod.leanFile contents
      liftM (m := IO) <| try IO.FS.removeFile mod.oleanFile catch
        | .noFileOrDirectory .. => pure ()
        | e => throw e

  pure <| Job.mix j1 j2

/-- Blocking target used from `Book` lib dependencies. -/
target genLibSync : Unit := do
  .pure <$> (← genLib.fetch).await

lean_lib Book where
  needs := #[genLibSync]
  srcDir := defaultBuildDir / "src"
