{"99":
 "<code class=\"docstring\">`infer_instance` is an abbreviation for `exact inferInstance`.\nIt synthesizes a value of any target type by typeclass inference.\n</code>",
 "98":
 "<code>CompactSpace.{u_1} (X : Type u_1) [TopologicalSpace X] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Type class for compact spaces. Separation is sometimes included in the definition, especially\nin the French literature, but we do not include it here. </code>",
 "97":
 "<code>IsCompact.{u_1} {X : Type u_1} [TopologicalSpace X] (s : Set X) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set `s` is compact if for every nontrivial filter `f` that contains `s`,\nthere exists `a ‚àà s` such that every set of `f` meets every neighborhood of `a`. </code>",
 "96":
 "<code>BoundedSpace.{u_4} (Œ± : Type u_4) [Bornology Œ±] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A space with a `Bornology` is a **bounded space** if `Set.univ : Set Œ±` is bounded. </code>",
 "95": "<code>Type u_4</code>",
 "94":
 "<code>Bornology.IsBounded.{u_2} {Œ± : Type u_2} [Bornology Œ±] (s : Set Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsBounded` is the predicate that `s` is bounded relative to the ambient bornology on `Œ±`. </code>",
 "93": "<code>Set Œ±</code>",
 "92":
 "<code>SeqCompactSpace.{u_1} (X : Type u_1) [TopologicalSpace X] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A space `X` is sequentially compact if every sequence in `X` has a\nconverging subsequence. </code>",
 "91":
 "<code>IsSeqCompact.{u_1} {X : Type u_1} [TopologicalSpace X] (s : Set X) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set `s` is sequentially compact if every sequence taking values in `s` has a\nconverging subsequence. </code>",
 "90":
 "<code class=\"docstring\">`letI` behaves like `let`, but inlines the value instead of producing a `let` term. </code>",
 "9":
 "<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>",
 "89":
 "<code class=\"docstring\">Tactic for evaluating expressions in *commutative* (semi)rings, allowing for variables in the\nexponent. If the goal is not appropriate for `ring` (e.g. not an equality) `ring_nf` will be\nsuggested.\n\n* `ring!` will use a more aggressive reducibility setting to determine equality of atoms.\n* `ring1` fails if the target is not an equality.\n\nFor example:\n```\nexample (n : ‚Ñï) (m : ‚Ñ§) : 2^(n+1) * m = 2 * 2^n * m := by ring\nexample (a b : ‚Ñ§) (n : ‚Ñï) : (a + b)^(n + 2) = (a^2 + b^2 + a * b + b * a) * (a + b)^n := by ring\nexample (x y : ‚Ñï) : x + id y = y + id x := by ring!\nexample (x : ‚Ñï) (h : x * 2 &gt; 5): x + x &gt; 5 := by ring; assumption -- suggests ring_nf\n```\n</code>",
 "88":
 "<code>ENNReal.ofReal (r : ‚Ñù) : ENNReal</code><span class=\"sep\"></span><code class=\"docstring\">`ofReal x` returns `x` if it is nonnegative, `0` otherwise. </code>",
 "87":
 "<code>EDist.edist.{u_2} {Œ± : Type u_2} [self : EDist Œ±] : Œ± ‚Üí Œ± ‚Üí ENNReal</code><span class=\"sep\"></span><code class=\"docstring\">Extended distance between two points </code>",
 "86":
 "<code>ENNReal : Type</code><span class=\"sep\"></span><code class=\"docstring\">The extended nonnegative real numbers. This is usually denoted [0, ‚àû],\nand is relevant as the codomain of a measure. </code>",
 "85": "<code>EDist Œ±</code>",
 "84": "<code>Type u_2</code>",
 "83": "<code>Dist Œ±</code>",
 "82":
 "<code>limUnder.{u_1, u_3} {X : Type u_1} [TopologicalSpace X] {Œ± : Type u_3} [Nonempty X] (f : Filter Œ±) (g : Œ± ‚Üí X) : X</code><span class=\"sep\"></span><code class=\"docstring\">If `f` is a filter in `Œ±` and `g : Œ± ‚Üí X` is a function, then `limUnder f g` is a limit of `g`\nat `f`, if it exists. </code>",
 "81": "<code>Œ± ‚Üí a</code>",
 "80": "<code>Filter Œ±</code>",
 "8":
 "<code class=\"docstring\">The `have` tactic is for adding opaque definitions and hypotheses to the local context of the main goal.\nThe definitions forget their associated value and cannot be unfolded, unlike definitions added by the `let` tactic.\n\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ‚àß q ‚àß r`, `have ‚ü®h‚ÇÅ, h‚ÇÇ, h‚ÇÉ‚ü© := h` produces the\n  hypotheses `h‚ÇÅ : p`, `h‚ÇÇ : q`, and `h‚ÇÉ : r`.\n* The syntax `have (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `have` term.\n\n## Properties and relations\n\n* It is not possible to unfold a variable introduced using `have`, since the definition's value is forgotten.\n  The `let` tactic introduces definitions that can be unfolded.\n* The `have h : t := e` is like doing `let h : t := e; clear_value h`.\n* The `have` tactic is preferred for propositions, and `let` is preferred for non-propositions.\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n    Consider using the equivalent `let +nondep` to indicate the intent.\n\n</code>",
 "79": "<code>Type u_3</code>",
 "78": "<code class=\"docstring\">The universe parameter u</code>",
 "77":
 "<code class=\"docstring\">Declares one or more universe variables.\n\n`universe u v`\n\n`Prop`, `Type`, `Type u` and `Sort u` are types that classify other types, also known as\n*universes*. In `Type u` and `Sort u`, the variable `u` stands for the universe's *level*, and a\nuniverse at level `u` can only classify universes that are at levels lower than `u`. For more\ndetails on type universes, please refer to [the relevant chapter of Theorem Proving in Lean][tpil\nuniverses].\n\nJust as type arguments allow polymorphic definitions to be used at many different types, universe\nparameters, represented by universe variables, allow a definition to be used at any required level.\nWhile Lean mostly handles universe levels automatically, declaring them explicitly can provide more\ncontrol when writing signatures. The `universe` keyword allows the declared universe variables to be\nused in a collection of definitions, and Lean will ensure that these definitions use them\nconsistently.\n\n[tpil universes]: https://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#types-as-objects\n(Type universes on Theorem Proving in Lean)\n\n```lean\n/- Explicit type-universe parameter. -/\ndef id‚ÇÅ.{u} (Œ± : Type u) (a : Œ±) := a\n\n/- Implicit type-universe parameter, equivalent to `id‚ÇÅ`.\n  Requires option `autoImplicit true`, which is the default. -/\ndef id‚ÇÇ (Œ± : Type u) (a : Œ±) := a\n\n/- Explicit standalone universe variable declaration, equivalent to `id‚ÇÅ` and `id‚ÇÇ`. -/\nuniverse u\ndef id‚ÇÉ (Œ± : Type u) (a : Œ±) := a\n```\n\nOn a more technical note, using a universe variable only in the right-hand side of a definition\ncauses an error if the universe has not been declared previously.\n\n```lean\ndef L‚ÇÅ.{u} := List (Type u)\n\n-- def L‚ÇÇ := List (Type u) -- error: `unknown universe level 'u'`\n\nuniverse u\ndef L‚ÇÉ := List (Type u)\n```\n\n## Examples\n\n```lean\nuniverse u v w\n\nstructure Pair (Œ± : Type u) (Œ≤ : Type v) : Type (max u v) where\n  a : Œ±\n  b : Œ≤\n\n#check Pair.{v, w}\n-- Pair : Type v ‚Üí Type w ‚Üí Type (max v w)\n```\n</code>",
 "76":
 "<code class=\"docstring\">`haveI` behaves like `have`, but inlines the value instead of producing a `have` term. </code>",
 "75":
 "<code>CompleteSpace.{u} (Œ± : Type u) [UniformSpace Œ±] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A complete space is defined here using uniformities. A uniform space\nis complete if every Cauchy filter converges. </code>",
 "74": "<code>sorry ^ sorry</code>",
 "73":
 "<code class=\"docstring\">`linarith` attempts to find a contradiction between hypotheses that are linear (in)equalities.\nEquivalently, it can prove a linear inequality by assuming its negation and proving `False`.\n\nIn theory, `linarith` should prove any goal that is true in the theory of linear arithmetic over\nthe rationals. While there is some special handling for non-dense orders like `Nat` and `Int`,\nthis tactic is not complete for these theories and will not prove every true goal. It will solve\ngoals over arbitrary types that instantiate `CommRing`, `LinearOrder` and `IsStrictOrderedRing`.\n\nAn example:\n```lean\nexample (x y z : ‚Ñö) (h1 : 2*x &lt; 3*y) (h2 : -4*x + 2*z &lt; 0)\n        (h3 : 12*y - 4* z &lt; 0) : False := by\n  linarith\n```\n\n`linarith` will use all appropriate hypotheses and the negation of the goal, if applicable.\nDisequality hypotheses require case splitting and are not normally considered\n(see the `splitNe` option below).\n\n`linarith [t1, t2, t3]` will additionally use proof terms `t1, t2, t3`.\n\n`linarith only [h1, h2, h3, t1, t2, t3]` will use only the goal (if relevant), local hypotheses\n`h1`, `h2`, `h3`, and proofs `t1`, `t2`, `t3`. It will ignore the rest of the local context.\n\n`linarith!` will use a stronger reducibility setting to try to identify atoms. For example,\n```lean\nexample (x : ‚Ñö) : id x ‚â• x := by\n  linarith\n```\nwill fail, because `linarith` will not identify `x` and `id x`. `linarith!` will.\nThis can sometimes be expensive.\n\n`linarith (config := { .. })` takes a config object with five\noptional arguments:\n* `discharger` specifies a tactic to be used for reducing an algebraic equation in the\n  proof stage. The default is `ring`. Other options include `simp` for basic\n  problems.\n* `transparency` controls how hard `linarith` will try to match atoms to each other. By default\n  it will only unfold `reducible` definitions.\n* If `splitHypotheses` is true, `linarith` will split conjunctions in the context into separate\n  hypotheses.\n* If `splitNe` is `true`, `linarith` will case split on disequality hypotheses.\n  For a given `x ‚â† y` hypothesis, `linarith` is run with both `x &lt; y` and `x &gt; y`,\n  and so this runs linarith exponentially many times with respect to the number of\n  disequality hypotheses. (`false` by default.)\n* If `exfalso` is `false`, `linarith` will fail when the goal is neither an inequality nor `False`.\n  (`true` by default.)\n* If `minimize` is `false`, `linarith?` will report all hypotheses appearing in its initial\n  proof without attempting to drop redundancies. (`true` by default.)\n* `restrict_type` (not yet implemented in mathlib4)\n  will only use hypotheses that are inequalities over `tp`. This is useful\n  if you have e.g. both integer- and rational-valued inequalities in the local context, which can\n  sometimes confuse the tactic.\n\nA variant, `nlinarith`, does some basic preprocessing to handle some nonlinear goals.\n\nThe option `set_option trace.linarith true` will trace certain intermediate stages of the `linarith`\nroutine.\n</code>",
 "727":
 "<code>V_Q.{u_1} {E : Type u_1} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] (Q : Set E) (d : E ‚Üí ‚Ñù)\n  (z : ‚ÜëQ) (g : Module.Dual ‚Ñù E) : ‚ÜëQ</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.5.3.1.\nDefine the mapping\n`V_Q(z,g) = argmin_{x ‚àà Q} { ‚ü™g, x - z‚ü´ + Œæ(z,x) }`\n(equation (eq:auto_Definition_5_6_content_2)). </code>",
 "726":
 "<code>signVec {n : ‚Ñï} (y : Fin n ‚Üí ‚Ñù) : Fin n ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The coordinatewise sign vector, with entries `¬±1`, used to saturate the `‚Äñ¬∑‚Äñ‚àû` unit ball. </code>",
 "725":
 "<code>DualNormDef.{u_1} {E : Type u_1} [SeminormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E]\n  (s : Module.Dual ‚Ñù E) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.1.5 (Dual norm).\nGiven a norm `‚Äñ¬∑‚Äñ` on `E`, the dual norm `‚Äñ¬∑‚Äñ_*` on `E*` is defined by\n`‚Äñs‚Äñ_* = max { ‚ü™s, x‚ü´ : x ‚àà E, ‚Äñx‚Äñ = 1 }` (equation (eq:dual_norm_def)). </code>",
 "724":
 "<code>stdSimplex.{u_1, u_2} (ùïú : Type u_2) (Œπ : Type u_1) [Semiring ùïú] [PartialOrder ùïú] [Fintype Œπ] : Set (Œπ ‚Üí ùïú)</code><span class=\"sep\"></span><code class=\"docstring\">The standard simplex in the space of functions `Œπ ‚Üí ùïú` is the set of vectors with non-negative\ncoordinates with total sum `1`. This is the free object in the category of convex spaces. </code>",
 "723":
 "<code>Real.toNNReal (r : ‚Ñù) : ‚Ñù‚â•0</code><span class=\"sep\"></span><code class=\"docstring\">Reinterpret a real number `r` as a non-negative real number. Returns `0` if `r &lt; 0`. </code>",
 "722":
 "<code>OperatorNormDef.{u_1, u_2} {E1 : Type u_1} {E2 : Type u_2} [SeminormedAddCommGroup E1] [NormedSpace ‚Ñù E1]\n  [FiniteDimensional ‚Ñù E1] [SeminormedAddCommGroup E2] [NormedSpace ‚Ñù E2] [FiniteDimensional ‚Ñù E2]\n  (A : E1 ‚Üí‚Çó[‚Ñù] Module.Dual ‚Ñù E2) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.1.7 (Operator norm ‚ÄñA‚Äñ_{1,2}).\nFor a linear operator `A : E1 ‚Üí E2*`, define\n`‚ÄñA‚Äñ_{1,2} = max { ‚ü™A x, u‚ü´_2 : ‚Äñx‚Äñ_1 = 1, ‚Äñu‚Äñ_2 = 1 }`\n(equation (eq:operator_norm_def)). </code>",
 "721": "<code>E1 ‚Üí‚Çó[‚Ñù] Module.Dual ‚Ñù E2</code>",
 "720": "<code>‚Ñï ‚Üí ‚ÜëQ</code>",
 "72":
 "<code>CauchySeq.{u, v} {Œ± : Type u} {Œ≤ : Type v} [uniformSpace : UniformSpace Œ±] [Preorder Œ≤] (u : Œ≤ ‚Üí Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Cauchy sequences. Usually defined on ‚Ñï, but often it is also useful to say that a function\ndefined on ‚Ñù is Cauchy at +‚àû to deduce convergence. Therefore, we define it in a type class that\nis general enough to cover both ‚Ñï and ‚Ñù, which are the main motivating examples. </code>",
 "719":
 "<code>A_k (Œ± : ‚Ñï ‚Üí ‚Ñù) (k : ‚Ñï) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.3.4.\nLet `{Œ±_i}_{i ‚â• 0}` be positive step-size parameters and define\n`A_k = ‚àë_{i=0}^k Œ±_i` (equation (Ak_def)). </code>",
 "718": "<code>‚Ñï ‚Üí ‚Ñù</code>",
 "717":
 "<code>R_k.{u_1} {E : Type u_1} [SeminormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] (Q : Set E) (f d : E ‚Üí ‚Ñù)\n  (L œÉ : ‚Ñù) (Œ± : ‚Ñï ‚Üí ‚Ñù) (xSeq ySeq : ‚Ñï ‚Üí ‚ÜëQ) (k : ‚Ñï) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.3.4.\nGiven a sequence `{y_k} ‚äÜ Q`, define the relation\n`(R_k): A_k f(y_k) ‚â§ œà_k` (equation (Rk)). </code>",
 "716": "<code>Set ?m.1</code>",
 "715":
 "<code>z_k.{u_1} {E : Type u_1} [SeminormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] (Q : Set E) (f d : E ‚Üí ‚Ñù)\n  (L œÉ : ‚Ñù) (Œ± : ‚Ñï ‚Üí ‚Ñù) (xSeq : ‚Ñï ‚Üí ‚ÜëQ) (k : ‚Ñï) : ‚ÜëQ</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.3.5.\nFor `k ‚â• 0`, define `z_k ‚àà Q` to be any minimizer achieving `œà_k` in (psi_k_def), namely\n`z_k ‚àà argmin_{x ‚àà Q} { (L/œÉ) d x + ‚àë_{i=0}^k Œ±_i [ f(x_i) + ‚ü™‚àá f(x_i), x - x_i‚ü´ ] }`\n(equation (zk_def)). </code>",
 "714":
 "<code>T_Q.{u_1} {E : Type u_1} [SeminormedAddCommGroup E] [NormedSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] (Q : Set E) (f : E ‚Üí ‚Ñù)\n  (L : ‚Ñù) (x : ‚ÜëQ) : ‚ÜëQ</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.3.1.\nLet `f` satisfy the assumptions of Proposition 1.3.1. For `x ‚àà Q`, define `T_Q(x) ‚àà Q` to be any\nminimizer of `y ‚Ü¶ ‚ü™‚àá f(x), y - x‚ü´ + (L / 2) ‚Äñy - x‚Äñ^2` over `y ‚àà Q`\n(equation (3.2)). If the norm is not strictly convex, the minimizer may be non-unique, and\n`T_Q(x)` denotes an arbitrary choice. </code>",
 "713": "<code>‚ÜëQ</code>",
 "712": "<code>E ‚Üí ‚Ñù</code>",
 "711":
 "<code>IsLeast.{u_1} {Œ± : Type u_1} [LE Œ±] (s : Set Œ±) (a : Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a` is a least element of a set `s`; for a partial order, it is unique if exists. </code>",
 "710":
 "<code>Polynomial.mapEquiv.{u, v} {R : Type u} {S : Type v} [Semiring R] [Semiring S] (e : R ‚âÉ+* S) :\n  Polynomial R ‚âÉ+* Polynomial S</code><span class=\"sep\"></span><code class=\"docstring\">If `R` and `S` are isomorphic, then so are their polynomial rings. </code>",
 "71": "<code>Œ≤ ‚Üí a</code>",
 "709": "<code>R ‚âÉ+* S</code>",
 "708":
 "<code>algebraMap.{u, v} (R : Type u) (A : Type v) [CommSemiring R] [Semiring A] [Algebra R A] : R ‚Üí+* A</code><span class=\"sep\"></span><code class=\"docstring\">Embedding `R ‚Üí+* A` given by `Algebra` structure. </code>",
 "707":
 "<code>AdjoinRoot.{u_1} {R : Type u_1} [CommRing R] (f : Polynomial R) : Type u_1</code><span class=\"sep\"></span><code class=\"docstring\">Adjoin a root of a polynomial `f` to a commutative ring `R`. We define the new ring\nas the quotient of `R[X]` by the principal ideal generated by `f`. </code>",
 "706":
 "<code>Iff (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">If and only if, or logical bi-implication. `a ‚Üî b` means that `a` implies `b` and vice versa.\nBy `propext`, this implies that `a` and `b` are equal and hence any expression involving `a`\nis equivalent to the corresponding expression with `b` instead.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `‚Üî` in identifiers is `iff`.\n\n * The recommended spelling of `&lt;-&gt;` in identifiers is `iff` (prefer `‚Üî` over `&lt;-&gt;`).</code>",
 "705":
 "<code>Function.IsFixedPt.{u‚ÇÅ} {Œ± : Type u‚ÇÅ} (f : Œ± ‚Üí Œ±) (x : Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A point `x` is a fixed point of `f : Œ± ‚Üí Œ±` if `f x = x`. </code>",
 "704":
 "<code>ContinuousAt.{u_1, u_2} {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] (f : X ‚Üí Y) (x : X) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function between topological spaces is continuous at a point `x‚ÇÄ`\nif `f x` tends to `f x‚ÇÄ` when `x` tends to `x‚ÇÄ`. </code>",
 "703":
 "<code>ConnectedSpace.{u} (Œ± : Type u) [TopologicalSpace Œ±] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A connected space is a nonempty one where there is no non-trivial open partition. </code>",
 "702": "<code>?m.5</code>",
 "701":
 "<code class=\"docstring\">`nth_rw` is a variant of `rw` that only changes the `n‚ÇÅ, ..., n‚Çñ`·µó ∞ _occurrence_ of the expression\nto be rewritten. Like `rw`, and unlike `nth_rewrite`, it will try to close the goal by trying `rfl`\nafterwards. `nth_rw n‚ÇÅ ... n‚Çñ [eq‚ÇÅ, eq‚ÇÇ,..., eq‚Çò]` will rewrite the `n‚ÇÅ, ..., n‚Çñ`·µó ∞ _occurrence_ of\neach of the `m` equalities `eq·µ¢`in that order. Occurrences are counted beginning with `1` in\norder of precedence. For example,\n```lean\nexample (h : a = 1) : a + a + a + a + a = 5 := by\n  nth_rw 2 3 [h]\n/-\na: ‚Ñï\nh: a = 1\n‚ä¢ a + 1 + 1 + a + a = 5\n-/\n```\nNotice that the second and third occurrences of `a` from the left have been rewritten by\n`nth_rw`.\n\nTo understand the importance of order of precedence, consider the example below\n```lean\nexample (a b c : Nat) : (a + b) + c = (b + a) + c := by\n  nth_rewrite 2 [Nat.add_comm] -- ‚ä¢ (b + a) + c = (b + a) + c\n```\nHere, although the occurrence parameter is `2`, `(a + b)` is rewritten to `(b + a)`. This happens\nbecause in order of precedence, the first occurrence of `_ + _` is the one that adds `a + b` to `c`.\nThe occurrence in `a + b` counts as the second occurrence.\n\nIf a term `t` is introduced by rewriting with `eq·µ¢`, then this instance of `t` will be counted as an\n_occurrence_ of `t` for all subsequent rewrites of `t` with `eq‚±º` for `j &gt; i`. This behaviour is\nillustrated by the example below\n```lean\nexample (h : a = a + b) : a + a + a + a + a = 0 := by\n  nth_rw 3 [h, h]\n/-\na b: ‚Ñï\nh: a = a + b\n‚ä¢ a + a + (a + b + b) + a + a = 0\n-/\n```\nHere, the first `nth_rw` with `h` introduces an additional occurrence of `a` in the goal. That is,\nthe goal state after the first rewrite looks like below\n```lean\n/-\na b: ‚Ñï\nh: a = a + b\n‚ä¢ a + a + (a + b) + a + a = 0\n-/\n```\nThis new instance of `a` also turns out to be the third _occurrence_ of `a`.  Therefore,\nthe next `nth_rw` with `h` rewrites this `a`.\n\nFurther, `nth_rw` will close the remaining goal with `rfl` if possible.\n</code>",
 "700":
 "<code>example6_2_9_fn (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 6.2.9: Let `f‚Çô(x) = 1 / (1 + n x¬≤)`. For `x ‚â† 0`, `f‚Çô(x)` converges\nto `0`, while `f‚Çô(0)` converges to `1`, so the pointwise limit is not\ncontinuous at `0`. The derivatives are `f‚Çô'(x) = - 2 n x / (1 + n x¬≤)¬≤`, which\nconverge pointwise to `0` but not uniformly on any interval containing `0`.\nThe limit function fails to be differentiable at `0`. </code>",
 "70": "<code>UniformSpace Œ±</code>",
 "7":
 "<code class=\"docstring\">This is a \"finishing\" tactic modification of `simp`. It has two forms.\n\n* `simpa [rules, ‚ãØ] using e` will simplify the goal and the type of\n`e` using `rules`, then try to close the goal using `e`.\n\nSimplifying the type of `e` makes it more likely to match the goal\n(which has also been simplified). This construction also tends to be\nmore robust under changes to the simp lemma set.\n\n* `simpa [rules, ‚ãØ]` will simplify the goal and the type of a\nhypothesis `this` if present in the context, then try to close the goal using\nthe `assumption` tactic.\n</code>",
 "699":
 "<code>example6_2_6_fn (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 6.2.6: The functions `f‚Çô : [0, 1] ‚Üí ‚Ñù` are `1` at rationals\nwhose reduced denominator is at most `n` and `0` otherwise. Each `f‚Çô` is\nRiemann integrable with integral `0`, the sequence converges pointwise to the\nDirichlet function that is `1` on `‚Ñö` and `0` on irrationals, and this limit\nis not Riemann integrable. </code>",
 "698":
 "<code>example6_2_3_fn (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 6.2.3: The sequence of piecewise linear functions\n`f‚Çô : [0,1] ‚Üí ‚Ñù` given by `f‚Çô(0) = 0`, `f‚Çô(x) = (n + 1) - (n + 1)¬≤ x`\nfor `0 &lt; x &lt; 1 / (n + 1)`, and `f‚Çô(x) = 0` for `x ‚â• 1 / (n + 1)` is\nRiemann integrable with integral `1 / 2`.  The pointwise limit on `[0,1]`\nis the zero function, so `lim_{n ‚Üí ‚àû} ‚à´‚ÇÄ¬π f‚Çô = 1/2` while\n`‚à´‚ÇÄ¬π (lim_{n ‚Üí ‚àû} f‚Çô) = 0`. </code>",
 "697":
 "<code>example6_2_1_fn (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 6.2.1: For each `n`, define `f‚Çô : [0,1] ‚Üí ‚Ñù` by\n`f‚Çô(x) = 1 - n x` when `x &lt; 1 / n` and `f‚Çô(x) = 0` when `x ‚â• 1 / n`.\nEach `f‚Çô` is continuous, the pointwise limit is the function that is `1`\nat `0` and `0` for `x &gt; 0`, and this limit is not continuous at `0`. </code>",
 "696":
 "<code>sinc (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 5.5.12. The sinc function is defined by\n`sinc x = sin x / x` for `x ‚â† 0` and `sinc 0 = 1`. Its improper integral over\nthe whole real line converges to `œÄ`, while the improper integral of its\nabsolute value diverges. </code>",
 "695":
 "<code>improperIntegral_tail_convergence {f : ‚Ñù ‚Üí ‚Ñù} {a b : ‚Ñù} (hb : b &gt; a)\n  (hInt : ‚àÄ c &gt; a, MeasureTheory.IntegrableOn f (Set.Icc a c) MeasureTheory.volume) :\n  ImproperIntegralAtTopConverges f b ‚Üî ImproperIntegralAtTopConverges f a</code><span class=\"sep\"></span><code class=\"docstring\">Proposition 5.5.3. If `f : [a, ‚àû) ‚Üí ‚Ñù` is Riemann integrable on every\n`[a, c]` with `c &gt; a`, then for any `b &gt; a` the improper integral `‚à´ b^‚àû f`\nconverges if and only if `‚à´ a^‚àû f` converges, and in the convergent case\n`‚à´ a^‚àû f = ‚à´ a..b, f + ‚à´ b^‚àû f`. </code>",
 "694":
 "<code>‚àÄ c &gt; a, MeasureTheory.IntegrableOn c (Set.Icc a_1 c) MeasureTheory.volume</code>",
 "693": "<code>b &gt; a</code>",
 "692":
 "<code>stepFunctionExample (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 5.1.12: The step function on `[0, 2]` given by\n`f x = 1` for `x &lt; 1`, `f 1 = 1 / 2`, and `f x = 0` for `x &gt; 1` is Riemann\nintegrable with integral `‚à´_0^2 f = 1`. </code>",
 "691":
 "<code class=\"docstring\">The `cases'` tactic is similar to the `cases` tactic in Lean 4 core, but the syntax for giving\nnames is different:\n\n```\nexample (h : p ‚à® q) : q ‚à® p := by\n  cases h with\n  | inl hp =&gt; exact Or.inr hp\n  | inr hq =&gt; exact Or.inl hq\n\nexample (h : p ‚à® q) : q ‚à® p := by\n  cases' h with hp hq\n  ¬∑ exact Or.inr hp\n  ¬∑ exact Or.inl hq\n\nexample (h : p ‚à® q) : q ‚à® p := by\n  rcases h with hp | hq\n  ¬∑ exact Or.inr hp\n  ¬∑ exact Or.inl hq\n```\n\nPrefer `cases` or `rcases` when possible, because these tactics promote structured proofs.\n</code>",
 "690":
 "<code>dirichletFunction (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 5.1.4: The Dirichlet function `f : [0, 1] ‚Üí ‚Ñù` with `f x = 1` on\nthe rationals and `f x = 0` otherwise satisfies `‚à´Ã≤‚ÇÄ¬π f = 0` and `‚à´ÃÖ‚ÇÄ¬π f = 1`. </code>",
 "69": "<code>Type v</code>",
 "689":
 "<code>lowerDarbouxIntegral (f : ‚Ñù ‚Üí ‚Ñù) (a b : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 5.1.3: The lower Darboux integral `‚à´Ã≤_a^b f` is the supremum of\nall lower Darboux sums over partitions of `[a, b]`; the upper Darboux integral\n`‚à´ÃÖ_a^b f` is the infimum of all upper Darboux sums over partitions of\n`[a, b]`. We also write these without an explicit integration variable. </code>",
 "688":
 "<code>Set.Ioo.{u_1} {Œ± : Type u_1} [Preorder Œ±] (a b : Œ±) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`Ioo a b` is the left-open right-open interval $(a, b)$. </code>",
 "687":
 "<code>derivWithin.{u, v} {ùïú : Type u} [NontriviallyNormedField ùïú] {F : Type v} [AddCommGroup F] [Module ùïú F]\n  [TopologicalSpace F] (f : ùïú ‚Üí F) (s : Set ùïú) (x : ùïú) : F</code><span class=\"sep\"></span><code class=\"docstring\">Derivative of `f` at the point `x` within the set `s`, if it exists.  Zero otherwise.\n\nIf the derivative exists (i.e., `‚àÉ f', HasDerivWithinAt f f' s x`), then\n`f x' = f x + (x' - x) ‚Ä¢ derivWithin f s x + o(x' - x)` where `x'` converges to `x` inside `s`.\n</code>",
 "686":
 "<code>taylorWithinEval.{u_2} {E : Type u_2} [NormedAddCommGroup E] [NormedSpace ‚Ñù E] (f : ‚Ñù ‚Üí E) (n : ‚Ñï) (s : Set ‚Ñù)\n  (x‚ÇÄ x : ‚Ñù) : E</code><span class=\"sep\"></span><code class=\"docstring\">The Taylor polynomial with derivatives inside of a set `s` considered as a function `‚Ñù ‚Üí E` </code>",
 "685": "<code>‚Ñù ‚Üí a</code>",
 "684":
 "<code>IsLocalMinOn.{u, v} {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (a : Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsLocalMinOn f s a` means that `f a ‚â§ f x` for all `x ‚àà s` in some neighborhood of `a`. </code>",
 "683":
 "<code>IsLocalMaxOn.{u, v} {Œ± : Type u} {Œ≤ : Type v} [TopologicalSpace Œ±] [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) (s : Set Œ±) (a : Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsLocalMaxOn f s a` means that `f x ‚â§ f a` for all `x ‚àà s` in some neighborhood of `a`. </code>",
 "682":
 "<code>HasDerivAt.{u, v} {ùïú : Type u} [NontriviallyNormedField ùïú] {F : Type v} [AddCommGroup F] [Module ùïú F]\n  [TopologicalSpace F] [ContinuousSMul ùïú F] (f : ùïú ‚Üí F) (f' : F) (x : ùïú) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`f` has the derivative `f'` at the point `x`.\n\nThat is, `f x' = f x + (x' - x) ‚Ä¢ f' + o(x' - x)` where `x'` converges to `x`.\n</code>",
 "681": "<code>Type</code>",
 "680":
 "<code>Float : Type</code><span class=\"sep\"></span><code class=\"docstring\">64-bit floating-point numbers.\n\n`Float` corresponds to the IEEE 754 *binary64* format (`double` in C or `f64` in Rust).\nFloating-point numbers are a finite representation of a subset of the real numbers, extended with\nextra ‚Äúsentinel‚Äù values that represent undefined and infinite results as well as separate positive\nand negative zeroes. Arithmetic on floating-point numbers approximates the corresponding operations\non the real numbers by rounding the results to numbers that are representable, propagating error and\ninfinite values.\n\nFloating-point numbers include [subnormal numbers](https://en.wikipedia.org/wiki/Subnormal_number).\nTheir special values are:\n * `NaN`, which denotes a class of ‚Äúnot a number‚Äù values that result from operations such as\n   dividing zero by zero, and\n * `Inf` and `-Inf`, which represent positive and infinities that result from dividing non-zero\n   values by zero.\n</code>",
 "68":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 ‚Üí def1', def2 ‚Üí def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : Œ±) : Œ± := a\n  def K (a : Œ±) : Œ≤ ‚Üí Œ± := fun _ =&gt; a\n  def S (x : Œ± ‚Üí Œ≤ ‚Üí Œ≥) (y : Œ± ‚Üí Œ≤) (z : Œ±) : Œ≥ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I ‚Üí identity,\n      K ‚Üí konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ‚âã \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `‚âã` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ‚âã Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>",
 "679":
 "<code class=\"docstring\">`use e‚ÇÅ, e‚ÇÇ, ‚ãØ` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic\n`refine ‚ü®e‚ÇÅ, e‚ÇÇ, ‚ãØ, ?_, ‚ãØ, ?_‚ü©` with any number of placeholders (rather than just one) and\nthen trying to close goals associated to the placeholders with a configurable discharger (rather\nthan just `try trivial`).\n\nExamples:\n\n```lean\nexample : ‚àÉ x : Nat, x = x := by use 42\n\nexample : ‚àÉ x : Nat, ‚àÉ y : Nat, x = y := by use 42, 42\n\nexample : ‚àÉ x : String √ó String, x.1 = x.2 := by use (\"forty-two\", \"forty-two\")\n```\n\n`use! e‚ÇÅ, e‚ÇÇ, ‚ãØ` is similar but it applies constructors everywhere rather than just for\ngoals that correspond to the last argument of a constructor. This gives the effect that\nnested constructors are being flattened out, with the supplied values being used along the\nleaves and nodes of the tree of constructors.\nWith `use!` one can feed in each `42` one at a time:\n\n```lean\nexample : ‚àÉ p : Nat √ó Nat, p.1 = p.2 := by use! 42, 42\n\nexample : ‚àÉ p : Nat √ó Nat, p.1 = p.2 := by use! (42, 42)\n```\n\nThe second line makes use of the fact that `use!` tries refining with the argument before\napplying a constructor. Also note that `use`/`use!` by default uses a tactic\ncalled `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since\n`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.\n\nThese tactics take an optional discharger to handle remaining explicit `Prop` constructor arguments.\nBy default it is `use (discharger := try with_reducible use_discharger) e‚ÇÅ, e‚ÇÇ, ‚ãØ`.\nTo turn off the discharger and keep all goals, use `(discharger := skip)`.\nTo allow \"heavy refls\", use `(discharger := try use_discharger)`.\n</code>",
 "678":
 "<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>",
 "677":
 "<code>limitValueDiff (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 3.1.6: The piecewise function on `[0, 1)` given by `f x = x` for\n`x &gt; 0` and `f 0 = 1` satisfies `f ‚ü∂ 0` as `x ‚Üí 0` within `[0, 1)`, even though\n`f 0 = 1`. </code>",
 "676":
 "<code>LimitWithin (S : Set ‚Ñù) (f : ‚Ñù ‚Üí ‚Ñù) (c L : ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 3.1.3: A function `f : ‚Ñù ‚Üí ‚Ñù` converges to `L` as `x` approaches\n`c` within a set `S` if `c` is a cluster point of `S` and for every `Œµ &gt; 0`\nthere is `Œ¥ &gt; 0` such that for all `x ‚àà S` with `x ‚â† c` and `|x - c| &lt; Œ¥` we\nhave `|f x - L| &lt; Œµ`. </code>",
 "675":
 "<code>Filter.liminf.{u_1, u_2} {Œ± : Type u_1} {Œ≤ : Type u_2} [ConditionallyCompleteLattice Œ±] (u : Œ≤ ‚Üí Œ±) (f : Filter Œ≤) : Œ±</code><span class=\"sep\"></span><code class=\"docstring\">The `liminf` of a function `u` along a filter `f` is the supremum of the `a` such that\nthe inequality `u x ‚â• a` eventually holds for `f`. </code>",
 "674":
 "<code>Filter.limsup.{u_1, u_2} {Œ± : Type u_1} {Œ≤ : Type u_2} [ConditionallyCompleteLattice Œ±] (u : Œ≤ ‚Üí Œ±) (f : Filter Œ≤) : Œ±</code><span class=\"sep\"></span><code class=\"docstring\">The `limsup` of a function `u` along a filter `f` is the infimum of the `a` such that\nthe inequality `u x ‚â§ a` eventually holds for `f`. </code>",
 "673":
 "<code>Filter.atBot.{u_3} {Œ± : Type u_3} [Preorder Œ±] : Filter Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`atBot` is the filter representing the limit `‚Üí -‚àû` on an ordered set.\nIt is generated by the collection of down-sets `{b | b ‚â§ a}`.\n(The preorder need not have a bottom element for this to be well defined,\nand indeed is trivial when a bottom element exists.) </code>",
 "672":
 "<code>Filter.atTop.{u_3} {Œ± : Type u_3} [Preorder Œ±] : Filter Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`atTop` is the filter representing the limit `‚Üí ‚àû` on an ordered set.\nIt is generated by the collection of up-sets `{b | a ‚â§ b}`.\n(The preorder need not have a top element for this to be well defined,\nand indeed is trivial when a top element exists.) </code>",
 "671": "<code>Sort u_3</code>",
 "670":
 "<code class=\"docstring\">The `induction'` tactic is similar to the `induction` tactic in Lean 4 core,\nbut with slightly different syntax (such as, no requirement to name the constructors).\n\n```\nopen Nat\n\nexample (n : ‚Ñï) : 0 &lt; factorial n := by\n  induction' n with n ih\n  ¬∑ rw [factorial_zero]\n    simp\n  ¬∑ rw [factorial_succ]\n    apply mul_pos (succ_pos n) ih\n\nexample (n : ‚Ñï) : 0 &lt; factorial n := by\n  induction n\n  case zero =&gt;\n    rw [factorial_zero]\n    simp\n  case succ n ih =&gt;\n    rw [factorial_succ]\n    apply mul_pos (succ_pos n) ih\n```\n</code>",
 "67":
 "<code>Set.inter.{u} {Œ± : Type u} (s‚ÇÅ s‚ÇÇ : Set Œ±) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">The intersection of two sets `s` and `t` is the set of elements contained in both `s` and `t`.\n\nNote that you should **not** use this definition directly, but instead write `s ‚à© t`. </code>",
 "669":
 "<code>Antitone.{u, v} {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f` is antitone if `a ‚â§ b` implies `f b ‚â§ f a`. </code>",
 "668":
 "<code>Monotone.{u, v} {Œ± : Type u} {Œ≤ : Type v} [Preorder Œ±] [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f` is monotone if `a ‚â§ b` implies `f a ‚â§ f b`. </code>",
 "667":
 "<code>Filter.Tendsto.{u_1, u_2} {Œ± : Type u_1} {Œ≤ : Type u_2} (f : Œ± ‚Üí Œ≤) (l‚ÇÅ : Filter Œ±) (l‚ÇÇ : Filter Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Filter.Tendsto` is the generic \"limit of a function\" predicate.\n`Tendsto f l‚ÇÅ l‚ÇÇ` asserts that for every `l‚ÇÇ` neighborhood `a`,\nthe `f`-preimage of `a` is an `l‚ÇÅ` neighborhood. </code>",
 "666": "<code>Filter Œ≤</code>",
 "665":
 "<code>decimalWithIncreasingZeroBlocks : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Example 1.5.4: The real number with decimal expansion `0.101001000100001‚Ä¶`,\nwhose `1`s occur at the positions `1, 3, 6, 10, ‚Ä¶` (each separated by an\nincreasing block of zeros), is irrational. </code>",
 "664":
 "<code class=\"docstring\">Splits all if-then-else-expressions into multiple goals.\nGiven a goal of the form `g (if p then x else y)`, `split_ifs` will produce\ntwo goals: `p ‚ä¢ g x` and `¬¨p ‚ä¢ g y`.\nIf there are multiple ite-expressions, then `split_ifs` will split them all,\nstarting with a top-most one whose condition does not contain another\nite-expression.\n`split_ifs at *` splits all ite-expressions in all hypotheses as well as the goal.\n`split_ifs with h‚ÇÅ h‚ÇÇ h‚ÇÉ` overrides the default names for the hypotheses.\n</code>",
 "663":
 "<code>sqrtTwo : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The book's notation `‚àö2` realized via the mathlib square root. </code>",
 "662": "<code>‚ÑÇ</code>",
 "661":
 "<code>HAdd.{u, v, w} (Œ± : Type u) (Œ≤ : Type v) (Œ≥ : outParam (Type w)) : Type (max (max u v) w)</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for heterogeneous addition.\nThis enables the notation `a + b : Œ≥` where `a : Œ±`, `b : Œ≤`.\n</code>",
 "660":
 "<code>Field.{u} (K : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A `Field` is a `CommRing` with multiplicative inverses for nonzero elements.\n\nAn instance of `Field K` includes maps `ratCast : ‚Ñö ‚Üí K` and `qsmul : ‚Ñö ‚Üí K ‚Üí K`.\nThose two fields are needed to implement the `DivisionRing K ‚Üí Algebra ‚Ñö K` instance since we need\nto control the specific definitions for some special cases of `K` (in particular `K = ‚Ñö` itself).\nSee also note [forgetful inheritance].\n\nIf the field has positive characteristic `p`, our division by zero convention forces\n`ratCast (1 / p) = 1 / 0 = 0`. </code>",
 "66":
 "<code class=\"docstring\">`omit` instructs Lean to not include a variable previously `include`d. Apart from variable names, it\ncan also refer to typeclass instance variables by type using the syntax `omit [TypeOfInst]`, in\nwhich case all instance variables that unify with the given type are omitted. `omit` should usually\nonly be used in conjunction with `in` in order to keep the section structure simple.\n</code>",
 "659": "<code>‚Ñö</code>",
 "658":
 "<code class=\"docstring\">`namespace &lt;id&gt;` opens a section with label `&lt;id&gt;` that influences naming and name resolution inside\nthe section:\n* Declarations names are prefixed: `def seventeen : ‚Ñï := 17` inside a namespace `Nat` is given the\n  full name `Nat.seventeen`.\n* Names introduced by `export` declarations are also prefixed by the identifier.\n* All names starting with `&lt;id&gt;.` become available in the namespace without the prefix. These names\n  are preferred over names introduced by outer namespaces or `open`.\n* Within a namespace, declarations can be `protected`, which excludes them from the effects of\n  opening the namespace.\n\nAs with `section`, namespaces can be nested and the scope of a namespace is terminated by a\ncorresponding `end &lt;id&gt;` or the end of the file.\n\n`namespace` also acts like `section` in delimiting the scope of `variable`, `open`, and other scoped commands.\n</code>",
 "657":
 "<code>Set.Infinite.{u} {Œ± : Type u} (s : Set Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set is infinite if it is not finite.\n\nThis is protected so that it does not conflict with global `Infinite`. </code>",
 "656":
 "<code>Set.Finite.{u} {Œ± : Type u} (s : Set Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set is finite if the corresponding `Subtype` is finite,\ni.e., if there exists a natural `n : ‚Ñï` and an equivalence `s ‚âÉ Fin n`. </code>",
 "655":
 "<code>Cardinal.mk.{u} : Type u ‚Üí Cardinal.{u}</code><span class=\"sep\"></span><code class=\"docstring\">The cardinal number of a type </code>",
 "654":
 "<code>Cardinal.{u} : Type (u + 1)</code><span class=\"sep\"></span><code class=\"docstring\">`Cardinal.{u}` is the type of cardinal numbers in `Type u`,\ndefined as the quotient of `Type u` by existence of an equivalence\n(a bijection with explicit inverse). </code>",
 "653":
 "<code>Setoid.{u} (Œ± : Sort u) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">A setoid is a type with a distinguished equivalence relation, denoted `‚âà`.\n\nThe `Quotient` type constructor requires a `Setoid` instance.\n</code>",
 "652":
 "<code>finiteExampleSet : Set ‚Ñï</code><span class=\"sep\"></span><code class=\"docstring\">Example 0.3.20: On the finite set `A = {1,2,3}` the relation `&lt;` corresponds to the\nset of pairs `{(1,2), (1,3), (2,3)}`, so `1 &lt; 2` holds but `3 &lt; 1` does not. The relation\n`=` is given by `{(1,1), (2,2), (3,3)}`. Any subset of `A √ó A` is a relation; for example\n`‚Ä† = {(1,2), (2,1), (2,3), (3,1)}` satisfies `1 ‚Ä† 2` and `3 ‚Ä† 1` but not `1 ‚Ä† 3`. </code>",
 "651":
 "<code>Equivalence.{u} {Œ± : Sort u} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An equivalence relation `r : Œ± ‚Üí Œ± ‚Üí Prop` is a relation that is\n\n* reflexive: `r x x`,\n* symmetric: `r x y` implies `r y x`, and\n* transitive: `r x y` and `r y z` implies `r x z`.\n\nEquality is an equivalence relation, and equivalence relations share many of the properties of\nequality.\n</code>",
 "650": "<code>Sort u</code>",
 "65":
 "<code class=\"docstring\">Declares one or more typed variables, or modifies whether already-declared variables are\n  implicit.\n\nIntroduces variables that can be used in definitions within the same `namespace` or `section` block.\nWhen a definition mentions a variable, Lean will add it as an argument of the definition. This is\nuseful in particular when writing many definitions that have parameters in common (see below for an\nexample).\n\nVariable declarations have the same flexibility as regular function parameters. In particular they\ncan be [explicit, implicit][binder docs], or [instance implicit][tpil classes] (in which case they\ncan be anonymous). This can be changed, for instance one can turn explicit variable `x` into an\nimplicit one with `variable {x}`. Note that currently, you should avoid changing how variables are\nbound and declare new variables at the same time; see [issue 2789] for more on this topic.\n\nIn *theorem bodies* (i.e. proofs), variables are not included based on usage in order to ensure that\nchanges to the proof cannot change the statement of the overall theorem. Instead, variables are only\navailable to the proof if they have been mentioned in the theorem header or in an `include` command\nor are instance implicit and depend only on such variables.\n\nSee [*Variables and Sections* from Theorem Proving in Lean][tpil vars] for a more detailed\ndiscussion.\n\n[tpil vars]:\nhttps://lean-lang.org/theorem_proving_in_lean4/dependent_type_theory.html#variables-and-sections\n(Variables and Sections on Theorem Proving in Lean) [tpil classes]:\nhttps://lean-lang.org/theorem_proving_in_lean4/type_classes.html (Type classes on Theorem Proving in\nLean) [binder docs]:\nhttps://leanprover-community.github.io/mathlib4_docs/Lean/Expr.html#Lean.BinderInfo (Documentation\nfor the BinderInfo type) [issue 2789]: https://github.com/leanprover/lean4/issues/2789 (Issue 2789\non github)\n\n## Examples\n\n```lean\nsection\n  variable\n    {Œ± : Type u}      -- implicit\n    (a : Œ±)           -- explicit\n    [instBEq : BEq Œ±] -- instance implicit, named\n    [Hashable Œ±]      -- instance implicit, anonymous\n\n  def isEqual (b : Œ±) : Bool :=\n    a == b\n\n  #check isEqual\n  -- isEqual.{u} {Œ± : Type u} (a : Œ±) [instBEq : BEq Œ±] (b : Œ±) : Bool\n\n  variable\n    {a} -- `a` is implicit now\n\n  def eqComm {b : Œ±} := a == b ‚Üî b == a\n\n  #check eqComm\n  -- eqComm.{u} {Œ± : Type u} {a : Œ±} [instBEq : BEq Œ±] {b : Œ±} : Prop\nend\n```\n\nThe following shows a typical use of `variable` to factor out definition arguments:\n\n```lean\nvariable (Src : Type)\n\nstructure Logger where\n  trace : List (Src √ó String)\n#check Logger\n-- Logger (Src : Type) : Type\n\nnamespace Logger\n  -- switch `Src : Type` to be implicit until the `end Logger`\n  variable {Src}\n\n  def empty : Logger Src where\n    trace := []\n  #check empty\n  -- Logger.empty {Src : Type} : Logger Src\n\n  variable (log : Logger Src)\n\n  def len :=\n    log.trace.length\n  #check len\n  -- Logger.len {Src : Type} (log : Logger Src) : Nat\n\n  variable (src : Src) [BEq Src]\n\n  -- at this point all of `log`, `src`, `Src` and the `BEq` instance can all become arguments\n\n  def filterSrc :=\n    log.trace.filterMap\n      fun (src', str') =&gt; if src' == src then some str' else none\n  #check filterSrc\n  -- Logger.filterSrc {Src : Type} (log : Logger Src) (src : Src) [inst‚úù : BEq Src] : List String\n\n  def lenSrc :=\n    log.filterSrc src |&gt;.length\n  #check lenSrc\n  -- Logger.lenSrc {Src : Type} (log : Logger Src) (src : Src) [inst‚úù : BEq Src] : Nat\nend Logger\n```\n\nThe following example demonstrates availability of variables in proofs:\n```lean\nvariable\n  {Œ± : Type}    -- available in the proof as indirectly mentioned through `a`\n  [ToString Œ±]  -- available in the proof as `Œ±` is included\n  (a : Œ±)       -- available in the proof as mentioned in the header\n  {Œ≤ : Type}    -- not available in the proof\n  [ToString Œ≤]  -- not available in the proof\n\ntheorem ex : a = a := rfl\n```\nAfter elaboration of the proof, the following warning will be generated to highlight the unused\nhypothesis:\n```\nincluded section variable '[ToString Œ±]' is not used in 'ex', consider excluding it\n```\nIn such cases, the offending variable declaration should be moved down or into a section so that\nonly theorems that do depend on it follow it until the end of the section.\n</code>",
 "649":
 "<code>Transitive.{u_1} {Œ± : Sort u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsTrans` as a definition, suitable for use in proofs. </code>",
 "648":
 "<code>Symmetric.{u_1} {Œ± : Sort u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsSymm` as a definition, suitable for use in proofs. </code>",
 "647":
 "<code>Subtype.{u} {Œ± : Sort u} (p : Œ± ‚Üí Prop) : Sort (max 1 u)</code><span class=\"sep\"></span><code class=\"docstring\">All the elements of a type that satisfy a predicate.\n\n`Subtype p`, usually written `{ x : Œ± // p x }` or `{ x // p x }`, contains all elements `x : Œ±` for\nwhich `p x` is true. Its constructor is a pair of the value and the proof that it satisfies the\npredicate. In run-time code, `{ x : Œ± // p x }` is represented identically to `Œ±`.\n\nThere is a coercion from `{ x : Œ± // p x }` to `Œ±`, so elements of a subtype may be used where the\nunderlying type is expected.\n\nExamples:\n * `{ n : Nat // n % 2 = 0 }` is the type of even numbers.\n * `{ xs : Array String // xs.size = 5 }` is the type of arrays with five `String`s.\n * Given `xs : List Œ±`, `List { x : Œ± // x ‚àà xs }` is the type of lists in which all elements are\n   contained in `xs`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `{ x // p x }` in identifiers is `subtype`.</code>",
 "646":
 "<code>Reflexive.{u_1} {Œ± : Sort u_1} (r : Œ± ‚Üí Œ± ‚Üí Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsRefl` as a definition, suitable for use in proofs. </code>",
 "645": "<code>Œ± ‚Üí Œ± ‚Üí Prop</code>",
 "644":
 "<code>Function.Bijective.{u‚ÇÅ, u‚ÇÇ} {Œ± : Sort u‚ÇÅ} {Œ≤ : Sort u‚ÇÇ} (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function is called bijective if it is both injective and surjective. </code>",
 "643": "<code>Sort u‚ÇÇ</code>",
 "642": "<code>Sort u‚ÇÅ</code>",
 "641":
 "<code>Function.Surjective.{u_1, u_2} {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f : Œ± ‚Üí Œ≤` is called surjective if every `b : Œ≤` is equal to `f a`\nfor some `a : Œ±`. </code>",
 "640":
 "<code>Function.Injective.{u_1, u_2} {Œ± : Sort u_1} {Œ≤ : Sort u_2} (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f : Œ± ‚Üí Œ≤` is called injective if `f x = f y` implies `x = y`. </code>",
 "64":
 "<code class=\"docstring\">`f.Eventually p` or `‚àÄ·∂† x in f, p x` mean that `{x | p x} ‚àà f`. E.g., `‚àÄ·∂† x in atTop, p x`\nmeans that `p` holds true for sufficiently large `x`. </code>",
 "639":
 "<code>Set.image.{u, v} {Œ± : Type u} {Œ≤ : Type v} (f : Œ± ‚Üí Œ≤) (s : Set Œ±) : Set Œ≤</code><span class=\"sep\"></span><code class=\"docstring\">The image of `s : Set Œ±` by `f : Œ± ‚Üí Œ≤`, written `f '' s`, is the set of `b : Œ≤` such that\n`f a = b` for some `a ‚àà s`. </code>",
 "638":
 "<code class=\"docstring\">`tauto` breaks down assumptions of the form `_ ‚àß _`, `_ ‚à® _`, `_ ‚Üî _` and `‚àÉ _, _`\nand splits a goal of the form `_ ‚àß _`, `_ ‚Üî _` or `‚àÉ _, _` until it can be discharged\nusing `rfl` or `solve_by_elim`.\nThis is a finishing tactic: it either closes the goal or raises an error.\n\nThe Lean 3 version of this tactic by default attempted to avoid classical reasoning\nwhere possible. This Lean 4 version makes no such attempt. The `itauto` tactic\nis designed for that purpose.\n</code>",
 "637":
 "<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ‚àß b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`‚ü®ha, hb‚ü© : a ‚àß b`, and if `h : a ‚àß b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `‚àß` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `‚àß` over `/\\`).</code>",
 "636":
 "<code>Rat : Type</code><span class=\"sep\"></span><code class=\"docstring\">Rational numbers, implemented as a pair of integers `num / den` such that the\ndenominator is positive and the numerator and denominator are coprime.\n</code>",
 "635": "<code class=\"docstring\">The universe parameter w</code>",
 "634": "<code class=\"docstring\">The universe parameter v</code>",
 "633":
 "<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>",
 "632": "<code>Type ?u.755357</code>",
 "631":
 "<code>Fin.succ {n : ‚Ñï} : Fin n ‚Üí Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The successor, with an increased bound.\n\nThis differs from adding `1`, which instead wraps around.\n\nExamples:\n* `(2 : Fin 3).succ = (3 : Fin 4)`\n* `(2 : Fin 3) + 1 = (0 : Fin 3)`\n</code>",
 "630":
 "<code>weightedSumSetWithRecession (n m : ‚Ñï) (C : Fin m ‚Üí Set (Fin n ‚Üí ‚Ñù)) (lam : Fin m ‚Üí ‚Ñù) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Weighted sums using `Œª i ‚Ä¢ C i` for nonzero coefficients and `0^+ C i` for zero\ncoefficients. </code>",
 "63":
 "<code>Set.univ.{u} {Œ± : Type u} : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">The universal set on a type `Œ±` is the set containing all elements of `Œ±`.\n\nThis is conceptually the \"same as\" `Œ±` (in set theory, it is actually the same), but type theory\nmakes the distinction that `Œ±` is a type while `Set.univ` is a term of type `Set Œ±`. `Set.univ` can\nitself be coerced to a type `‚Ü•Set.univ` which is in bijection with (but distinct from) `Œ±`. </code>",
 "629": "<code>Fin m ‚Üí Set (Fin a ‚Üí ‚Ñù)</code>",
 "628": "<code>Type ?u.236989</code>",
 "627": "<code>Type ?u.234311</code>",
 "626":
 "<code>Fin.last (n : ‚Ñï) : Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">The greatest value of `Fin (n+1)`, namely `n`.\n\nExamples:\n* `Fin.last 4 = (4 : Fin 5)`\n* `(Fin.last 0).val = (0 : Nat)`\n</code>",
 "625":
 "<code>helperForCorollary_19_3_4_transformedProjectedEpigraph_eq_sum {n : ‚Ñï} (f‚ÇÅ f‚ÇÇ : (Fin n ‚Üí ‚Ñù) ‚Üí EReal)\n  (hproper‚ÇÅ : ProperConvexFunctionOn Set.univ f‚ÇÅ) (hproper‚ÇÇ : ProperConvexFunctionOn Set.univ f‚ÇÇ) :\n  have A‚ÇÅ := LinearMap.pi fun i =&gt; LinearMap.proj (Fin.castAdd n i);\n  have A‚ÇÇ := LinearMap.pi fun i =&gt; LinearMap.proj (Fin.natAdd n i);\n  have B := A‚ÇÅ + A‚ÇÇ;\n  have h := fun z =&gt; f‚ÇÅ (A‚ÇÅ z) + f‚ÇÇ (A‚ÇÇ z);\n  (fun p =&gt; prodLinearEquiv_append p) '' (‚áë(linearMap_prod B) '' epigraph Set.univ h) =\n    (fun p =&gt; prodLinearEquiv_append p) '' epigraph Set.univ f‚ÇÅ +\n      (fun p =&gt; prodLinearEquiv_append p) '' epigraph Set.univ f‚ÇÇ</code><span class=\"sep\"></span><code class=\"docstring\">Helper for Corollary 19.3.4: the transformed projected epigraph of the split-sum model equals\nthe Minkowski sum of the transformed epigraphs of `f‚ÇÅ` and `f‚ÇÇ`. </code>",
 "624": "<code>(Fin n ‚Üí ‚Ñù) √ó ‚Ñù</code>",
 "623": "<code>Fin (n + n) ‚Üí ‚Ñù</code>",
 "622": "<code>(Fin (n + n) ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "621": "<code>(Fin (n + n) ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin n ‚Üí ‚Ñù</code>",
 "620": "<code>ProperConvexFunctionOn Set.univ f‚ÇÇ</code>",
 "62":
 "<code>IsOpen.{u} {X : Type u} [TopologicalSpace X] : Set X ‚Üí Prop</code><span class=\"sep\"></span><code class=\"docstring\">`IsOpen s` means that `s` is open in the ambient topological space on `X` </code>",
 "619": "<code>ProperConvexFunctionOn Set.univ f‚ÇÅ</code>",
 "618":
 "<code>linearMap_prod_embedded {n m : ‚Ñï} (A : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin m ‚Üí ‚Ñù) :\n  EuclideanSpace ‚Ñù (Fin (n + 1)) ‚Üí‚Çó[‚Ñù] EuclideanSpace ‚Ñù (Fin (m + 1))</code><span class=\"sep\"></span><code class=\"docstring\">Conjugate `linearMap_prod` under the append equivalence. </code>",
 "617": "<code>(Fin m ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "616":
 "<code>imageUnderLinearMap {n m : ‚Ñï} (A : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin m ‚Üí ‚Ñù) (h : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin m ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.7.1: The function `Ah` in Theorem 5.7 is called the image of `h` under `A`. </code>",
 "615":
 "<code>inverseImageUnderLinearMap {n m : ‚Ñï} (A : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin m ‚Üí ‚Ñù) (g : (Fin m ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.7.1: The function `gA` in Theorem 5.7 is called the inverse image of `g` under `A`. </code>",
 "614":
 "<code>constNegInf (n : ‚Ñï) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 12.1.3: Let `f_{-‚àû}` and `f_{+‚àû}` denote the constant functions on `‚Ñù^n` taking values\n`-‚àû` and `+‚àû` respectively. Then they are conjugate to each other (with conjugation given here by\n`fenchelConjugate`), i.e. `(f_{-‚àû})^* = f_{+‚àû}` and `(f_{+‚àû})^* = f_{-‚àû}`. </code>",
 "613":
 "<code>IsFinitelyGeneratedConvexSet (n : ‚Ñï) (C : Set (Fin n ‚Üí ‚Ñù)) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Text 19.0.4: A convex set `C ‚äÜ ‚Ñù^n` is called finitely generated if it is the mixed convex\nhull of finitely many points and directions (Definition 17.0.4). Equivalently, there exist\nvectors `a‚ÇÅ, ‚Ä¶, a_m` and an integer `k` with `0 ‚â§ k ‚â§ m` such that `C` consists exactly of all\nvectors of the form `x = Œª‚ÇÅ a‚ÇÅ + ¬∑¬∑¬∑ + Œª_m a_m` with `Œª‚ÇÅ + ¬∑¬∑¬∑ + Œª_k = 1` and `Œª_i ‚â• 0` for\n`i = 1, ‚Ä¶, m`. </code>",
 "612":
 "<code>Fin.append.{u_1} {m n : ‚Ñï} {Œ± : Sort u_1} (a : Fin m ‚Üí Œ±) (b : Fin n ‚Üí Œ±) : Fin (m + n) ‚Üí Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Append a tuple of length `m` to a tuple of length `n` to get a tuple of length `m + n`.\nThis is a non-dependent version of `Fin.add_cases`. </code>",
 "611": "<code>Fin n ‚Üí Œ±</code>",
 "610": "<code>Fin m ‚Üí Œ±</code>",
 "61":
 "<code>IsClosed.{u} {X : Type u} [TopologicalSpace X] (s : Set X) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set is closed if its complement is open </code>",
 "609":
 "<code>Fin.natAdd {m : ‚Ñï} (n : ‚Ñï) (i : Fin m) : Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Adds a natural number to a `Fin`, increasing the bound.\n\nThis is a generalization of `Fin.succ`.\n\n`Fin.addNat` is a version of this function that takes its `Nat` parameter second.\n\nExamples:\n* `Fin.natAdd 3 (5 : Fin 8) = (8 : Fin 11)`\n* `Fin.natAdd 1 (0 : Fin 8) = (1 : Fin 9)`\n* `Fin.natAdd 1 (2 : Fin 8) = (3 : Fin 9)`\n</code>",
 "608":
 "<code>Fin.castAdd {n : ‚Ñï} (m : ‚Ñï) : Fin n ‚Üí Fin (n + m)</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound to one at least as large.\n\nSee also `Fin.natAdd` and `Fin.addNat` for addition functions that increase the bound, and\n`Fin.castLE` for a version that uses an explicit inequality proof.\n</code>",
 "607":
 "<code class=\"docstring\">`have` is used to declare local hypotheses and opaque local definitions.\n\nIt has the same syntax as `let`, and it is equivalent to `let +nondep`,\ncreating a *nondependent* let expression.\n</code>",
 "606":
 "<code>Fin.castSucc {n : ‚Ñï} : Fin n ‚Üí Fin (n + 1)</code><span class=\"sep\"></span><code class=\"docstring\">Coarsens a bound by one.\n</code>",
 "605":
 "<code class=\"docstring\">Empty match/ex falso. `nomatch e` is of arbitrary type `Œ± : Sort u` if\nLean can show that an empty set of patterns is exhaustive given `e`'s type,\ne.g. because it has no constructors.\n</code>",
 "604":
 "<code>IsPolyhedralConvexFunction (n : ‚Ñï) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Text 19.0.8: A convex function `f : ‚Ñù^n ‚Üí (-‚àû, +‚àû]` is called polyhedral convex if its\nepigraph `epi f = {(x, Œº) ‚àà ‚Ñù^{n+1} | f x ‚â§ Œº}` is a polyhedral convex set in `‚Ñù^{n+1}`. </code>",
 "603":
 "<code>IsDirectionOf.{u_1, u_2} {ùïú : Type u_1} {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SMul ùïú E]\n  (C' : Set E) (d : E) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Defn 18.4 (extreme direction). If `C'` is a half-line face of a convex set `C`, the direction\nof `C'` is called an *extreme direction* of `C` (an ‚Äúextreme point of `C` at infinity‚Äù).\n\nThis helper predicate says that `d` is a (nonzero) direction vector of a half-line set `C'`,\nmeaning `C'` can be parameterized as `x + t ‚Ä¢ d` for `t ‚â• 0`. </code>",
 "602":
 "<code>convexConeGenerated (n : ‚Ñï) (S : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 2.6.10. The convex cone obtained by adjoining the origin to the cone in\nCorollary 2.6.2 (equivalently, Corollary 2.6.3) is called the convex cone generated by `S`\n(or by a convex set `C`) and is denoted `cone S`. </code>",
 "601":
 "<code>vectorSpan.{u_1, u_2, u_3} (k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n  [AddTorsor V P] (s : Set P) : Submodule k V</code><span class=\"sep\"></span><code class=\"docstring\">The submodule spanning the differences of a (possibly empty) set of points. </code>",
 "600":
 "<code>IsExtremeDirection.{u_1, u_2} {ùïú : Type u_1} {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SMul ùïú E]\n  (C : Set E) (d : E) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Defn 18.4 (extreme direction). A vector `d` is an *extreme direction* of a convex set `C` if it\nis the direction of some half-line face `C'` of `C`. </code>",
 "60":
 "<code class=\"docstring\">* `change tgt'` will change the goal from `tgt` to `tgt'`,\n  assuming these are definitionally equal.\n* `change t' at h` will change hypothesis `h : t` to have type `t'`, assuming\n  assuming `t` and `t'` are definitionally equal.\n</code>",
 "6":
 "<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`. It is equivalent to `intro _`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, given a type ascription, or matched against a pattern:\n  ```lean\n  -- ... ‚ä¢ Œ± √ó Œ≤ ‚Üí ...\n  intro (a, b)\n  -- ..., a : Œ±, b : Œ≤ ‚ä¢ ...\n  ```\n* `intro rfl` is short for `intro h; subst h`, if `h` is an equality where the left-hand or right-hand side\n  is a variable.\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>",
 "599":
 "<code>euclideanRelativeBoundary (n : ‚Ñï) (C : Set (EuclideanSpace ‚Ñù (Fin n))) : Set (EuclideanSpace ‚Ñù (Fin n))</code><span class=\"sep\"></span><code class=\"docstring\">Text 6.10: The relative boundary of `C` is the set difference `(cl C) \\ (ri C)`. </code>",
 "598":
 "<code>rayNonneg (n : ‚Ñï) (S : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The nonnegative ray generated by a set. </code>",
 "597": "<code>?m.23</code>",
 "596":
 "<code>mixedConvexHull {n : ‚Ñï} (S‚ÇÄ S‚ÇÅ : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 17.0.4 (Mixed convex hull). Let `S = S‚ÇÄ ‚à™ S‚ÇÅ`, where `S‚ÇÄ ‚äÜ ‚Ñù‚Åø` is a set of\npoints and `S‚ÇÅ` is a set of directions. The (mixed) convex hull `conv(S)` is the smallest\nconvex set `C ‚äÜ ‚Ñù‚Åø` such that:\n\n(1) `C ‚äá S‚ÇÄ`;\n(2) `C` recedes in all directions in `S‚ÇÅ`, i.e. for every `d ‚àà S‚ÇÅ`, `x ‚àà C`, and `t ‚â• 0`,\n`x + t ‚Ä¢ d ‚àà C`. </code>",
 "595":
 "<code>euclideanRelativeInterior_fin (n : ‚Ñï) (C : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Relative interior in `Fin n ‚Üí ‚Ñù`, transported via `EuclideanSpace.equiv`. </code>",
 "594":
 "<code class=\"docstring\">The line between two points, as an affine subspace. </code>",
 "593":
 "<code>FaceOf.sInf.{u_1, u_2} {ùïú : Type u_1} {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SMul ùïú E]\n  (C : Set E) (hC : Convex ùïú C) (S : Set (FaceOf C)) : FaceOf C</code><span class=\"sep\"></span><code class=\"docstring\">The infimum of a set of faces, defined by intersecting all faces (and `C`). </code>",
 "592": "<code>Set (FaceOf C)</code>",
 "591": "<code>Convex ùïú C</code>",
 "590":
 "<code>faceRelativeInteriors (n : ‚Ñï) (C : Set (EuclideanSpace ‚Ñù (Fin n))) : Set (Set (EuclideanSpace ‚Ñù (Fin n)))</code><span class=\"sep\"></span><code class=\"docstring\">The collection `ùì§` of all relative interiors of nonempty convex faces of a convex set `C`\nin `‚Ñù‚Åø`. </code>",
 "59":
 "<code class=\"docstring\">Applies the second constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample {p q : Prop} (h : q) : p ‚à® q := by\n  right\n  exact h\n```\n</code>",
 "589":
 "<code>IsFace.{u_1, u_2} {ùïú : Type u_1} {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SMul ùïú E]\n  (C C' : Set E) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Defn 18.1 (the face of a convex set). Let `C` be a convex set. A subset `C' ‚äÜ C` is a *face*\nof `C` if, for every closed line segment in `C`, whenever the relative interior of the segment\n(i.e. the open segment) is contained in `C'`, then both endpoints of the segment belong to `C'`. </code>",
 "588":
 "<code>exampleC : Set (EuclideanSpace ‚Ñù (Fin 3))</code><span class=\"sep\"></span><code class=\"docstring\">The example set in `‚Ñù¬≥` used to exhibit a non-exposed extreme point. </code>",
 "587":
 "<code>mem_coneK_iff_exists_conicCombination {n : ‚Ñï} (Sstar : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)) (xStar : Fin n ‚Üí ‚Ñù) (muStar : ‚Ñù) :\n  (xStar, muStar) ‚àà coneK Sstar ‚Üî\n    ‚àÉ m p lam0 lam,\n      (‚àÄ (i : Fin m), p i ‚àà Sstar) ‚àß\n        0 ‚â§ lam0 ‚àß (‚àÄ (i : Fin m), 0 ‚â§ lam i) ‚àß (xStar, muStar) = lam0 ‚Ä¢ verticalVector n + ‚àë i, lam i ‚Ä¢ p i</code><span class=\"sep\"></span><code class=\"docstring\">Lemma 17.2.9 (Membership in `K` via conic combinations), LaTeX label `lem:K_conic`.\n\nLet `K` be the convex cone generated by `S* ‚à™ {(0, 1)}` (here: `K = coneK Sstar`). Then\n`(x*, Œº*) ‚àà K` if and only if there exist finitely many points `(x·µ¢*, Œº·µ¢*) ‚àà S*` and\ncoefficients `Œª‚ÇÄ, Œª‚ÇÅ, ‚Ä¶, Œª‚Çò ‚â• 0` such that\n\n`(x*, Œº*) = Œª‚ÇÄ (0, 1) + ‚àë i, Œª·µ¢ (x·µ¢*, Œº·µ¢*)`.\n\nIn that case, `x* = ‚àë i, Œª·µ¢ x·µ¢*` and `Œº* ‚â• ‚àë i, Œª·µ¢ Œº·µ¢*`. </code>",
 "586": "<code>Fin m ‚Üí (Fin a ‚Üí ‚Ñù) √ó ‚Ñù</code>",
 "585":
 "<code>adjoinVertical {n : ‚Ñï} (Sstar : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)) : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The set `D := S* ‚à™ {(0, 1)}` obtained by adjoining the vertical vector to `S*`. </code>",
 "584":
 "<code>coneK {n : ‚Ñï} (Sstar : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)) : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The convex cone `K` generated by `D = S* ‚à™ {(0, 1)}` (as a subset of `‚Ñù^{n+1}`). </code>",
 "583":
 "<code>infMuInCone {n : ‚Ñï} (Sstar : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)) (xStar : Fin n ‚Üí ‚Ñù) : WithTop ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The function `f(x*) = inf {Œº* | (x*, Œº*) ‚àà K}` with values in `‚Ñù ‚à™ {+‚àû}`. </code>",
 "582":
 "<code>supremumInnerSub {n : ‚Ñï} (S : Set (Fin n ‚Üí ‚Ñù)) (f : ‚ÜëS ‚Üí EReal) (z : Fin n ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Definition 17.2.2 (A convex function defined as a supremum), LaTeX label `def:h`.\n\nLet `S ‚äÜ ‚Ñù‚Åø` and let `f : S ‚Üí (‚Ñù ‚à™ {+‚àû})` (modeled here as `f : S ‚Üí EReal`). Define\n`h : ‚Ñù‚Åø ‚Üí (‚Ñù ‚à™ {+‚àû})` by\n\n`h z = sup { ‚ü™z, x‚ü´ - f x | x ‚àà S }`.\n\nIn `Fin n ‚Üí ‚Ñù`, the inner product `‚ü™z, x‚ü´` is expressed as `‚àë i, z i * x i`. </code>",
 "581": "<code>‚ÜëS ‚Üí EReal</code>",
 "580":
 "<code>convexHullFunction {n : ‚Ñï} (g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.5.1: For a function `g`, define `f x = inf { Œº | (x, Œº) ‚àà conv (epi g) }`.\nThen `f` is called the convex hull of `g`, and is denoted `f = conv(g)`. </code>",
 "58":
 "<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>",
 "579": "<code>Fin ?m.1 ‚Üí ‚Ñù</code>",
 "578":
 "<code>IsGeneralizedSimplex (n m : ‚Ñï) (S : Set (Fin n ‚Üí ‚Ñù)) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A generalized `m`-dimensional simplex in `‚Ñù‚Åø`, modeled via the identification\n`x ‚Ü¶ (1, x) ‚àà H = {(1, x) | x ‚àà ‚Ñù‚Åø}` as a slice of an `(m+1)`-dimensional skew orthant in\n`‚Ñù^{n+1}`. </code>",
 "577":
 "<code>conv {n : ‚Ñï} (S : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 17.0.2 (Convex hull). For `S ‚äÜ ‚Ñù‚Åø`, the convex hull of `S`, denoted `conv(S)`,\nis the set of all convex combinations of finitely many points of `S`; equivalently, it is the\nsmallest convex set containing `S`. </code>",
 "576":
 "<code>cone (n : ‚Ñï) (S‚ÇÅ : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The cone obtained as the convex hull of `ray S‚ÇÅ`. </code>",
 "575":
 "<code>ray (n : ‚Ñï) (S‚ÇÅ : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 17.0.5 (`ray S‚ÇÅ` and `cone S‚ÇÅ`, LaTeX label `def:ray-cone`). Let `ray S‚ÇÅ` be the\nset consisting of the origin and all vectors whose directions belong to `S‚ÇÅ`, i.e. all vectors\nof the form `t ‚Ä¢ d` with `d ‚àà S‚ÇÅ` and `t ‚â• 0`. Define `cone(S‚ÇÅ) := conv(ray S‚ÇÅ)`. Equivalently,\n`cone(S‚ÇÅ)` is the convex cone generated by all vectors whose directions belong to `S‚ÇÅ`. </code>",
 "574": "<code>?m.13 ‚Üí ‚Ñù</code>",
 "573": "<code>Œπ ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "572":
 "<code>convexHullFunctionFamily.{u_1} {n : ‚Ñï} {Œπ : Sort u_1} (f : Œπ ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.5.5: The convex hull of an arbitrary collection of functions `{f_i | i ‚àà I}` on\n`‚Ñù^n` is denoted `conv {f_i | i ‚àà I}`. It is the function obtained via Theorem 5.3 from\nthe convex hull of the union of the epigraphs of the `f_i`. </code>",
 "571":
 "<code>Metric.infDist.{u} {Œ± : Type u} [PseudoMetricSpace Œ±] (x : Œ±) (s : Set Œ±) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The minimal distance of a point to a set </code>",
 "570":
 "<code>infimalConvolutionFamily {n m : ‚Ñï} (f : Fin m ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.4.1: Let `f_1, ..., f_m` be proper convex functions on `R^n`, and let\n`f x = inf { f_1 x_1 + ... + f_m x_m | x_i ‚àà R^n, x_1 + ... + x_m = x }`. The\nfunction `f` is denoted by `f_1 square f_2 square ... square f_m`; the operation\n`square` is called infimal convolution. </code>",
 "57":
 "<code>closure.{u} {X : Type u} [TopologicalSpace X] (s : Set X) : Set X</code><span class=\"sep\"></span><code class=\"docstring\">The closure of `s` is the smallest closed set containing `s`. </code>",
 "569":
 "<code>section16_closure_image_adjoint_polar_eq_closure_sublevel_sInf {n m : ‚Ñï}\n  (Aadj : EuclideanSpace ‚Ñù (Fin m) ‚Üí‚Çó[‚Ñù] EuclideanSpace ‚Ñù (Fin n)) (D : Set (Fin m ‚Üí ‚Ñù)) :\n  closure ((fun yStar =&gt; (Aadj (WithLp.toLp 2 yStar)).ofLp) '' {yStar | supportFunctionEReal D yStar ‚â§ 1}) =\n    closure\n      {xStar |\n        sInf ((fun yStar =&gt; supportFunctionEReal D yStar.ofLp) '' {yStar | Aadj yStar = WithLp.toLp 2 xStar}) ‚â§ 1}</code><span class=\"sep\"></span><code class=\"docstring\">The closure of the adjoint image of the polar sublevel equals the closure of the `sInf` sublevel. </code>",
 "568": "<code>EuclideanSpace ‚Ñù (Fin m)</code>",
 "567": "<code>Fin m ‚Üí ‚Ñù</code>",
 "566": "<code>Set (Fin m ‚Üí ‚Ñù)</code>",
 "565": "<code>EuclideanSpace ‚Ñù (Fin m) ‚Üí‚Çó[‚Ñù] EuclideanSpace ‚Ñù (Fin n)</code>",
 "564":
 "<code>polarSetProd {n : ‚Ñï} (C : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)) : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Product-space polar set using the dot-product-plus-scalar pairing. </code>",
 "563": "<code>Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)</code>",
 "562":
 "<code>obverseConvex {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 15.0.32: Let `f : ‚Ñù‚Åø ‚Üí [0, +‚àû]` be a nonnegative closed convex function with `f(0) = 0`.\nFor `Œª &gt; 0`, define the scaled (perspective) function `f_Œª x := Œª * f (x / Œª)`. The obverse of\n`f` is the function `g : ‚Ñù‚Åø ‚Üí [0, +‚àû]` given by\n`g x := inf {Œª &gt; 0 | f_Œª x ‚â§ 1}`.\n\nIf `f = Œ¥(¬∑ | C)` for a closed convex set `C` containing `0`, then `g = Œ≥(¬∑ | C)` is the gauge of\n`C`. If `f = Œ≥(¬∑ | C)` is the gauge of such a set `C`, then `g = Œ¥(¬∑ | C)`. Thus the gauge and\nindicator functions of `C` are obverses of each other.\n\nIn this development, `‚Ñù‚Åø` is `Fin n ‚Üí ‚Ñù`, `[0, +‚àû]` is modeled by `EReal` with nonnegativity\nassumptions, `Œ¥(¬∑ | C)` is `erealIndicator C`, and `Œ≥(¬∑ | C)` is represented by\n`fun x =&gt; (gaugeFunction C x : EReal)`. </code>",
 "561":
 "<code>polarConvex {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) (xStar : Fin n ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 15.0.29: Let `f : ‚Ñù‚Åø ‚Üí [0, +‚àû]` be a convex function such that `f 0 = 0`. Its polar\n`f·µí : ‚Ñù‚Åø ‚Üí [0, +‚àû]` is defined by\n\n`f·µí x‚ãÜ = inf { Œº‚ãÜ ‚â• 0 | ‚ü™x, x‚ãÜ‚ü´ ‚â§ 1 + Œº‚ãÜ * f x for all x }`.\n\nIf `f` is a gauge, this reduces to the polar gauge (Text 15.0.5). If `f = Œ¥(¬∑ | C)` for a closed\nconvex set `C` containing `0`, then `f·µí = Œ¥(¬∑ | C·µí)`. Furthermore, whenever `x ‚àà dom f` and\n`x‚ãÜ ‚àà dom f·µí`, one has `‚ü™x, x‚ãÜ‚ü´ ‚â§ 1 + f x * f·µí x‚ãÜ`.\n\nIn this development, we represent `[0, +‚àû]` by `EReal` together with explicit nonnegativity\nassumptions, and effective-domain assumptions by `f x ‚â† ‚ä§`. </code>",
 "560":
 "<code>Ring.inverse.{u_2} {M‚ÇÄ : Type u_2} [MonoidWithZero M‚ÇÄ] : M‚ÇÄ ‚Üí M‚ÇÄ</code><span class=\"sep\"></span><code class=\"docstring\">Introduce a function `inverse` on a monoid with zero `M‚ÇÄ`, which sends `x` to `x‚Åª¬π` if `x` is\ninvertible and to `0` otherwise.  This definition is somewhat ad hoc, but one needs a fully (rather\nthan partially) defined inverse function for some purposes, including for calculus.\n\nNote that while this is in the `Ring` namespace for brevity, it requires the weaker assumption\n`MonoidWithZero M‚ÇÄ` instead of `Ring M‚ÇÄ`. </code>",
 "56":
 "<code class=\"docstring\">The `dsimp` tactic is the definitional simplifier. It is similar to `simp` but only\napplies theorems that hold by reflexivity. Thus, the result is guaranteed to be\ndefinitionally equal to the input.\n</code>",
 "559":
 "<code>Matrix.toLin'.{u_1, u_4, u_5} {R : Type u_1} [CommSemiring R] {m : Type u_4} {n : Type u_5} [DecidableEq n]\n  [Fintype n] : Matrix m n R ‚âÉ‚Çó[R] (n ‚Üí R) ‚Üí‚Çó[R] m ‚Üí R</code><span class=\"sep\"></span><code class=\"docstring\">A `Matrix m n R` is linearly equivalent to a linear map `(n ‚Üí R) ‚Üí‚Çó[R] (m ‚Üí R)`.\n\nNote that the forward-direction does not require `DecidableEq` and is `Matrix.mulVecLin`. </code>",
 "558": "<code>(Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin n ‚Üí ‚Ñù</code>",
 "557":
 "<code>lpNormEReal {n : ‚Ñï} (p : ‚Ñù) (x : Fin n ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">The ‚Ñì·µñ gauge as an `EReal`-valued function. </code>",
 "556":
 "<code>Real.rpow (x y : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The real power function `x ^ y`, defined as the real part of the complex power function.\nFor `x &gt; 0`, it is equal to `exp (y log x)`. For `x = 0`, one sets `0 ^ 0=1` and `0 ^ y=0` for\n`y ‚â† 0`. For `x &lt; 0`, the definition is somewhat arbitrary as it depends on the choice of a complex\ndetermination of the logarithm. With our conventions, it is equal to `exp (y log x) cos (œÄ y)`. </code>",
 "555":
 "<code>ProperConvexFunctionOn {n : ‚Ñï} (S : Set (Fin n ‚Üí ‚Ñù)) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.6: A convex function `f` is proper if its epigraph is nonempty and\ncontains no vertical lines (equivalently, `f x ‚â† ‚ä•` for all `x ‚àà S`). </code>",
 "554":
 "<code>ClosedConvexFunction {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Text 7.0.6: A convex function is called closed if it is lower semicontinuous on `‚Ñù^n`. </code>",
 "553": "<code>EReal ‚Üí EReal</code>",
 "552":
 "<code>phiPow (r : ‚Ñù) : EReal ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Power profile used in the `rpow` representation. </code>",
 "551":
 "<code>monotoneConjugateERealNonneg (g : EReal ‚Üí EReal) (s : EReal) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">The monotone conjugate `g‚Å∫` of a function `g : [0, +‚àû] ‚Üí (-‚àû, +‚àû]`, defined by\n`g‚Å∫(s) = sup_{t ‚â• 0} (t * s - g t)`. </code>",
 "550":
 "<code>euclideanDist (n : ‚Ñï) (x y : EuclideanSpace ‚Ñù (Fin n)) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Text 6.1: The Euclidean distance between two points `x` and `y` in `R^n` is defined by\n`d(x, y) = |x - y| = sqrt (inner (x - y) (x - y))`. </code>",
 "55":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat √ó Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n\nThe *anaphoric let* `let := v` defines a variable called `this`.\n</code>",
 "549": "<code>EuclideanSpace ‚Ñù (Fin n)</code>",
 "548": "<code>?m.37 x‚úù</code>",
 "547": "<code>?m.37 x</code>",
 "546":
 "<code>IsMetricFun {n : ‚Ñï} (œÅ : (Fin n ‚Üí ‚Ñù) ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Text 15.0.14: A metric on `‚Ñù‚Åø` is a function `œÅ : ‚Ñù‚Åø √ó ‚Ñù‚Åø ‚Üí ‚Ñù` such that:\n(1) `œÅ(x, y) &gt; 0` if `x ‚â† y`, and `œÅ(x, y) = 0` if `x = y`;\n(2) `œÅ(x, y) = œÅ(y, x)` for all `x, y`;\n(3) `œÅ(x, z) ‚â§ œÅ(x, y) + œÅ(y, z)` for all `x, y, z`.\n\nThe quantity `œÅ(x, y)` is interpreted as the distance between `x` and `y`.\n\nIn this development, we use `Fin n ‚Üí ‚Ñù` for `‚Ñù‚Åø`. The usual mathlib notion of a metric space is\n`MetricSpace`, and `IsMetricFun œÅ` records the book axioms for the distance function `œÅ`. </code>",
 "545":
 "<code>MetricSpace.{u} (Œ± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A metric space is a type endowed with a `‚Ñù`-valued distance `dist` satisfying\n`dist x y = 0 ‚Üî x = y`, commutativity `dist x y = dist y x`, and the triangle inequality\n`dist x z ‚â§ dist x y + dist y z`.\n\nSee pseudometric spaces (`PseudoMetricSpace`) for the similar class with the `dist x y = 0 ‚Üî x = y`\nassumption weakened to `dist x x = 0`.\n\nAny metric space is a T1 topological space and a uniform space (see `TopologicalSpace`, `T1Space`,\n`UniformSpace`), where the topology and uniformity come from the metric.\n\nWe make the uniformity/topology part of the data instead of deriving it from the metric.\nThis e.g. ensures that we do not get a diamond when doing\n`[MetricSpace Œ±] [MetricSpace Œ≤] : TopologicalSpace (Œ± √ó Œ≤)`:\nThe product metric and product topology agree, but not definitionally so.\nSee Note [forgetful inheritance]. </code>",
 "544":
 "<code>Real.sign (r : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The sign function that maps negative real numbers to -1, positive numbers to 1, and 0\notherwise. </code>",
 "543": "<code>(Fin ?m.5 ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "542":
 "<code>eH_transport_to_H2 (n : ‚Ñï) : WithLp 2 (EuclideanSpace ‚Ñù (Fin n) √ó ‚Ñù) ‚âÉL[‚Ñù] (Fin n ‚Üí ‚Ñù) √ó ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Continuous linear equivalence between the inner-product model `H‚ÇÇ` and `((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)`. </code>",
 "541":
 "<code>WithLp.{u_1} (p : ENNReal) (V : Type u_1) : Type u_1</code><span class=\"sep\"></span><code class=\"docstring\">A type synonym for the given `V`, associated with the L`p` norm. Note that by default this just\nforgets the norm structure on `V`; it is up to downstream users to implement the L`p` norm (for\ninstance, on `Prod` and finite `Pi` types). </code>",
 "540": "<code>?m.8 ‚Üí ‚Ñù</code>",
 "54":
 "<code class=\"docstring\">Applies extensionality lemmas that are registered with the `@[ext]` attribute.\n* `ext pat*` applies extensionality theorems as much as possible,\n  using the patterns `pat*` to introduce the variables in extensionality theorems using `rintro`.\n  For example, the patterns are used to name the variables introduced by lemmas such as `funext`.\n* Without patterns,`ext` applies extensionality lemmas as much\n  as possible but introduces anonymous hypotheses whenever needed.\n* `ext pat* : n` applies ext theorems only up to depth `n`.\n\nThe `ext1 pat*` tactic is like `ext pat*` except that it only applies a single extensionality theorem.\n\nUnused patterns will generate warning.\nPatterns that don't match the variables will typically result in the introduction of anonymous hypotheses.\n</code>",
 "539": "<code>‚ÜëJ ‚Üí EReal</code>",
 "538":
 "<code>innerMulGauge {n : ‚Ñï} {J : Set (Fin n ‚Üí ‚Ñù)} (j : ‚ÜëJ ‚Üí EReal) (x : Fin n ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Candidate gauge defined by infimum of feasible multipliers. </code>",
 "537":
 "<code class=\"docstring\">The `norm_cast` family of tactics is used to normalize certain coercions (*casts*) in expressions.\n- `norm_cast` normalizes casts in the target.\n- `norm_cast at h` normalizes casts in hypothesis `h`.\n\nThe tactic is basically a version of `simp` with a specific set of lemmas to move casts\nupwards in the expression.\nTherefore even in situations where non-terminal `simp` calls are discouraged (because of fragility),\n`norm_cast` is considered to be safe.\nIt also has special handling of numerals.\n\nFor instance, given an assumption\n```lean\na b : ‚Ñ§\nh : ‚Üëa + ‚Üëb &lt; (10 : ‚Ñö)\n```\nwriting `norm_cast at h` will turn `h` into\n```lean\nh : a + b &lt; 10\n```\n\nThere are also variants of basic tactics that use `norm_cast` to normalize expressions during\ntheir operation, to make them more flexible about the expressions they accept\n(we say that it is a tactic *modulo* the effects of `norm_cast`):\n- `exact_mod_cast` for `exact` and `apply_mod_cast` for `apply`.\n  Writing `exact_mod_cast h` and `apply_mod_cast h` will normalize casts\n  in the goal and `h` before using `exact h` or `apply h`.\n- `rw_mod_cast` for `rw`. It applies `norm_cast` between rewrites.\n- `assumption_mod_cast` for `assumption`.\n  This is effectively `norm_cast at *; assumption`, but more efficient.\n  It normalizes casts in the goal and, for every hypothesis `h` in the context,\n  it will try to normalize casts in `h` and use `exact h`.\n\nSee also `push_cast`, which moves casts inwards rather than lifting them outwards.\n</code>",
 "536":
 "<code>polarGaugeSqrtSumSq_add_fst (xStar : Fin 2 ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 15.0.8 (polar formula): explicit piecewise formula for the polar gauge of\n`gaugeSqrtSumSq_add_fst`. </code>",
 "535":
 "<code>gaugeSqrtSumSq_add_fst (x : Fin 2 ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 15.0.8: Define `k : ‚Ñù¬≤ ‚Üí [0, +‚àû)` by\n`k(Œæ‚ÇÅ, Œæ‚ÇÇ) = sqrt (Œæ‚ÇÅ^2 + Œæ‚ÇÇ^2) + Œæ‚ÇÅ`. Then `k` is a closed gauge function.\n\nIts polar gauge `k^‚àò` is given by the piecewise formula\n`k^‚àò(Œæ‚ÇÅ‚ãÜ, Œæ‚ÇÇ‚ãÜ) = (1/2) * ((Œæ‚ÇÇ‚ãÜ)^2 / Œæ‚ÇÅ‚ãÜ + Œæ‚ÇÅ‚ãÜ)` if `0 &lt; Œæ‚ÇÅ‚ãÜ`,\n`k^‚àò(0, 0) = 0`, and `k^‚àò(Œæ‚ÇÅ‚ãÜ, Œæ‚ÇÇ‚ãÜ) = +‚àû` otherwise.\n\nNeither `k` nor `k^‚àò` is a norm (e.g. neither is an even function). </code>",
 "534":
 "<code>EReal.toReal : EReal ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The map from extended reals to reals sending infinities to zero. </code>",
 "533":
 "<code>polarGauge {n : ‚Ñï} (k : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) (xStar : Fin n ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 15.0.5: Let `k` be a gauge on `‚Ñù‚Åø`. Its polar `k·µí : ‚Ñù‚Åø ‚Üí [0, +‚àû]` is defined by\n`k·µí x‚ãÜ = inf { Œº‚ãÜ ‚â• 0 | ‚ü™x, x‚ãÜ‚ü´ ‚â§ Œº‚ãÜ * k x for all x }`.\n\nIn this development, `‚Ñù‚Åø` is `Fin n ‚Üí ‚Ñù` and we represent the `inf` as `sInf` in `EReal`. </code>",
 "532":
 "<code>gaugeFunction {n : ‚Ñï} (C : Set (Fin n ‚Üí ‚Ñù)) : (Fin n ‚Üí ‚Ñù) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Defintion 4.8.2: The gauge `gamma(¬∑ | C)` is defined by\n`gamma(x | C) = inf {lambda &gt;= 0 | x ‚àà lambda C}`, for `C ‚â† ‚àÖ`. </code>",
 "531": "<code>Fin ?m.3 ‚Üí ‚Ñù</code>",
 "530": "<code>?m.13 √ó ?m.19</code>",
 "53":
 "<code>frontier.{u} {X : Type u} [TopologicalSpace X] (s : Set X) : Set X</code><span class=\"sep\"></span><code class=\"docstring\">The frontier of a set is the set of points between the closure and interior. </code>",
 "529":
 "<code>Set.recessionCone.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] (C : Set E) : Set E</code><span class=\"sep\"></span><code class=\"docstring\">Definition 8.0.2. Let `C` be a non-empty convex set. The recession cone of `C`\nis the set `0^+ C = { y | x + Œª ‚Ä¢ y ‚àà C` for all `x ‚àà C` and all `Œª ‚â• 0` }. </code>",
 "528":
 "<code>Submodule.span.{u_1, u_4} (R : Type u_1) {M : Type u_4} [Semiring R] [AddCommMonoid M] [Module R M] (s : Set M) :\n  Submodule R M</code><span class=\"sep\"></span><code class=\"docstring\">The span of a set `s ‚äÜ M` is the smallest submodule of M that contains `s`. </code>",
 "527":
 "<code>Module.finrank.{u_1, u_2} (R : Type u_1) (M : Type u_2) [Semiring R] [AddCommMonoid M] [Module R M] : ‚Ñï</code><span class=\"sep\"></span><code class=\"docstring\">The rank of a module as a natural number.\n\nFor a finite-dimensional vector space `V` over a field `k`, `Module.finrank k V` is equal to\nthe dimension of `V` over `k`.\n\nFor a general module `M` over a ring `R`, `Module.finrank R M` is defined to be the supremum of the\ncardinalities of the `R`-linearly independent subsets of `M`, if this supremum is finite. It is\ndefined by convention to be `0` if this supremum is infinite. See `Module.rank` for a\ncardinal-valued version where infinite rank modules have rank an infinite cardinal.\n\nNote that if `R` is not a field then there can exist modules `M` with `¬¨(Module.Finite R M)` but\n`finrank R M ‚â† 0`. For example `‚Ñö` has `finrank` equal to `1` over `‚Ñ§`, because the nonempty\n`‚Ñ§`-linearly independent subsets of `‚Ñö` are precisely the nonzero singletons. </code>",
 "526": "<code>?m.16 x‚úù</code>",
 "525": "<code>Module.Dual ‚Ñù (?m.18 x‚úù)</code>",
 "524": "<code>Module.Dual ‚Ñù (?m.18 x)</code>",
 "523":
 "<code>section14_swapNeg‚Çó.{u_2} (E : Type u_2) [AddCommGroup E] [Module ‚Ñù E] : ‚Ñù √ó E √ó ‚Ñù ‚Üí‚Çó[‚Ñù] ‚Ñù √ó E √ó ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Coordinate involution used in Theorem 14.4: `swapNeg (Œª, x, Œº) = (-Œº, x, -Œª)`. </code>",
 "522":
 "<code>PointedCone.dual.{u_1, u_2, u_3} {R : Type u_1} {M : Type u_2} {N : Type u_3} [CommRing R] [PartialOrder R]\n  [IsOrderedRing R] [AddCommGroup M] [AddCommGroup N] [Module R M] [Module R N] (p : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] R) (s : Set M) :\n  PointedCone R N</code><span class=\"sep\"></span><code class=\"docstring\">The dual cone of a set `s` with respect to a bilinear pairing `p` is the cone consisting of all\npoints `y` such that for all points `x ‚àà s` we have `0 ‚â§ p x y`. </code>",
 "521":
 "<code>section14_posHomHull.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] (f : E ‚Üí EReal) : E ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Positively homogeneous hull generated by `f`:\n`k(x) = inf_{t&gt;0} t * f(t‚Åª¬π ‚Ä¢ x)`.\n\nThis is the standard conic hull construction used in the proof of Theorem 14.3. </code>",
 "520": "<code>E ‚Üí EReal</code>",
 "52":
 "<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>",
 "519": "<code>E ‚Üí‚Çó[‚Ñù] F ‚Üí‚Çó[‚Ñù] ‚Ñù</code>",
 "518": "<code>Set M</code>",
 "517":
 "<code>section14_counterexample_P_not_subset_polar_C4 :\n  have C‚ÇÑ := {x | x.ofLp 0 ‚â§ 1 - ‚àö(1 + x.ofLp 1 ^ 2)};\n  have P := {œÜ | ‚àö(1 + œÜ (EuclideanSpace.single 1 1) ^ 2) ‚â§ œÜ (EuclideanSpace.single 0 1)};\n  ¬¨P ‚äÜ polar C‚ÇÑ</code><span class=\"sep\"></span><code class=\"docstring\">A concrete counterexample showing that, for the current definition of `C‚ÇÑ` and `P`,\nthe set `P` is not a subset of the polar `C‚ÇÑ^‚àò`. This indicates that `polar_C4_eq_convexHull`\ncannot be proven as stated. </code>",
 "516": "<code>‚Ñù √ó ?m.29</code>",
 "515":
 "<code>polar_C4_eq_convexHull :\n  have C‚ÇÑ := {x | x.ofLp 0 ‚â§ 1 - ‚àö(1 + x.ofLp 1 ^ 2)};\n  have P‚ÇÑ := {œÜ | œÜ (EuclideanSpace.single 1 1) ^ 2 + 1 ‚â§ 2 * œÜ (EuclideanSpace.single 0 1)};\n  polar C‚ÇÑ = (convexHull ‚Ñù) (P‚ÇÑ ‚à™ {0})</code><span class=\"sep\"></span><code class=\"docstring\">Text 14.0.15 (Example). Define\n`C‚ÇÑ = {x = (Œæ‚ÇÅ, Œæ‚ÇÇ) | Œæ‚ÇÅ ‚â§ 1 - (1 + Œæ‚ÇÇ^2)^{1/2}}`.\nThen its polar can be written as\n`C‚ÇÑ^‚àò = conv(P ‚à™ {0})`, where\n`P = {x‚òÖ = (Œæ‚ÇÅ‚òÖ, Œæ‚ÇÇ‚òÖ) | Œæ‚ÇÅ‚òÖ ‚â• (1 + (Œæ‚ÇÇ‚òÖ)^2)^{1/2}}`.\n\nNote: the set `P` above (a \"sqrt cone\") is not contained in the polar for the current definition\nof `polar` (via Fenchel conjugates), as shown by `section14_counterexample_P_not_subset_polar_C4`.\nThe correct description of `C‚ÇÑ^‚àò` in this formalization uses instead the parabola region\n`P‚ÇÑ = {x‚òÖ = (a,b) | b^2 + 1 ‚â§ 2a}`, which is the closed convex hull of all supporting halfspaces\nthrough the origin.\n\nIn this file, `C^‚àò` is modeled as `polar (E := EuclideanSpace ‚Ñù (Fin 2)) C :\nSet (Module.Dual ‚Ñù _)`, and we interpret the coordinates `Œæ‚ÇÅ‚òÖ, Œæ‚ÇÇ‚òÖ` of a functional `œÜ` as the\nvalues `œÜ (EuclideanSpace.single 0 1)` and `œÜ (EuclideanSpace.single 1 1)`. </code>",
 "514": "<code>Module.Dual ‚Ñù (EuclideanSpace ‚Ñù (Fin 2))</code>",
 "513": "<code>Set (Module.Dual ‚Ñù (EuclideanSpace ‚Ñù (Fin 2)))</code>",
 "512": "<code>EuclideanSpace ‚Ñù (Fin 2)</code>",
 "511": "<code>Set (EuclideanSpace ‚Ñù (Fin 2))</code>",
 "510":
 "<code>erealDom.{u_2} {F : Type u_2} (f : F ‚Üí EReal) : Set F</code><span class=\"sep\"></span><code class=\"docstring\">The effective domain `dom f` of an `EReal`-valued function, as the set where `f` is finite\n(i.e. strictly below `‚ä§`). </code>",
 "51":
 "<code>interior.{u} {X : Type u} [TopologicalSpace X] (s : Set X) : Set X</code><span class=\"sep\"></span><code class=\"docstring\">The interior of a set `s` is the largest open subset of `s`. </code>",
 "509":
 "<code>recessionConeEReal.{u_2} {F : Type u_2} [AddCommGroup F] (f : F ‚Üí EReal) : Set F</code><span class=\"sep\"></span><code class=\"docstring\">The recession cone `{y | f‚ÇÄ‚Å∫(y) ‚â§ 0}` associated to `recessionFunctionEReal`. </code>",
 "508":
 "<code>recessionFunctionEReal.{u_2} {F : Type u_2} [AddCommGroup F] (f : F ‚Üí EReal) : F ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">The recession function `f‚ÇÄ‚Å∫(y) = sup { f(x+y) - f(x) | x ‚àà dom f }` for an `EReal`-valued\nfunction. </code>",
 "507": "<code>F ‚Üí EReal</code>",
 "506":
 "<code>inner‚Çó.{u_3} (F : Type u_3) [SeminormedAddCommGroup F] [InnerProductSpace ‚Ñù F] : F ‚Üí‚Çó[‚Ñù] F ‚Üí‚Çó[‚Ñù] ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The inner product as a bilinear map in the real case. </code>",
 "505":
 "<code>normalConeAtOriginDual.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] (C : Set (Module.Dual ‚Ñù E)) : Set E</code><span class=\"sep\"></span><code class=\"docstring\">The normal cone to a set `C` in the dual space at the origin, modeled in the primal space:\n`N(0 | C)`. </code>",
 "504": "<code>Set (Module.Dual ‚Ñù E)</code>",
 "503":
 "<code>normalConeAtOrigin.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] (C : Set E) : Set (Module.Dual ‚Ñù E)</code><span class=\"sep\"></span><code class=\"docstring\">The normal cone to a set `C` at the origin, modeled in the dual space: `N(0 | C)`. </code>",
 "502":
 "<code>mem_polar_iff.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] {C : Set E} {œÜ : Module.Dual ‚Ñù E} :\n  œÜ ‚àà polar C ‚Üî ‚àÄ x ‚àà C, œÜ x ‚â§ 1</code><span class=\"sep\"></span><code class=\"docstring\">Text 14.0.5 (membership form): `x‚òÖ ‚àà C^‚àò` iff `‚ü™x, x‚òÖ‚ü´ ‚â§ 1` for all `x ‚àà C`. </code>",
 "501": "<code>Module.Dual ‚Ñù E</code>",
 "500":
 "<code>polar.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] (C : Set E) : Set (Module.Dual ‚Ñù E)</code><span class=\"sep\"></span><code class=\"docstring\">Text 14.0.5: The polar of a non-empty convex set `C` is\n`C^‚àò = {x‚òÖ | Œ¥*(x‚òÖ | C) - 1 ‚â§ 0} = {x‚òÖ | ‚àÄ x ‚àà C, ‚ü™x, x‚òÖ‚ü´ ‚â§ 1}`.\n\nHere we model `Œ¥*(x‚òÖ | C)` as the Fenchel‚ÄìLegendre conjugate of the `EReal`-indicator of `C`\nwith respect to the evaluation pairing. </code>",
 "50": "<code>Set X</code>",
 "5":
 "<code class=\"docstring\">`refine e` behaves like `exact e`, except that named (`?x`) or unnamed (`?_`)\nholes in `e` that are not solved by unification with the main goal's target type\nare converted into new goals, using the hole's name, if any, as the goal case name.\n</code>",
 "499":
 "<code>erealIndicator.{u_1} {E : Type u_1} (K : Set E) : E ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">An `EReal`-valued indicator function: `0` on a set and `‚ä§` off it. </code>",
 "498":
 "<code>fenchelConjugateBilin.{u_1, u_2} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] {F : Type u_2} [AddCommGroup F]\n  [Module ‚Ñù F] (p : E ‚Üí‚Çó[‚Ñù] F ‚Üí‚Çó[‚Ñù] ‚Ñù) (f : E ‚Üí EReal) : F ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">The (Fenchel‚ÄìLegendre) conjugate of an `EReal`-valued function with respect to a bilinear\npairing `p`, defined as `sup_x (p x y - f x)`. </code>",
 "497":
 "<code>polarCone.{u_1} {E : Type u_1} [AddCommGroup E] [Module ‚Ñù E] (K : Set E) : Set (Module.Dual ‚Ñù E)</code><span class=\"sep\"></span><code class=\"docstring\">Text 14.0.1: The polar of a non-empty convex cone `K` is the set\n`K·µí = {x‚òÖ | ‚àÄ x ‚àà K, ‚ü™x, x‚òÖ‚ü´ ‚â§ 0}`.\n\nIn this formalization, we interpret `x‚òÖ` as a linear functional `Module.Dual ‚Ñù E`\nand the pairing `‚ü™x, x‚òÖ‚ü´` as evaluation `x‚òÖ x`. </code>",
 "496":
 "<code>ProperCone.dual.{u_1, u_2, u_3} {R : Type u_1} {M : Type u_2} {N : Type u_3} [CommRing R] [PartialOrder R]\n  [IsOrderedRing R] [TopologicalSpace R] [ClosedIciTopology R] [AddCommGroup M] [Module R M] [TopologicalSpace M]\n  [AddCommGroup N] [Module R N] [TopologicalSpace N] (p : M ‚Üí‚Çó[R] N ‚Üí‚Çó[R] R) [p.IsContPerfPair] (s : Set M) :\n  ProperCone R N</code><span class=\"sep\"></span><code class=\"docstring\">The dual cone of a set `s` with respect to a perfect pairing `p` is the cone consisting of all\npoints `y` such that for all points `x ‚àà s` we have `0 ‚â§ p x y`. </code>",
 "495":
 "<code>Module.Dual.{u_4, u_5} (R : Type u_4) (M : Type u_5) [Semiring R] [AddCommMonoid M] [Module R M] : Type (max u_5 u_4)</code><span class=\"sep\"></span><code class=\"docstring\">The left dual space of an R-module M is the R-module of linear maps `M ‚Üí R`. </code>",
 "494":
 "<code>section13_supportSet {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Set (Fin (n + 1) ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The set `C = { (Œª^*, x^*) | Œª^* ‚â§ -f^*(x^*) } ‚äÜ ‚Ñù^{n+1}` from Corollary 13.5.1. </code>",
 "493":
 "<code>positivelyHomogeneousConvexFunctionGenerated {n : ‚Ñï} (h : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.4.7 (Positively homogeneous convex function generated by `h`): Let\n`h : ‚Ñù^n ‚Üí ‚Ñù ‚à™ {+‚àû}` be convex and let `F = cone (epi h) ‚äÜ ‚Ñù^{n+1}`. Define\n`f x = inf { Œº | (x, Œº) ‚àà F }` (as in Theorem 5.3). The function `f` is called the\npositively homogeneous convex function generated by `h`. </code>",
 "492":
 "<code>linearitySpace {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary definition: the linearity space of a function `f`, defined as the set of directions\n`y` for which the recession function is finite and symmetric:\n`-(f‚ÇÄ‚Å∫)(-y) = (f‚ÇÄ‚Å∫)(y)` whenever `(f‚ÇÄ‚Å∫)(y) &lt; +‚àû`. </code>",
 "491":
 "<code>AffineSubspace.{u_1, u_2, u_3} (k : Type u_1) {V : Type u_2} (P : Type u_3) [Ring k] [AddCommGroup V] [Module k V]\n  [AddTorsor V P] : Type u_3</code><span class=\"sep\"></span><code class=\"docstring\">An `AffineSubspace k P` is a subset of an `AffineSpace V P` that, if not empty, has an affine\nspace structure induced by a corresponding subspace of the `Module k V`. </code>",
 "490":
 "<code>orthogonalComplement (n : ‚Ñï) (L : Submodule ‚Ñù (Fin n ‚Üí ‚Ñù)) : Submodule ‚Ñù (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Text 1.6: Given a subspace `L` of `Real^n`, the orthogonal complement `L^‚ä•` is the set\nof vectors `x` such that `x ‚üÇ y` for every `y ‚àà L`. </code>",
 "49": "<code>Type u</code>",
 "489": "<code>Submodule ‚Ñù (Fin n ‚Üí ‚Ñù)</code>",
 "488": "<code>‚Ñù ^ sorry</code>",
 "487":
 "<code>conjugateDomainRadius {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary definition: the quantity `sup { ‚ÄñxStar‚Äñ‚ÇÅ | xStar ‚àà dom f^* }`, where `dom f^*` is the\neffective domain of the Fenchel conjugate `f^*`. </code>",
 "486":
 "<code>l1Norm {n : ‚Ñï} (x : Fin n ‚Üí ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary definition: the `‚Ñì¬π`-norm on `‚Ñù^n` (with `‚Ñù^n` represented as `Fin n ‚Üí ‚Ñù`). </code>",
 "485":
 "<code>LipschitzCondition {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) (Œ± : ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary definition: the global Lipschitz condition\n`|f(z) - f(x)| ‚â§ Œ± * ‚Äñz - x‚Äñ`, expressed via `toReal` for an `EReal`-valued function. </code>",
 "484":
 "<code>recessionFunction {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary definition: the recession function `f‚ÇÄ‚Å∫` of an `EReal`-valued function `f` on `‚Ñù^n`,\ngiven by `f‚ÇÄ‚Å∫(y) = sup { f(x+y) - f(x) | x ‚àà dom f }`. </code>",
 "483":
 "<code>supportFunctionEReal {n : ‚Ñï} (C : Set (Fin n ‚Üí ‚Ñù)) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary definition: the `EReal`-valued support function\n`xStar ‚Ü¶ sup_{x ‚àà C} ‚ü™x, xStar‚ü´`. </code>",
 "482": "<code>Prop</code>",
 "481": "<code>?m.2 sorry</code>",
 "480":
 "<code>Real.sqrt (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The square root of a real number. This returns 0 for negative inputs.\n\nThis has notation `‚àöx`. Note that `‚àöx‚Åª¬π` is parsed as `‚àö(x‚Åª¬π)`. </code>",
 "48":
 "<code class=\"docstring\">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ‚â† 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ‚â† 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ‚â† 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ‚ãØ\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n</code>",
 "479":
 "<code>deltaStar {n : ‚Ñï} (C : Set (Fin n ‚Üí ‚Ñù)) : (Fin n ‚Üí ‚Ñù) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Text 13.0.1: Let `C` be a convex set. The support function `Œ¥^*(¬∑ | C)` of `C` is defined by\n\n`Œ¥^*(x^* | C) = sup { ‚ü™x, x^*‚ü´ | x ‚àà C }`. </code>",
 "478":
 "<code>supportFunction {n : ‚Ñï} (C : Set (Fin n ‚Üí ‚Ñù)) : (Fin n ‚Üí ‚Ñù) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Defintion 4.8.2: The support function `delta*(¬∑ | C)` of a convex set `C` in `R^n`\nis defined by `delta*(x | C) = sup {dotProduct x y | y ‚àà C}`. </code>",
 "477":
 "<code>monotoneConjugateEReal (n : ‚Ñï) (g : (Fin n ‚Üí NNReal) ‚Üí ‚Ñù) : (Fin n ‚Üí NNReal) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">`EReal`-valued monotone conjugate: same supremum, but living in `[-‚àû, ‚àû]` so it can take `‚ä§`. </code>",
 "476":
 "<code>nonnegRay : Set (Fin 1 ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The nonnegative ray in `Fin 1 ‚Üí ‚Ñù` used to model `[0, +‚àû)`. </code>",
 "475":
 "<code>quadraticHalfLinear (n : ‚Ñï) (Q : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin n ‚Üí ‚Ñù) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">The quadratic extended-real function associated to a linear map `Q` on `‚Ñù^n`,\n`x ‚Ü¶ (1/2) * ‚ü™x, Q x‚ü´`. Here the inner product is written as the dot product `‚¨ù·µ•` on\ncoordinates `x : Fin n ‚Üí ‚Ñù`. </code>",
 "474":
 "<code>Submodule.comap.{u_1, u_3, u_5, u_7, u_9} {R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_5} {M‚ÇÇ : Type u_7} [Semiring R]\n  [Semiring R‚ÇÇ] [AddCommMonoid M] [AddCommMonoid M‚ÇÇ] [Module R M] [Module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ} {F : Type u_9}\n  [FunLike F M M‚ÇÇ] [SemilinearMapClass F œÉ‚ÇÅ‚ÇÇ M M‚ÇÇ] (f : F) (p : Submodule R‚ÇÇ M‚ÇÇ) : Submodule R M</code><span class=\"sep\"></span><code class=\"docstring\">The pullback of a submodule `p ‚äÜ M‚ÇÇ` along `f : M ‚Üí M‚ÇÇ` </code>",
 "473": "<code>Submodule R‚ÇÇ M‚ÇÇ</code>",
 "472": "<code>F</code>",
 "471": "<code>R ‚Üí+* R‚ÇÇ</code>",
 "470":
 "<code>quadraticHalfInner (n : ‚Ñï) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">The quadratic function `w(x) = (1/2) * ‚ü™x, x‚ü´` on `‚Ñù^n`, written on coordinates\n`x : Fin n ‚Üí ‚Ñù` and valued in `EReal`. </code>",
 "47":
 "<code class=\"docstring\">`end` closes a `section` or `namespace` scope. If the scope is named `&lt;id&gt;`, it has to be closed\nwith `end &lt;id&gt;`. The `end` command is optional at the end of a file.\n</code>",
 "469":
 "<code>mul_add_sqrt_sq_sub_sq_le {a x s : ‚Ñù} (ha : 0 ‚â§ a) (hx : |x| ‚â§ a) : x * s + ‚àö(a ^ 2 - x ^ 2) ‚â§ a * ‚àö(1 + s ^ 2)</code><span class=\"sep\"></span><code class=\"docstring\">A Cauchy‚ÄìSchwarz-type bound for the range terms\n`x*s + ‚àö(a^2-x^2)` under the constraint `|x| ‚â§ a` and `a ‚â• 0`. </code>",
 "468": "<code>|x| ‚â§ a</code>",
 "467": "<code>0 ‚â§ a</code>",
 "466":
 "<code>fenchelConjugate (n : ‚Ñï) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Defn 12.2: The conjugate `f*` of a function `f` on `‚Ñù^n` is the function on `‚Ñù^n` defined by\n`f*(x*) = sup_x (‚ü™x, x*‚ü´ - f x) = - inf_x (f x - ‚ü™x, x*‚ü´)`. </code>",
 "465":
 "<code>BddAbove.{u_1} {Œ± : Type u_1} [LE Œ±] (s : Set Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set is bounded above if there exists an upper bound. </code>",
 "464": "<code>?m.10 ‚Üí ?m.15</code>",
 "463":
 "<code>clConv (n : ‚Ñï) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">`clConv n f` is a Lean stand-in for the book's `cl (conv f)` for an extended-real-valued\nfunction `f : ‚Ñù^n ‚Üí [-‚àû, ‚àû]`. It is defined pointwise as the supremum of all affine functions\nmajorized by `f`. </code>",
 "462": "<code>?m.11 √ó ?m.17</code>",
 "461":
 "<code>ConvexCone.hull.{u_2, u_4} (R : Type u_2) {M : Type u_4} [Semiring R] [PartialOrder R] [AddCommMonoid M] [SMul R M]\n  (s : Set M) : ConvexCone R M</code><span class=\"sep\"></span><code class=\"docstring\">The cone hull of a set. The smallest convex cone containing that set. </code>",
 "460":
 "<code>ConvexCone.{u_2, u_4} (R : Type u_2) (M : Type u_4) [Semiring R] [PartialOrder R] [AddCommMonoid M] [SMul R M] :\n  Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">A convex cone is a subset `s` of an `R`-module such that `a ‚Ä¢ x + b ‚Ä¢ y ‚àà s` whenever `a, b &gt; 0`\nand `x, y ‚àà s`. </code>",
 "46":
 "<code class=\"docstring\">Normalize casts in the goal and the given expression, then close the goal with `exact`.\n</code>",
 "459": "<code>?m.8 ‚Üí ‚Ñï</code>",
 "458": "<code>?m.10 ‚Üí ?m.9</code>",
 "457":
 "<code>intrinsicFrontier.{u_1, u_2, u_5} (ùïú : Type u_1) {V : Type u_2} {P : Type u_5} [Ring ùïú] [AddCommGroup V] [Module ùïú V]\n  [TopologicalSpace P] [AddTorsor V P] (s : Set P) : Set P</code><span class=\"sep\"></span><code class=\"docstring\">The intrinsic frontier of a set is its frontier considered as a set in its affine span. </code>",
 "456": "<code>?m.16 x</code>",
 "455":
 "<code>StrongDual.{u_1, u_2} (R : Type u_1) [Semiring R] [TopologicalSpace R] (M : Type u_2) [TopologicalSpace M]\n  [AddCommMonoid M] [Module R M] : Type (max u_1 u_2)</code><span class=\"sep\"></span><code class=\"docstring\">The *strong dual* of a topological vector space `M` over a ring `R`. This is the space of\ncontinuous linear functionals and is equipped with the topology of uniform convergence\non bounded subsets. `StrongDual R M` is an abbreviation for `M ‚ÜíL[R] R`. </code>",
 "454": "<code>?m.9 ‚Üí ?m.13</code>",
 "453":
 "<code>Metric.closedBall.{u} {Œ± : Type u} [PseudoMetricSpace Œ±] (x : Œ±) (Œµ : ‚Ñù) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`closedBall x Œµ` is the set of all points `y` with `dist y x ‚â§ Œµ` </code>",
 "452":
 "<code>intrinsicInterior.{u_1, u_2, u_5} (ùïú : Type u_1) {V : Type u_2} {P : Type u_5} [Ring ùïú] [AddCommGroup V] [Module ùïú V]\n  [TopologicalSpace P] [AddTorsor V P] (s : Set P) : Set P</code><span class=\"sep\"></span><code class=\"docstring\">The intrinsic interior of a set is its interior considered as a set in its affine span. </code>",
 "451": "<code>Set P</code>",
 "450":
 "<code>euclideanRelativeInterior (n : ‚Ñï) (C : Set (EuclideanSpace ‚Ñù (Fin n))) : Set (EuclideanSpace ‚Ñù (Fin n))</code><span class=\"sep\"></span><code class=\"docstring\">Text 6.8: The relative interior `ri C` of a convex set `C` in `R^n` is the interior of `C`\nin its affine hull `aff C`. Equivalently,\n`ri C = { x ‚àà aff C | ‚àÉ Œµ &gt; 0, (x + Œµ B) ‚à© aff C ‚äÜ C }`. </code>",
 "45":
 "<code>swapEndpointsOnUnitInterval : { x // x ‚àà Set.Icc 0 1 } ‚Üí { x // x ‚àà Set.Icc 0 1 }</code><span class=\"sep\"></span><code class=\"docstring\">Proposition 1.9 (prop:1.9): the map on the closed unit interval that sends\n`0` to `1`, `1` to `0`, and fixes every `x ‚àà (0,1)`. </code>",
 "449": "<code>Set (EuclideanSpace ‚Ñù (Fin n))</code>",
 "448":
 "<code>Submodule.map.{u_1, u_3, u_5, u_7, u_9} {R : Type u_1} {R‚ÇÇ : Type u_3} {M : Type u_5} {M‚ÇÇ : Type u_7} [Semiring R]\n  [Semiring R‚ÇÇ] [AddCommMonoid M] [AddCommMonoid M‚ÇÇ] [Module R M] [Module R‚ÇÇ M‚ÇÇ] {œÉ‚ÇÅ‚ÇÇ : R ‚Üí+* R‚ÇÇ}\n  [RingHomSurjective œÉ‚ÇÅ‚ÇÇ] {F : Type u_9} [FunLike F M M‚ÇÇ] [SemilinearMapClass F œÉ‚ÇÅ‚ÇÇ M M‚ÇÇ] (f : F) (p : Submodule R M) :\n  Submodule R‚ÇÇ M‚ÇÇ</code><span class=\"sep\"></span><code class=\"docstring\">The pushforward of a submodule `p ‚äÜ M` by `f : M ‚Üí M‚ÇÇ` </code>",
 "447":
 "<code>AffineSubspace.direction.{u_1, u_2, u_3} {k : Type u_1} {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V]\n  [Module k V] [AddTorsor V P] (s : AffineSubspace k P) : Submodule k V</code><span class=\"sep\"></span><code class=\"docstring\">The direction of an affine subspace is the submodule spanned by\nthe pairwise differences of points.  (Except in the case of an empty\naffine subspace, where the direction is the zero submodule, every\nvector in the direction is the difference of two points in the affine\nsubspace.) </code>",
 "446": "<code>?m.8 ‚Üí ?m.13</code>",
 "445": "<code>?m.9 ‚Üí ?m.14</code>",
 "444":
 "<code>C11_1_2_C2 : Set (Fin 2 ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The set `C‚ÇÇ` from Text 11.1.2 (a closed convex ray on the `x`-axis). </code>",
 "443":
 "<code>C11_1_2_C1 : Set (Fin 2 ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The set `C‚ÇÅ` from Text 11.1.2 (a closed convex \"hyperbola region\"). </code>",
 "442":
 "<code>HyperplaneSeparatesProperly (n : ‚Ñï) (H C‚ÇÅ C‚ÇÇ : Set (Fin n ‚Üí ‚Ñù)) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Text 11.0.2: A hyperplane `H` is said to separate `C‚ÇÅ` and `C‚ÇÇ` properly if `C‚ÇÅ` and `C‚ÇÇ`\nare not both actually contained in `H` itself. </code>",
 "441": "<code>?m.14 x‚úù</code>",
 "440": "<code>?m.14 x</code>",
 "44":
 "<code class=\"docstring\">\"Dependent\" if-then-else, normally written via the notation `if h : c then t(h) else e(h)`,\nis sugar for `dite c (fun h =&gt; t(h)) (fun h =&gt; e(h))`, and it is the same as\n`if c then t else e` except that `t` is allowed to depend on a proof `h : c`,\nand `e` can depend on `h : ¬¨c`. (Both branches use the same name for the hypothesis,\neven though it has different types in the two cases.)\n\nWe use this to be able to communicate the if-then-else condition to the branches.\nFor example, `Array.get arr i h` expects a proof `h : i &lt; arr.size` in order to\navoid a bounds check, so you can write `if h : i &lt; arr.size then arr.get i h else ...`\nto avoid the bounds check inside the if branch. (Of course in this case we have only\nlifted the check into an explicit `if`, but we could also use this proof multiple times\nor derive `i &lt; arr.size` from some other proposition that we are checking in the `if`.)\n</code>",
 "439":
 "<code class=\"docstring\">Filters are automatically bounded or cobounded in complete lattices. To use the same statements\nin complete and conditionally complete lattices but let automation fill automatically the\nboundedness proofs in complete lattices, we use the tactic `isBoundedDefault` in the statements,\nin the form `(hf : f.IsBounded (‚â•) := by isBoundedDefault)`. </code>",
 "438":
 "<code>Function.recessionFunction {n : ‚Ñï} (f : EuclideanSpace ‚Ñù (Fin n) ‚Üí ‚Ñù) : EuclideanSpace ‚Ñù (Fin n) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">The recession function `f‚ÇÄ‚Å∫` of a real-valued function `f` on `‚Ñù^n`, defined by\n`f‚ÇÄ‚Å∫(y) = sup_x (f(x + y) - f(x))` (as an extended real). </code>",
 "437": "<code>EuclideanSpace ‚Ñù (Fin n) ‚Üí ‚Ñù</code>",
 "436":
 "<code>WithLp.toLp.{u_1} (p : ENNReal) {V : Type u_1} (ofLp : V) : WithLp p V</code><span class=\"sep\"></span><code class=\"docstring\">Converts an element of `V` to an element of `WithLp p V`. </code>",
 "435": "<code>V</code>",
 "434":
 "<code>Pi.single.{u_1, u_6} {Œπ : Type u_1} {M : Œπ ‚Üí Type u_6} [(i : Œπ) ‚Üí Zero (M i)] [DecidableEq Œπ] (i : Œπ) (x : M i)\n  (j : Œπ) : M j</code><span class=\"sep\"></span><code class=\"docstring\">The function supported at `i`, with value `x` there, and `0` elsewhere. </code>",
 "433": "<code>Type u_8</code>",
 "432": "<code>Type u_7</code>",
 "431":
 "<code class=\"docstring\">Lift an expression to another type.\n* Usage: `'lift' expr 'to' expr ('using' expr)? ('with' id (id id?)?)?`.\n* If `n : ‚Ñ§` and `hn : n ‚â• 0` then the tactic `lift n to ‚Ñï using hn` creates a new\n  constant of type `‚Ñï`, also named `n` and replaces all occurrences of the old variable `(n : ‚Ñ§)`\n  with `‚Üën` (where `n` in the new variable). It will clear `n` from the context and\n  try to clear `hn` from the context.\n  + So for example the tactic `lift n to ‚Ñï using hn` transforms the goal\n    `n : ‚Ñ§, hn : n ‚â• 0, h : P n ‚ä¢ n = 3` to `n : ‚Ñï, h : P ‚Üën ‚ä¢ ‚Üën = 3`\n    (here `P` is some term of type `‚Ñ§ ‚Üí Prop`).\n* The argument `using hn` is optional, the tactic `lift n to ‚Ñï` does the same, but also creates a\n  new subgoal that `n ‚â• 0` (where `n` is the old variable).\n  This subgoal will be placed at the top of the goal list.\n  + So for example the tactic `lift n to ‚Ñï` transforms the goal\n    `n : ‚Ñ§, h : P n ‚ä¢ n = 3` to two goals\n    `n : ‚Ñ§, h : P n ‚ä¢ n ‚â• 0` and `n : ‚Ñï, h : P ‚Üën ‚ä¢ ‚Üën = 3`.\n* You can also use `lift n to ‚Ñï using e` where `e` is any expression of type `n ‚â• 0`.\n* Use `lift n to ‚Ñï with k` to specify the name of the new variable.\n* Use `lift n to ‚Ñï with k hk` to also specify the name of the equality `‚Üëk = n`. In this case, `n`\n  will remain in the context. You can use `rfl` for the name of `hk` to substitute `n` away\n  (i.e. the default behavior).\n* You can also use `lift e to ‚Ñï with k hk` where `e` is any expression of type `‚Ñ§`.\n  In this case, the `hk` will always stay in the context, but it will be used to rewrite `e` in\n  all hypotheses and the target.\n  + So for example the tactic `lift n + 3 to ‚Ñï using hn with k hk` transforms the goal\n    `n : ‚Ñ§, hn : n + 3 ‚â• 0, h : P (n + 3) ‚ä¢ n + 3 = 2 * n` to the goal\n    `n : ‚Ñ§, k : ‚Ñï, hk : ‚Üëk = n + 3, h : P ‚Üëk ‚ä¢ ‚Üëk = 2 * n`.\n* The tactic `lift n to ‚Ñï using h` will remove `h` from the context. If you want to keep it,\n  specify it again as the third argument to `with`, like this: `lift n to ‚Ñï using h with n rfl h`.\n* More generally, this can lift an expression from `Œ±` to `Œ≤` assuming that there is an instance\n  of `CanLift Œ± Œ≤`. In this case the proof obligation is specified by `CanLift.prf`.\n* Given an instance `CanLift Œ≤ Œ≥`, it can also lift `Œ± ‚Üí Œ≤` to `Œ± ‚Üí Œ≥`; more generally, given\n  `Œ≤ : Œ† a : Œ±, Type*`, `Œ≥ : Œ† a : Œ±, Type*`, and `[Œ† a : Œ±, CanLift (Œ≤ a) (Œ≥ a)]`, it\n  automatically generates an instance `CanLift (Œ† a, Œ≤ a) (Œ† a, Œ≥ a)`.\n\n`lift` is in some sense dual to the `zify` tactic. `lift (z : ‚Ñ§) to ‚Ñï` will change the type of an\ninteger `z` (in the supertype) to `‚Ñï` (the subtype), given a proof that `z ‚â• 0`;\npropositions concerning `z` will still be over `‚Ñ§`. `zify` changes propositions about `‚Ñï` (the\nsubtype) to propositions about `‚Ñ§` (the supertype), without changing the type of any variable.\n</code>",
 "430":
 "<code class=\"docstring\">Given a main goal `ctx ‚ä¢ t`, `suffices h : t' from e` replaces the main goal with `ctx ‚ä¢ t'`,\n`e` must have type `t` in the context `ctx, h : t'`.\n\nThe variant `suffices h : t' by tac` is a shorthand for `suffices h : t' from by tac`.\nIf `h :` is omitted, the name `this` is used.\n </code>",
 "43":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "429":
 "<code>AffineBasis.{u‚ÇÅ, u‚ÇÇ, u‚ÇÉ, u‚ÇÑ} (Œπ : Type u‚ÇÅ) (k : Type u‚ÇÇ) {V : Type u‚ÇÉ} (P : Type u‚ÇÑ) [AddCommGroup V] [AddTorsor V P]\n  [Ring k] [Module k V] : Type (max u‚ÇÅ u‚ÇÑ)</code><span class=\"sep\"></span><code class=\"docstring\">An affine basis is a family of affine-independent points whose span is the top subspace. </code>",
 "428": "<code>Type u‚ÇÑ</code>",
 "427": "<code>Type u‚ÇÉ</code>",
 "426": "<code>Type u‚ÇÇ</code>",
 "425": "<code>Type u‚ÇÅ</code>",
 "424": "<code>Fin sorry</code>",
 "423": "<code>?m.10</code>",
 "422":
 "<code>quadraticOverLinearEReal (Œæ : Fin 2 ‚Üí ‚Ñù) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Theorem 10.1.4. Define `f : ‚Ñù^2 ‚Üí (-‚àû, +‚àû]` by\n\n- `f(Œæ‚ÇÅ, Œæ‚ÇÇ) = Œæ‚ÇÇ^2 / (2 Œæ‚ÇÅ)` if `Œæ‚ÇÅ &gt; 0`,\n- `f(0, 0) = 0`,\n- `f(Œæ‚ÇÅ, Œæ‚ÇÇ) = +‚àû` otherwise.\n\nThen `f` is convex with effective domain `{(Œæ‚ÇÅ, Œæ‚ÇÇ) | Œæ‚ÇÅ &gt; 0} ‚à™ {(0,0)}`.\nMoreover, `f` is the support function of the convex set\n`C = {(Œ∑‚ÇÅ, Œ∑‚ÇÇ) | Œ∑‚ÇÅ + Œ∑‚ÇÇ^2 / 2 ‚â§ 0}` (i.e. the supremum of `‚ü™Œæ, Œ∑‚ü´` over `Œ∑ ‚àà C`).\n\nThe function is continuous at every point of its effective domain except at `(0,0)`, where it is\nonly lower semicontinuous. In particular, for any `Œ± &gt; 0`,\n`lim_{t ‚Üí 0} f(t^2/(2Œ±), t) = Œ±`, while `lim_{t ‚Üì 0} f(t ‚Ä¢ x) = 0` for every `x` with `x‚ÇÅ &gt; 0`. </code>",
 "421": "<code>Fin 2 ‚Üí ‚Ñù</code>",
 "420":
 "<code>quadraticOverLinearSupportSet : Set (Fin 2 ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The convex set `C = {(Œ∑‚ÇÅ, Œ∑‚ÇÇ) | Œ∑‚ÇÅ + Œ∑‚ÇÇ^2/2 ‚â§ 0}` appearing in Theorem 10.1.4. </code>",
 "42":
 "<code class=\"docstring\">`by_contra h` proves `‚ä¢ p` by contradiction,\nintroducing a hypothesis `h : ¬¨p` and proving `False`.\n* If `p` is a negation `¬¨q`, `h : q` will be introduced instead of `¬¨¬¨q`.\n* If `p` is decidable, it uses `Decidable.byContradiction` instead of `Classical.byContradiction`.\n* If `h` is omitted, the introduced variable will be called `this`.\n</code>",
 "419":
 "<code>dotProduct.{v, u_2} {m : Type u_2} {Œ± : Type v} [Fintype m] [Mul Œ±] [AddCommMonoid Œ±] (v w : m ‚Üí Œ±) : Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`dotProduct v w` is the sum of the entrywise products `v i * w i`.\n\nSee also `dotProductEquiv`. </code>",
 "418": "<code>m ‚Üí Œ±</code>",
 "417": "<code>SupSet Œ±</code>",
 "416":
 "<code>ContinuousOn.{u_1, u_2} {X : Type u_1} {Y : Type u_2} [TopologicalSpace X] [TopologicalSpace Y] (f : X ‚Üí Y)\n  (s : Set X) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function between topological spaces is continuous on a subset `s`\nwhen it's continuous at every point of `s` within `s`. </code>",
 "415":
 "<code>nhdsWithin.{u_1} {X : Type u_1} [TopologicalSpace X] (x : X) (s : Set X) : Filter X</code><span class=\"sep\"></span><code class=\"docstring\">The \"neighborhood within\" filter. Elements of `ùìù[s] x` are sets containing the\nintersection of `s` and a neighborhood of `x`. </code>",
 "414": "<code>Type ?u.931423</code>",
 "413":
 "<code>Nat.succ (n : ‚Ñï) : ‚Ñï</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.26.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "412":
 "<code>prodLinearEquiv_append_coord (n : ‚Ñï) : ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù) ‚âÉ‚Çó[‚Ñù] Fin (n + 1) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Coordinate version of `prodLinearEquiv_append` landing in `Fin (n + 1) ‚Üí Real`. </code>",
 "411":
 "<code>prodLinearEquiv_append {n : ‚Ñï} : ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù) ‚âÉ‚Çó[‚Ñù] EuclideanSpace ‚Ñù (Fin (n + 1))</code><span class=\"sep\"></span><code class=\"docstring\">Linear equivalence between `(Fin n ‚Üí ‚Ñù) √ó ‚Ñù` and `‚Ñù^{n+1}` via append. </code>",
 "410": "<code>Type ?u.445107</code>",
 "41":
 "<code class=\"docstring\">An extension of `linarith` with some preprocessing to allow it to solve some nonlinear arithmetic\nproblems. (Based on Coq's `nra` tactic.) See `linarith` for the available syntax of options,\nwhich are inherited by `nlinarith`; that is, `nlinarith!` and `nlinarith only [h1, h2]` all work as\nin `linarith`. The preprocessing is as follows:\n\n* For every subterm `a ^ 2` or `a * a` in a hypothesis or the goal,\n  the assumption `0 ‚â§ a ^ 2` or `0 ‚â§ a * a` is added to the context.\n* For every pair of hypotheses `a1 R1 b1`, `a2 R2 b2` in the context, `R1, R2 ‚àà {&lt;, ‚â§, =}`,\n  the assumption `0 R' (b1 - a1) * (b2 - a2)` is added to the context (non-recursively),\n  where `R ‚àà {&lt;, ‚â§, =}` is the appropriate comparison derived from `R1, R2`.\n</code>",
 "409": "<code>?m.8</code>",
 "408":
 "<code>recessionCone_sum_epigraph_prod {n m : ‚Ñï} {f f0_plus : Fin m ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí EReal}\n  (hnotbot : ‚àÄ (i : Fin m) (x : Fin n ‚Üí ‚Ñù), f i x ‚â† ‚ä•) (hnotbot0 : ‚àÄ (i : Fin m) (x : Fin n ‚Üí ‚Ñù), f0_plus i x ‚â† ‚ä•)\n  (hconv_i : ‚àÄ (i : Fin m), Convex ‚Ñù (epigraph Set.univ (f i)))\n  (hrec_i : ‚àÄ (i : Fin m), (epigraph Set.univ (f i)).recessionCone = epigraph Set.univ (f0_plus i)) :\n  have g := fun x =&gt; ‚àë i, f i (x i);\n  have g0_plus := fun x =&gt; ‚àë i, f0_plus i (x i);\n  {p | g p.1 ‚â§ ‚Üëp.2}.recessionCone = {p | g0_plus p.1 ‚â§ ‚Üëp.2}</code><span class=\"sep\"></span><code class=\"docstring\">Recession cone of the sum-epigraph on the product space. </code>",
 "407": "<code>(Fin m ‚Üí Fin n ‚Üí ‚Ñù) √ó ‚Ñù</code>",
 "406": "<code>(Fin m ‚Üí Fin n ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "405":
 "<code>‚àÄ (i : Fin m), (epigraph Set.univ (f i)).recessionCone = epigraph Set.univ (f0_plus i)</code>",
 "404": "<code>‚àÄ (i : Fin m), Convex ‚Ñù (epigraph Set.univ (f i))</code>",
 "403": "<code>‚àÄ (i : Fin m) (x : Fin n ‚Üí ‚Ñù), f0_plus i x ‚â† ‚ä•</code>",
 "402": "<code>Fin m</code>",
 "401": "<code>‚àÄ (i : Fin m) (x : Fin n ‚Üí ‚Ñù), @x i x ‚â† ‚ä•</code>",
 "400": "<code>Fin m ‚Üí (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "40":
 "<code class=\"docstring\">`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬¨ p` in the second branch.\n</code>",
 "4":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `h·µ¢`'s, where the `h·µ¢`'s are expressions.-\n- If an `h·µ¢` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]` is like `simp [h‚ÇÅ, h‚ÇÇ, ..., h‚Çô]` but does not use `[simp]` lemmas.\n- `simp [-id‚ÇÅ, ..., -id‚Çô]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `id·µ¢`.\n- `simp at h‚ÇÅ h‚ÇÇ ... h‚Çô` simplifies the hypotheses `h‚ÇÅ : T‚ÇÅ` ... `h‚Çô : T‚Çô`. If\n  the target or another hypothesis depends on `h·µ¢`, a new simplified hypothesis\n  `h·µ¢` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "399":
 "<code>linearMap_prod {n m : ‚Ñï} (A : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin m ‚Üí ‚Ñù) : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù ‚Üí‚Çó[‚Ñù] (Fin m ‚Üí ‚Ñù) √ó ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The lifted linear map on product spaces sending `(x, Œº)` to `(A x, Œº)`. </code>",
 "398": "<code>(Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Fin m ‚Üí ‚Ñù</code>",
 "397": "<code>‚Ñï √ó ‚Ñï</code>",
 "396":
 "<code>EuclideanSpace.equiv.{u_1, u_3} (Œπ : Type u_1) (ùïú : Type u_3) [RCLike ùïú] : EuclideanSpace ùïú Œπ ‚âÉL[ùïú] Œπ ‚Üí ùïú</code><span class=\"sep\"></span><code class=\"docstring\">A shorthand for `PiLp.continuousLinearEquiv`. </code>",
 "395": "<code>Type ?u.881248</code>",
 "394": "<code>Type ?u.881240</code>",
 "393": "<code>Type ?u.878127</code>",
 "392":
 "<code>blockSet {n m : ‚Ñï} (C : Fin m ‚Üí Set (EuclideanSpace ‚Ñù (Fin n))) : Set (EuclideanSpace ‚Ñù (Fin (m * n)))</code><span class=\"sep\"></span><code class=\"docstring\">The block product set in `‚Ñù^{m n}` associated to `C`. </code>",
 "391": "<code>Fin m ‚Üí Set (EuclideanSpace ‚Ñù (Fin a))</code>",
 "390": "<code>?m.10 √ó ?m.11</code>",
 "39":
 "<code class=\"docstring\">A specific universe in Lean's infinite hierarchy of universes. </code>",
 "389": "<code>Type ?u.764067</code>",
 "388": "<code>Type ?u.750575</code>",
 "387": "<code>Type ?u.745475</code>",
 "386": "<code>Type ?u.730270</code>",
 "385": "<code>Type ?u.725187</code>",
 "384": "<code>Type ?u.717811</code>",
 "383": "<code>Type ?u.715718</code>",
 "382": "<code>Type ?u.704986</code>",
 "381": "<code>‚Ñï √ó sorry</code>",
 "380": "<code>Type ?u.696029</code>",
 "38":
 "<code class=\"docstring\">The `let` tactic is for adding definitions to the local context of the main goal.\nThe definition can be unfolded, unlike definitions introduced by `have`.\n\n* `let x : t := e` adds the definition `x : t := e` if `e` is a term of type `t`.\n* `let x := e` uses the type of `e` for `t`.\n* `let : t := e` and `let := e` use `this` for the name of the hypothesis.\n* `let pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that let only one applicable constructor.\n  For example, given `p : Œ± √ó Œ≤ √ó Œ≥`, `let ‚ü®x, y, z‚ü© := p` produces the\n  local variables `x : Œ±`, `y : Œ≤`, and `z : Œ≥`.\n* The syntax `let (eq := h) pat := e` is equivalent to `match h : e with | pat =&gt; _`,\n  which adds the equation `h : e = pat` to the local context.\n\nThe tactic supports all the same syntax variants and options as the `let` term.\n\n## Properties and relations\n\n* Unlike `have`, it is possible to unfold definitions introduced using `let`, using tactics\n  such as `simp`, `dsimp`, `unfold`, and `subst`.\n* The `clear_value` tactic turns a `let` definition into a `have` definition after the fact.\n  The tactic might fail if the local context depends on the value of the variable.\n* The `let` tactic is preferred for data (non-propositions).\n* Sometimes `have` is used for non-propositions to ensure that the variable is never unfolded,\n  which may be important for performance reasons.\n</code>",
 "379": "<code>Type ?u.687300</code>",
 "378": "<code>Type ?u.683880</code>",
 "377":
 "<code>affineSpan.{u_1, u_2, u_3} (k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V] [Module k V]\n  [AddTorsor V P] (s : Set P) : AffineSubspace k P</code><span class=\"sep\"></span><code class=\"docstring\">The affine span of a set of points is the smallest affine subspace containing those points.\n(Actually defined here in terms of spans in modules.) </code>",
 "376":
 "<code>iInf.{u, v} {Œ± : Type u} {Œπ : Sort v} [InfSet Œ±] (s : Œπ ‚Üí Œ±) : Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Indexed infimum </code>",
 "375": "<code class=\"docstring\">Tactic to prove function properties </code>",
 "374":
 "<code>riEpigraph {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Set (EuclideanSpace ‚Ñù (Fin (n + 1)))</code><span class=\"sep\"></span><code class=\"docstring\">Remark 7.0.23: Theorems 7.2 and later show that comparisons between `f` and `cl f`\nhinge on relative interiors; in particular, the set `ri (epi f)` plays a key role. </code>",
 "373":
 "<code>effectiveDomain {n : ‚Ñï} (S : Set (Fin n ‚Üí ‚Ñù)) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.4: The effective domain of a convex function `f` on `S`, denoted `dom f`,\nis the projection of `epi f` onto `R^n`; equivalently,\n`dom f = {x | ‚àÉ Œº, (x, Œº) ‚àà epi f} = {x | f x &lt; +infty}`. </code>",
 "372":
 "<code>convexFunctionClosure {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 7.0.5: The closure of a convex function `f` is the lower semicontinuous hull\nwhen `f` is never `-‚àû`, whereas it is the constant function `-‚àû` when `f` is an\nimproper convex function with `f x = -‚àû` for some `x`. </code>",
 "371": "<code>Œº &gt; sorry</code>",
 "370": "<code>?m.28</code>",
 "37":
 "<code class=\"docstring\">After `with`, there is an optional tactic that runs on all branches, and\nthen a list of alternatives.\n</code>",
 "369": "<code>Fin ?m.4 ‚Üí ‚Ñù</code>",
 "368":
 "<code>epigraphClosureInf {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">The function obtained by taking the infimum of each vertical slice of the epigraph closure. </code>",
 "367":
 "<code>UpperSemicontinuousAt.{u_1, u_2} {Œ± : Type u_1} [TopologicalSpace Œ±] {Œ≤ : Type u_2} [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) (x : Œ±) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">A real function `f` is upper semicontinuous at `x` if, for any `Œµ &gt; 0`, for all `x'` close\nenough to `x`, then `f x'` is at most `f x + Œµ`. We formulate this in a general preordered space,\nusing an arbitrary `y &gt; f x` instead of `f x + Œµ`. </code>",
 "366":
 "<code>LowerSemicontinuousAt.{u_1, u_2} {Œ± : Type u_1} [TopologicalSpace Œ±] {Œ≤ : Type u_2} [Preorder Œ≤] (f : Œ± ‚Üí Œ≤) (x : Œ±) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">A real function `f` is lower semicontinuous at `x` if, for any `Œµ &gt; 0`, for all `x'` close\nenough to `x`, then `f x'` is at least `f x - Œµ`. We formulate this in a general preordered space,\nusing an arbitrary `y &lt; f x` instead of `f x - Œµ`. </code>",
 "365": "<code>‚Ñï √ó ?m.13</code>",
 "364":
 "<code>LinearMap.lsmul.{u_1, u_6} (R : Type u_1) [CommSemiring R] (M : Type u_6) [AddCommMonoid M] [Module R M] :\n  R ‚Üí‚Çó[R] M ‚Üí‚Çó[R] M</code><span class=\"sep\"></span><code class=\"docstring\">Scalar multiplication as a bilinear map `R ‚Üí M ‚Üí M`. </code>",
 "363": "<code>Type u_6</code>",
 "362":
 "<code class=\"docstring\">`set_option &lt;id&gt; &lt;value&gt;` sets the option `&lt;id&gt;` to `&lt;value&gt;`. Depending on the type of the option,\nthe value can be `true`, `false`, a string, or a numeral. Options are used to configure behavior of\nLean as well as user-defined extensions. The setting is active until the end of the current `section`\nor `namespace` or the end of the file.\nAuto-completion is available for `&lt;id&gt;` to list available options.\n\n`set_option &lt;id&gt; &lt;value&gt; in &lt;command&gt;` sets the option for just a single command:\n```\nset_option pp.all true in\n#check 1 + 1\n```\nSimilarly, `set_option &lt;id&gt; &lt;value&gt; in` can also be used inside terms and tactics to set an option\nonly in a single term or tactic.\n</code>",
 "361":
 "<code>directSumSetEuclidean (m p : ‚Ñï) (C1 : Set (EuclideanSpace ‚Ñù (Fin m))) (C2 : Set (EuclideanSpace ‚Ñù (Fin p))) :\n  Set (EuclideanSpace ‚Ñù (Fin (m + p)))</code><span class=\"sep\"></span><code class=\"docstring\">Auxiliary: the direct-sum set `C1 ‚äï C2` in `R^{m+p}`, built via `Fin.appendIsometry`. </code>",
 "360":
 "<code>appendAffineEquiv (m p : ‚Ñï) : EuclideanSpace ‚Ñù (Fin m) √ó EuclideanSpace ‚Ñù (Fin p) ‚âÉ·µÉ[‚Ñù] EuclideanSpace ‚Ñù (Fin (m + p))</code><span class=\"sep\"></span><code class=\"docstring\">The append map on Euclidean spaces is an affine equivalence. </code>",
 "36":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`cases x` splits the main goal, producing one goal for each constructor of the\ninductive type, in which the target is replaced by a general instance of that constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the case split affects that hypothesis as well.\n`cases` detects unreachable cases and closes them automatically.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypothesis `h : P (Nat.succ a)` and target `Q (Nat.succ a)`.\nHere the name `a` is chosen automatically and is not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal,\n  and then cases on the resulting variable.\n- Given `as : List Œ±`, `cases as with | nil =&gt; tac‚ÇÅ | cons a as' =&gt; tac‚ÇÇ`,\n  uses tactic `tac‚ÇÅ` for the `nil` case, and `tac‚ÇÇ` for the `cons` case,\n  and `a` and `as'` are used as names for the new variables introduced.\n- `cases h : e`, where `e` is a variable or an expression,\n  performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis,\n  where `...` is the constructor instance for that particular case.\n</code>",
 "359":
 "<code>Fin.appendIsometry.{u} {Œ± : Type u} [PseudoEMetricSpace Œ±] (m n : ‚Ñï) : (Fin m ‚Üí Œ±) √ó (Fin n ‚Üí Œ±) ‚âÉ·µ¢ (Fin (m + n) ‚Üí Œ±)</code><span class=\"sep\"></span><code class=\"docstring\">The natural `IsometryEquiv` between `(Fin m ‚Üí Œ±) √ó (Fin n ‚Üí Œ±)` and `Fin (m + n) ‚Üí Œ±`.\n`Fin.appendEquiv` as an `IsometryEquiv`. </code>",
 "358":
 "<code>LinearEquiv.piCongrLeft.{u, x, x', u_1} (R : Type u) {Œπ : Type x} {Œπ' : Type x'} [Semiring R] (œÜ : Œπ ‚Üí Type u_1)\n  [(i : Œπ) ‚Üí AddCommMonoid (œÜ i)] [(i : Œπ) ‚Üí Module R (œÜ i)] (e : Œπ' ‚âÉ Œπ) : ((i' : Œπ') ‚Üí œÜ (e i')) ‚âÉ‚Çó[R] (i : Œπ) ‚Üí œÜ i</code><span class=\"sep\"></span><code class=\"docstring\">Transporting dependent functions through an equivalence of the base,\nexpressed as a \"simplification\".\n\nThis is `Equiv.piCongrLeft` as a `LinearEquiv` </code>",
 "357": "<code>Œπ'</code>",
 "356": "<code>Œπ' ‚âÉ Œπ</code>",
 "355": "<code>Œπ</code>",
 "354": "<code>Œπ ‚Üí Type u_1</code>",
 "353": "<code>Type x'</code>",
 "352": "<code>Type x</code>",
 "351": "<code>?m.24</code>",
 "350": "<code>?m.19</code>",
 "35":
 "<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h‚ÇÅ ... h‚Çô`: target the hypotheses `h‚ÇÅ`, ..., `h‚Çô`\n* `at h‚ÇÅ h‚ÇÇ ‚ä¢`: target the hypotheses `h‚ÇÅ` and `h‚ÇÇ`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>",
 "349": "<code>?m.9</code>",
 "348":
 "<code>iSup.{u, v} {Œ± : Type u} {Œπ : Sort v} [SupSet Œ±] (s : Œπ ‚Üí Œ±) : Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Indexed supremum </code>",
 "347": "<code>Sort v</code>",
 "346":
 "<code>rightScalarMultiple {n : ‚Ñï} (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) (lam : ‚Ñù) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.4.2: Let `f : R^n ‚Üí R ‚à™ {+infty}` be convex and `lam ‚àà [0, +infty)`.\nDefine the right scalar multiple `f lam` to be the convex function obtained from\nTheorem 5.3 by taking `F = lam (epi f) ‚äÜ R^{n+1}`. </code>",
 "345": "<code>?m.13</code>",
 "344": "<code>?m.13 √ó ?m.14</code>",
 "343": "<code>InfSet Œ±</code>",
 "342": "<code class=\"docstring\">The universe parameter [anonymous]</code>",
 "341": "<code>(Fin ?m.1 ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "340":
 "<code>indicatorFunction {n : ‚Ñï} (C : Set (Fin n ‚Üí ‚Ñù)) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Defintion 4.8.1: For a set `C ‚äÜ ‚Ñù^n`, the indicator function `Œ¥(¬∑ | C)` is\n`0` on `C` and `+‚àû` outside `C`. </code>",
 "34":
 "<code>Dist.dist.{u_3} {Œ± : Type u_3} [self : Dist Œ±] : Œ± ‚Üí Œ± ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Distance between two points </code>",
 "339":
 "<code>gauge.{u_2} {E : Type u_2} [AddCommGroup E] [Module ‚Ñù E] (s : Set E) (x : E) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The Minkowski functional. Given a set `s` in a real vector space, `gauge s` is the functional\nwhich sends `x : E` to the smallest `r : ‚Ñù` such that `x` is in `s` scaled by `r`. </code>",
 "338":
 "<code>epigraph {n : ‚Ñï} (S : Set (Fin n ‚Üí ‚Ñù)) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.1: Let `f` be a function with values in `R` union\n`{plus or minus infinity}` whose domain is a subset `S` of `R^n`. The set\n`{(x, mu) | x in S, mu in R, mu &gt;= f x}` is called the epigraph of `f`,\ndenoted `epi f`. </code>",
 "337":
 "<code>infimalConvolution {n : ‚Ñï} (f g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : (Fin n ‚Üí ‚Ñù) ‚Üí EReal</code><span class=\"sep\"></span><code class=\"docstring\">Text 5.4.0 (Infimal convolution of two functions): Let `f, g : R^n -&gt; R union {+infty}`\nbe proper convex functions. Their infimal convolution `f square g` is the function\n`(f square g)(x) = inf { f x1 + g x2 | x1, x2 in R^n, x1 + x2 = x }`, equivalently\n`(f square g)(x) = inf_{y in R^n} { f y + g (x - y) }`. </code>",
 "336":
 "<code class=\"docstring\">Theorems tagged with the `simp` attribute are used by the simplifier\n(i.e., the `simp` tactic, and its variants) to simplify expressions occurring in your goals.\nWe call theorems tagged with the `simp` attribute \"simp theorems\" or \"simp lemmas\".\nLean maintains a database/index containing all active simp theorems.\nHere is an example of a simp theorem.\n```lean\n@[simp] theorem ne_eq (a b : Œ±) : (a ‚â† b) = Not (a = b) := rfl\n```\nThis simp theorem instructs the simplifier to replace instances of the term\n`a ‚â† b` (e.g. `x + 0 ‚â† y`) with `Not (a = b)` (e.g., `Not (x + 0 = y)`).\nThe simplifier applies simp theorems in one direction only:\nif `A = B` is a simp theorem, then `simp` replaces `A`s with `B`s,\nbut it doesn't replace `B`s with `A`s. Hence a simp theorem should have the\nproperty that its right-hand side is \"simpler\" than its left-hand side.\nIn particular, `=` and `‚Üî` should not be viewed as symmetric operators in this situation.\nThe following would be a terrible simp theorem (if it were even allowed):\n```lean\n@[simp] lemma mul_right_inv_bad (a : G) : 1 = a * a‚Åª¬π := ...\n```\nReplacing 1 with a * a‚Åª¬π is not a sensible default direction to travel.\nEven worse would be a theorem that causes expressions to grow without bound,\ncausing simp to loop forever.\n\nBy default the simplifier applies `simp` theorems to an expression `e`\nafter its sub-expressions have been simplified.\nWe say it performs a bottom-up simplification.\nYou can instruct the simplifier to apply a theorem before its sub-expressions\nhave been simplified by using the modifier `‚Üì`. Here is an example\n```lean\n@[simp‚Üì] theorem not_and_eq (p q : Prop) : (¬¨ (p ‚àß q)) = (¬¨p ‚à® ¬¨q) :=\n```\n\nYou can instruct the simplifier to rewrite the lemma from right-to-left:\n```lean\nattribute @[simp ‚Üê] and_assoc\n```\n\nWhen multiple simp theorems are applicable, the simplifier uses the one with highest priority.\nThe equational theorems of functions are applied at very low priority (100 and below).\nIf there are several with the same priority, it is uses the \"most recent one\". Example:\n```lean\n@[simp high] theorem cond_true (a b : Œ±) : cond true a b = a := rfl\n@[simp low+1] theorem or_true (p : Prop) : (p ‚à® True) = True :=\n  propext &lt;| Iff.intro (fun _ =&gt; trivial) (fun _ =&gt; Or.inr trivial)\n@[simp 100] theorem ite_self {d : Decidable c} (a : Œ±) : ite c a a = a := by\n  cases d &lt;;&gt; rfl\n```\n</code>",
 "335":
 "<code>expEReal (z : EReal) : EReal</code><span class=\"sep\"></span><code class=\"docstring\">Extended-real exponential with `expEReal ‚ä§ = ‚ä§` and `expEReal ‚ä• = 0`. </code>",
 "334":
 "<code>Finset.univ.{u_1} {Œ± : Type u_1} [Fintype Œ±] : Finset Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`univ` is the universal finite set of type `Finset Œ±` implied from\nthe assumption `Fintype Œ±`. </code>",
 "333":
 "<code class=\"docstring\">`rename_i x_1 ... x_n` renames the last `n` inaccessible names using the given names. </code>",
 "332":
 "<code>EReal.neg_add {x y : EReal} (h1 : x ‚â† ‚ä• ‚à® y ‚â† ‚ä§) (h2 : x ‚â† ‚ä§ ‚à® y ‚â† ‚ä•) : -(x + y) = -x - y</code>",
 "331": "<code>x ‚â† ‚ä§ ‚à® y ‚â† ‚ä•</code>",
 "330": "<code>x ‚â† ‚ä• ‚à® y ‚â† ‚ä§</code>",
 "33":
 "<code class=\"docstring\">* `symm` applies to a goal whose target has the form `t ~ u` where `~` is a symmetric relation,\n  that is, a relation which has a symmetry lemma tagged with the attribute [symm].\n  It replaces the target with `u ~ t`.\n* `symm at h` will rewrite a hypothesis `h : t ~ u` to `h : u ~ t`.\n</code>",
 "329": "<code>EReal</code>",
 "328":
 "<code>SupSet.sSup.{u_1} {Œ± : Type u_1} [self : SupSet Œ±] : Set Œ± ‚Üí Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Supremum of a set </code>",
 "327":
 "<code>InfSet.sInf.{u_1} {Œ± : Type u_1} [self : InfSet Œ±] : Set Œ± ‚Üí Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Infimum of a set </code>",
 "326":
 "<code class=\"docstring\">`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) =&gt; `(tactic| simp)\n```\n</code>",
 "325":
 "<code>ConvexFunctionOn {n : ‚Ñï} (S : Set (Fin n ‚Üí ‚Ñù)) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.2: A function `f` on `S` is a convex function if `epi f` is\nconvex as a subset of `R^{n+1}`. </code>",
 "324": "<code>(Fin n ‚Üí ‚Ñù) ‚Üí EReal</code>",
 "323":
 "<code>Matrix.PosSemidef.{u_2, u_3} {n : Type u_2} {R : Type u_3} [Ring R] [PartialOrder R] [StarRing R] (M : Matrix n n R) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">A matrix `M : Matrix n n R` is positive semidefinite if it is Hermitian and `x·¥¥ * M * x` is\nnonnegative for all `x` of finite support. </code>",
 "322": "<code>Matrix n n R</code>",
 "321": "<code><span class=\"literal string\">\" # \"</span> : String</code>",
 "320": "<code>?m.3</code>",
 "32":
 "<code class=\"docstring\">* `unfold id` unfolds all occurrences of definition `id` in the target.\n* `unfold id1 id2 ...` is equivalent to `unfold id1; unfold id2; ...`.\n* `unfold id at h` unfolds at the hypothesis `h`.\n\nDefinitions can be either global or local definitions.\n\nFor non-recursive global definitions, this tactic is identical to `delta`.\nFor recursive global definitions, it uses the \"unfolding lemma\" `id.eq_def`,\nwhich is generated for each recursive definition, to unfold according to the recursive definition given by the user.\nOnly one level of unfolding is performed, in contrast to `simp only [id]`, which unfolds definition `id` recursively.\n</code>",
 "319": "<code>x1 ‚àà sorry</code>",
 "318": "<code>?m.17</code>",
 "317":
 "<code class=\"docstring\">`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n</code>",
 "316": "<code>?m.11</code>",
 "315": "<code>?m.15 x‚úù</code>",
 "314": "<code>?m.15 x</code>",
 "313":
 "<code>Fin.cons.{u} {n : ‚Ñï} {Œ± : Fin (n + 1) ‚Üí Sort u} (x : Œ± 0) (p : (i : Fin n) ‚Üí Œ± i.succ) (i : Fin (n + 1)) : Œ± i</code><span class=\"sep\"></span><code class=\"docstring\">Adding an element at the beginning of an `n`-tuple, to get an `n+1`-tuple. </code>",
 "312": "<code>(i : Fin n) ‚Üí Œ± i.succ</code>",
 "311": "<code>Œ± 0</code>",
 "310": "<code>Fin (n + 1) ‚Üí Sort u</code>",
 "31":
 "<code>realDist (x y : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.2: the distance function on `‚Ñù`. </code>",
 "309": "<code>?m.19 x</code>",
 "308": "<code>?m.9 ‚Üí ‚Ñï</code>",
 "307": "<code>?m.22 x</code>",
 "306": "<code>?m.11 ‚Üí ‚Ñï</code>",
 "305":
 "<code>linearComparisonSet (n : ‚Ñï) (b : Fin n ‚Üí ‚Ñù) (Œ≤ : ‚Ñù) : LinearComparison ‚Üí Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Interpret `‚ü™x, b‚ü´ (rel) Œ≤` as a subset of `Real^n`. </code>",
 "304":
 "<code>LinearComparison : Type</code><span class=\"sep\"></span><code class=\"docstring\">A comparison symbol for linear inequalities/equations. </code>",
 "303":
 "<code class=\"docstring\">`show t` finds the first goal whose target unifies with `t`. It makes that the main goal,\nperforms the unification, and replaces the target with the unified version of `t`.\n</code>",
 "302":
 "<code class=\"docstring\">`clear x...` removes the given hypotheses, or fails if there are remaining\nreferences to a hypothesis.\n</code>",
 "301": "<code>Set (Fin n ‚Üí ‚Ñù)</code>",
 "300":
 "<code>convexSetDim (n : ‚Ñï) (C : Set (Fin n ‚Üí ‚Ñù)) : ‚Ñï</code><span class=\"sep\"></span><code class=\"docstring\">Definition 2.4.10. The dimension of a convex set `C` is the dimension of the affine\nhull of `C`. </code>",
 "30": "<code>‚Ñù</code>",
 "3":
 "<code class=\"docstring\">Step-wise reasoning over transitive relations.\n```\ncalc\n  a = b := pab\n  b = c := pbc\n  ...\n  y = z := pyz\n```\nproves `a = z` from the given step-wise proofs. `=` can be replaced with any\nrelation implementing the typeclass `Trans`. Instead of repeating the right-\nhand sides, subsequent left-hand sides can be replaced with `_`.\n```\ncalc\n  a = b := pab\n  _ = c := pbc\n  ...\n  _ = z := pyz\n```\nIt is also possible to write the *first* relation as `&lt;lhs&gt;\\n  _ = &lt;rhs&gt; :=\n&lt;proof&gt;`. This is useful for aligning relation symbols, especially on longer:\nidentifiers:\n```\ncalc abc\n  _ = bce := pabce\n  _ = cef := pbcef\n  ...\n  _ = xyz := pwxyz\n```\n\n`calc` works as a term, as a tactic or as a `conv` tactic.\n\nSee [Theorem Proving in Lean 4][tpil4] for more information.\n\n[tpil4]: https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#calculational-proofs\n</code>",
 "299":
 "<code>Set.range.{u, u_1} {Œ± : Type u} {Œπ : Sort u_1} (f : Œπ ‚Üí Œ±) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Range of a function.\n\nThis function is more flexible than `f '' univ`, as the image requires that the domain is in Type\nand not an arbitrary Sort. </code>",
 "298": "<code>Œπ ‚Üí a</code>",
 "297": "<code>Sort u_1</code>",
 "296":
 "<code>Fintype.{u_4} (Œ± : Type u_4) : Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">`Fintype Œ±` means that `Œ±` is finite, i.e. there are only\nfinitely many distinct elements of type `Œ±`. The evidence of this\nis a finset `elems` (a list up to permutation without duplicates),\ntogether with a proof that everything of type `Œ±` is in the list. </code>",
 "295":
 "<code>convexHull.{u_1, u_2} (ùïú : Type u_1) {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [Module ùïú E] :\n  ClosureOperator (Set E)</code><span class=\"sep\"></span><code class=\"docstring\">The convex hull of a set `s` is the minimal convex set that includes `s`. </code>",
 "294":
 "<code class=\"docstring\">`fin_cases h` performs case analysis on a hypothesis of the form\n`h : A`, where `[Fintype A]` is available, or\n`h : a ‚àà A`, where `A : Finset X`, `A : Multiset X` or `A : List X`.\n\nAs an example, in\n```\nexample (f : ‚Ñï ‚Üí Prop) (p : Fin 3) (h0 : f 0) (h1 : f 1) (h2 : f 2) : f p.val := by\n  fin_cases p; simp\n  all_goals assumption\n```\nafter `fin_cases p; simp`, there are three goals, `f 0`, `f 1`, and `f 2`.\n</code>",
 "293":
 "<code>IsConvexCombination (n m : ‚Ñï) (x : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (y : Fin n ‚Üí ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 2.2.10. A vector sum `Œª‚ÇÅ x‚ÇÅ + ‚ãØ + Œª‚Çò x‚Çò` is called a convex combination of\n`x‚ÇÅ, ..., x‚Çò` if `Œª i ‚â• 0` for all `i` and `Œª‚ÇÅ + ‚ãØ + Œª‚Çò = 1`. </code>",
 "292": "<code>Fin m ‚Üí Fin n ‚Üí ‚Ñù</code>",
 "291":
 "<code class=\"docstring\">The syntax `variable (X Y ... Z : Sort*)` creates a new distinct implicit universe variable\nfor each variable in the sequence. </code>",
 "290":
 "<code>segment.{u_1, u_2} (ùïú : Type u_1) {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SMul ùïú E] (x y : E) :\n  Set E</code><span class=\"sep\"></span><code class=\"docstring\">Segments in a vector space. </code>",
 "29":
 "<code>MetricAxioms.{u_1} {X : Type u_1} (d : X ‚Üí X ‚Üí ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 1.3 (Metric space): a metric satisfies the usual axioms. </code>",
 "289":
 "<code>Convex.{u_1, u_2} (ùïú : Type u_1) {E : Type u_2} [Semiring ùïú] [PartialOrder ùïú] [AddCommMonoid E] [SMul ùïú E] (s : Set E) :\n  Prop</code><span class=\"sep\"></span><code class=\"docstring\">Convexity of sets. </code>",
 "288":
 "<code>affineHull (n : ‚Ñï) (S : Set (Fin n ‚Üí ‚Ñù)) : Set (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">Text 1.8: For any `S ‚äÜ R^n` there is a unique smallest affine set containing `S`,\nnamely the intersection of all affine sets containing `S`. This set is called the affine\nhull of `S` and is denoted `aff S`. </code>",
 "287":
 "<code>Fin.cases.{u_1} {n : ‚Ñï} {motive : Fin (n + 1) ‚Üí Sort u_1} (zero : motive 0) (succ : (i : Fin n) ‚Üí motive i.succ)\n  (i : Fin (n + 1)) : motive i</code><span class=\"sep\"></span><code class=\"docstring\">Proves a statement by cases on the underlying `Nat` value in a `Fin (n + 1)`.\n\nThe two cases are:\n* `zero`, used when the value is of the form `(0 : Fin (n + 1))`\n* `succ`, used when the value is of the form `(j : Fin n).succ`\n\nThe corresponding induction principle is `Fin.induction`.\n</code>",
 "286": "<code>Fin (n + 1)</code>",
 "285": "<code>Fin n</code>",
 "284": "<code>(i : Fin n) ‚Üí motive i.succ</code>",
 "283": "<code>motive 0</code>",
 "282": "<code>Fin (n + 1) ‚Üí Sort u_1</code>",
 "281":
 "<code>AffineMap.{u_1, u_2, u_3, u_4, u_5} (k : Type u_1) {V1 : Type u_2} (P1 : Type u_3) {V2 : Type u_4} (P2 : Type u_5)\n  [Ring k] [AddCommGroup V1] [Module k V1] [AddTorsor V1 P1] [AddCommGroup V2] [Module k V2] [AddTorsor V2 P2] :\n  Type (max (max (max u_2 u_3) u_4) u_5)</code><span class=\"sep\"></span><code class=\"docstring\">An `AffineMap k P1 P2` (notation: `P1 ‚Üí·µÉ[k] P2`) is a map from `P1` to `P2` that\ninduces a corresponding linear map from `V1` to `V2`. </code>",
 "280":
 "<code class=\"docstring\">Applies the first constructor when\nthe goal is an inductive type with exactly two constructors, or fails otherwise.\n```\nexample : True ‚à® False := by\n  left\n  trivial\n```\n</code>",
 "28": "<code>X ‚Üí X ‚Üí ‚Ñù</code>",
 "279":
 "<code>AffineIndependent.{u_1, u_2, u_3, u_4} (k : Type u_1) {V : Type u_2} {P : Type u_3} [Ring k] [AddCommGroup V]\n  [Module k V] [AddTorsor V P] {Œπ : Type u_4} (p : Œπ ‚Üí P) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An indexed family is said to be affinely independent if no\nnontrivial weighted subtractions (where the sum of weights is 0) are\n0. </code>",
 "278": "<code>Œπ ‚Üí P</code>",
 "277":
 "<code>dotProductLinear (n : ‚Ñï) (b : Fin n ‚Üí ‚Ñù) : Module.Dual ‚Ñù (Fin n ‚Üí ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The linear functional `x ‚Ü¶ x ‚¨ù·µ• b`. </code>",
 "276": "<code>Fin n ‚Üí ‚Ñù</code>",
 "275":
 "<code class=\"docstring\">Tactic for evaluating equations in the language of\n*additive*, commutative monoids and groups.\n\n`abel` and its variants work as both tactics and conv tactics.\n\n* `abel1` fails if the target is not an equality that is provable by the axioms of\n  commutative monoids/groups.\n* `abel_nf` rewrites all group expressions into a normal form.\n  * In tactic mode, `abel_nf at h` can be used to rewrite in a hypothesis.\n  * `abel_nf (config := cfg)` allows for additional configuration:\n    * `red`: the reducibility setting (overridden by `!`)\n    * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n    * `recursive`: if true, `abel_nf` will also recurse into atoms\n* `abel!`, `abel1!`, `abel_nf!` will use a more aggressive reducibility setting to identify atoms.\n\nFor example:\n\n```\nexample [AddCommMonoid Œ±] (a b : Œ±) : a + (b + a) = a + a + b := by abel\nexample [AddCommGroup Œ±] (a : Œ±) : (3 : ‚Ñ§) ‚Ä¢ a = a + (2 : ‚Ñ§) ‚Ä¢ a := by abel\n```\n\n## Future work\n\n* In mathlib 3, `abel` accepted additional optional arguments:\n  ```\n  syntax \"abel\" (&\" raw\" &lt;|&gt; &\" term\")? (location)? : tactic\n  ```\n  It is undecided whether these features should be restored eventually.\n</code>",
 "274": "<code>?m.23 x‚úù</code>",
 "273": "<code>?m.23 x</code>",
 "272":
 "<code>fderivWithin.{u_4, u_5, u_6} (ùïú : Type u_4) [NontriviallyNormedField ùïú] {E : Type u_5} [AddCommGroup E] [Module ùïú E]\n  [TopologicalSpace E] {F : Type u_6} [AddCommGroup F] [Module ùïú F] [TopologicalSpace F] (f : E ‚Üí F) (s : Set E)\n  (x : E) : E ‚ÜíL[ùïú] F</code><span class=\"sep\"></span><code class=\"docstring\">If `f` has a derivative at `x` within `s`, then `fderivWithin ùïú f s x` is such a derivative.\nOtherwise, it is set to `0`. We also set it to be zero, if zero is one of possible derivatives. </code>",
 "271":
 "<code>operatorNormOneTwo.{u_3, u_4} {E‚ÇÅ : Type u_3} {E‚ÇÇ : Type u_4} [NormedAddCommGroup E‚ÇÅ] [InnerProductSpace ‚Ñù E‚ÇÅ]\n  [NormedAddCommGroup E‚ÇÇ] [InnerProductSpace ‚Ñù E‚ÇÇ] (A : E‚ÇÅ ‚Üí‚Çó[‚Ñù] E‚ÇÇ ‚ÜíL[‚Ñù] ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 6.3: For a linear operator `A : E‚ÇÅ ‚Üí (E‚ÇÇ ‚ÜíL[‚Ñù] ‚Ñù)`, define\n`‚ÄñA‚Äñ_{1,2}` as the supremum of the pairings `(A x) u` over all unit vectors\n`x : E‚ÇÅ` and `u : E‚ÇÇ`. In finite-dimensional spaces this equals the stated maximum. </code>",
 "270": "<code>E‚ÇÅ ‚Üí‚Çó[‚Ñù] E‚ÇÇ ‚ÜíL[‚Ñù] ‚Ñù</code>",
 "27": "<code>Type u_1</code>",
 "269":
 "<code>innerFenchelConjugateRealDom.{u_1} {E : Type u_1} [NormedAddCommGroup E] [InnerProductSpace ‚Ñù E] (f : E ‚Üí EReal) : Set E</code><span class=\"sep\"></span><code class=\"docstring\">The finite-real effective domain of the Fenchel conjugate. </code>",
 "268":
 "<code>Finset.{u_4} (Œ± : Type u_4) : Type u_4</code><span class=\"sep\"></span><code class=\"docstring\">`Finset Œ±` is the type of finite sets of elements of `Œ±`. It is implemented\nas a multiset (a list up to permutation) which has no duplicate elements. </code>",
 "267":
 "<code class=\"docstring\">`simp_rw` functions as a mix of `simp` and `rw`. Like `rw`, it applies each\nrewrite rule in the given order, but like `simp` it repeatedly applies these\nrules and also under binders like `‚àÄ x, ...`, `‚àÉ x, ...` and `fun x ‚Ü¶...`.\nUsage:\n\n- `simp_rw [lemma_1, ..., lemma_n]` will rewrite the goal by applying the\n  lemmas in that order. A lemma preceded by `‚Üê` is applied in the reverse direction.\n- `simp_rw [lemma_1, ..., lemma_n] at h‚ÇÅ ... h‚Çô` will rewrite the given hypotheses.\n- `simp_rw [...] at *` rewrites in the whole context: all hypotheses and the goal.\n\nLemmas passed to `simp_rw` must be expressions that are valid arguments to `simp`.\nFor example, neither `simp` nor `rw` can solve the following, but `simp_rw` can:\n\n```lean\nexample {a : ‚Ñï}\n    (h1 : ‚àÄ a b : ‚Ñï, a - 1 ‚â§ b ‚Üî a ‚â§ b + 1)\n    (h2 : ‚àÄ a b : ‚Ñï, a ‚â§ b ‚Üî ‚àÄ c, c &lt; a ‚Üí c &lt; b) :\n    (‚àÄ b, a - 1 ‚â§ b) = ‚àÄ b c : ‚Ñï, c &lt; a ‚Üí c &lt; b + 1 := by\n  simp_rw [h1, h2]\n```\n</code>",
 "266":
 "<code>periodicConvolution (f g : C(AddCircle 1, ‚ÑÇ)) : C(AddCircle 1, ‚ÑÇ)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 5.4.2: for continuous `f, g : C(‚Ñù/‚Ñ§; ‚ÑÇ)`, the periodic convolution\nis the continuous function on `‚Ñù/‚Ñ§` given by\n`(f * g)(x) = ‚à´ y ‚àà [0,1], f(y) g(x - y) dy` with `y` viewed in `‚Ñù/‚Ñ§`. </code>",
 "265":
 "<code>fourierCharacter (n : ‚Ñ§) : C(AddCircle 1, ‚ÑÇ)</code><span class=\"sep\"></span><code class=\"docstring\">Definition 5.3.1 (Characters): for every integer `n`, define\n`e_n ‚àà C(‚Ñù/‚Ñ§; ‚ÑÇ)` by `e_n(x) = exp(2œÄ i n x)`. </code>",
 "264":
 "<code>Finsupp.{u_9, u_10} (Œ± : Type u_9) (M : Type u_10) [Zero M] : Type (max u_10 u_9)</code><span class=\"sep\"></span><code class=\"docstring\">`Finsupp Œ± M`, denoted `Œ± ‚Üí‚ÇÄ M`, is the type of functions `f : Œ± ‚Üí M` such that\n`f x = 0` for all but finitely many `x`. </code>",
 "263": "<code>Type u_10</code>",
 "262": "<code>Type u_9</code>",
 "261":
 "<code>AddCircle.{u_1} {ùïú : Type u_1} [AddCommGroup ùïú] (p : ùïú) : Type u_1</code><span class=\"sep\"></span><code class=\"docstring\">The \"additive circle\": `ùïú ‚ß∏ ‚Ñ§ ‚àô p`. See also `Circle` and `Real.Angle`. </code>",
 "260":
 "<code>fourierTransform (f : C(AddCircle 1, ‚ÑÇ)) : ‚Ñ§ ‚Üí ‚ÑÇ</code><span class=\"sep\"></span><code class=\"docstring\">Definition 5.3.7 (Fourier transform): for `f ‚àà C(‚Ñù/‚Ñ§; ‚ÑÇ)`, its Fourier transform is the\nfunction `‚Ñ§ ‚Üí ‚ÑÇ` sending `n` to the `n`-th Fourier coefficient\n`‚à´ x in (0 : ‚Ñù)..1, f x * exp (-2œÄ i n x)`. </code>",
 "26":
 "<code class=\"docstring\">`subst x...` substitutes each hypothesis `x` with a definition found in the local context,\nthen eliminates the hypothesis.\n- If `x` is a local definition, then its definition is used.\n- Otherwise, if there is a hypothesis of the form `x = e` or `e = x`,\n  then `e` is used for the definition of `x`.\n\nIf `h : a = b`, then `subst h` may be used if either `a` or `b` unfolds to a local hypothesis.\nThis is similar to the `cases h` tactic.\n\nSee also: `subst_vars` for substituting all local hypotheses that have a defining equation.\n</code>",
 "259": "<code>C(AddCircle 1, ‚ÑÇ)</code>",
 "258":
 "<code>fourierLp {T : ‚Ñù} [hT : Fact (0 &lt; T)] (p : ENNReal) [Fact (1 ‚â§ p)] (n : ‚Ñ§) :\n  ‚Ü•(MeasureTheory.Lp ‚ÑÇ p AddCircle.haarAddCircle)</code><span class=\"sep\"></span><code class=\"docstring\">The family of monomials `fourier n`, parametrized by `n : ‚Ñ§` and considered as\nelements of the `Lp` space of functions `AddCircle T ‚Üí ‚ÑÇ`. </code>",
 "257":
 "<code>sumExpModes : ‚Ñï ‚Üí { h // Continuous h ‚àß Function.Periodic h 1 }</code><span class=\"sep\"></span><code class=\"docstring\">Helper for Exercise 5.2.3: partial sums of positive Fourier modes. </code>",
 "256":
 "<code class=\"docstring\">The `rintro` tactic is a combination of the `intros` tactic with `rcases` to\nallow for destructuring patterns while introducing variables. See `rcases` for\na description of supported patterns. For example, `rintro (a | ‚ü®b, c‚ü©) ‚ü®d, e‚ü©`\nwill introduce two variables, and then do case splits on both of them producing\ntwo subgoals, one with variables `a d e` and the other with `b c d e`.\n\n`rintro`, unlike `rcases`, also supports the form `(x y : ty)` for introducing\nand type-ascripting multiple variables at once, similar to binders.\n</code>",
 "255":
 "<code>periodicInnerProduct (f g : { h // Continuous h ‚àß Function.Periodic h 1 }) : ‚ÑÇ</code><span class=\"sep\"></span><code class=\"docstring\">Definition 5.2.1 (Inner product): for `f, g ‚àà C(‚Ñù/‚Ñ§;‚ÑÇ)` (modeled as continuous,\n`‚Ñ§`-periodic functions `‚Ñù ‚Üí ‚ÑÇ`), define\n`‚ü™f, g‚ü´ = ‚à´ x in [0,1], f x * conj (g x) dx`. </code>",
 "254":
 "<code>periodicL2Norm (f : { h // Continuous h ‚àß Function.Periodic h 1 }) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The `L^2` norm on continuous, `1`-periodic complex-valued functions induced by\nthe inner product `‚ü™f, g‚ü´ = ‚à´_[0,1] f \\overline{g}`. </code>",
 "253": "<code>{ h // Continuous h ‚àß Function.Periodic h 1 }</code>",
 "252":
 "<code>IsPeriodicWithPeriod (L : ‚Ñù) (f : ‚Ñù ‚Üí ‚ÑÇ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 5.1.1: Let L &gt; 0. A function f : ‚Ñù ‚Üí ‚ÑÇ is periodic with period L\nif for every x : ‚Ñù, one has f (x + L) = f x. </code>",
 "251": "<code>‚Ñù ‚Üí ‚ÑÇ</code>",
 "250":
 "<code>scaledCosineSeriesFunction : ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.7.4: Define `f : ‚Ñù ‚Üí ‚Ñù` by\n`f(x) = ‚àë' n = 1..‚àû, 4^{-n} * cos(32^n * œÄ * x)`.\nEquivalently (reindexing by `n : ‚Ñï`),\n`f(x) = ‚àë' n, (1 / 4^(n+1)) * cos(32^(n+1) * œÄ * x)`. </code>",
 "25":
 "<code class=\"docstring\">The syntax `variable (X Y ... Z : Type*)` creates a new distinct implicit universe variable\n`&gt; 0` for each variable in the sequence. </code>",
 "249":
 "<code class=\"docstring\">The `gcongr` tactic applies \"generalized congruence\" rules, reducing a relational goal\nbetween an LHS and RHS.  For example,\n```\nexample {a b x c d : ‚Ñù} (h1 : a + 1 ‚â§ b + 1) (h2 : c + 2 ‚â§ d + 2) :\n    x ^ 2 * a + c ‚â§ x ^ 2 * b + d := by\n  gcongr\n  ¬∑ linarith\n  ¬∑ linarith\n```\nThis example has the goal of proving the relation `‚â§` between an LHS and RHS both of the pattern\n```\nx ^ 2 * ?_ + ?_\n```\n(with inputs `a`, `c` on the left and `b`, `d` on the right); after the use of\n`gcongr`, we have the simpler goals `a ‚â§ b` and `c ‚â§ d`.\n\nA depth limit or a pattern can be provided explicitly;\nthis is useful if a non-maximal match is desired:\n```\nexample {a b c d x : ‚Ñù} (h : a + c + 1 ‚â§ b + d + 1) :\n    x ^ 2 * (a + c) + 5 ‚â§ x ^ 2 * (b + d) + 5 := by\n  gcongr x ^ 2 * ?_ + 5 -- or `gcongr 2`\n  linarith\n```\n\nThe \"generalized congruence\" rules are the library lemmas which have been tagged with the\nattribute `@[gcongr]`.  For example, the first example constructs the proof term\n```\nadd_le_add (mul_le_mul_of_nonneg_left ?_ (Even.pow_nonneg (even_two_mul 1) x)) ?_\n```\nusing the generalized congruence lemmas `add_le_add` and `mul_le_mul_of_nonneg_left`.\n\nThe tactic attempts to discharge side goals to these \"generalized congruence\" lemmas (such as the\nside goal `0 ‚â§ x ^ 2` in the above application of `mul_le_mul_of_nonneg_left`) using the tactic\n`gcongr_discharger`, which wraps `positivity` but can also be extended. Side goals not discharged\nin this way are left for the user.\n\n`gcongr` will descend into binders (for example sums or suprema). To name the bound variables,\nuse `with`:\n```\nexample {f g : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû} (h : ‚àÄ n, f n ‚â§ g n) : ‚®Ü n, f n ‚â§ ‚®Ü n, g n := by\n  gcongr with i\n  exact h i\n```\n</code>",
 "248":
 "<code>Real.pi : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The number œÄ = 3.14159265... Defined here using choice as twice a zero of cos in [1,2],\nfrom which one can derive all its properties. For explicit bounds on œÄ,\nsee `Mathlib/Analysis/Real/Pi/Bounds.lean`.\n\nDenoted `œÄ`, once the `Real` namespace is opened. </code>",
 "247":
 "<code>Real.deriv_arctan : deriv Real.arctan = fun x =&gt; 1 / (1 + x ^ 2)</code>",
 "246":
 "<code>Real.arctan (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Inverse of the `tan` function, returns values in the range `-œÄ / 2 &lt; arctan x` and\n`arctan x &lt; œÄ / 2` </code>",
 "245":
 "<code>Real.tan (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The real tangent function, defined as the real part of the complex tangent </code>",
 "244":
 "<code>firstPositiveSineZero : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.7.2: Define `œÄ` to be\n`inf {x ‚àà (0, ‚àû) : Real.sin x = 0}`. </code>",
 "243":
 "<code>Real.cos (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The real cosine function, defined as the real part of the complex cosine </code>",
 "242":
 "<code>Real.sin (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The real sine function, defined as the real part of the complex sine </code>",
 "241":
 "<code>Neg.{u} (Œ± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">The notation typeclass for negation.\nThis enables the notation `-a : Œ±` where `a : Œ±`.\n</code>",
 "240":
 "<code>Complex.normSq : ‚ÑÇ ‚Üí*‚ÇÄ ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The norm squared function. </code>",
 "24":
 "<code class=\"docstring\">`rcases` is a tactic that will perform `cases` recursively, according to a pattern. It is used to\ndestructure hypotheses or expressions composed of inductive types like `h1 : a ‚àß b ‚àß c ‚à® d` or\n`h2 : ‚àÉ x y, trans_rel R x y`. Usual usage might be `rcases h1 with ‚ü®ha, hb, hc‚ü© | hd` or\n`rcases h2 with ‚ü®x, y, _ | ‚ü®z, hxz, hzy‚ü©‚ü©` for these examples.\n\nEach element of an `rcases` pattern is matched against a particular local hypothesis (most of which\nare generated during the execution of `rcases` and represent individual elements destructured from\nthe input expression). An `rcases` pattern has the following grammar:\n\n* A name like `x`, which names the active hypothesis as `x`.\n* A blank `_`, which does nothing (letting the automatic naming system used by `cases` name the\n  hypothesis).\n* A hyphen `-`, which clears the active hypothesis and any dependents.\n* The keyword `rfl`, which expects the hypothesis to be `h : a = b`, and calls `subst` on the\n  hypothesis (which has the effect of replacing `b` with `a` everywhere or vice versa).\n* A type ascription `p : ty`, which sets the type of the hypothesis to `ty` and then matches it\n  against `p`. (Of course, `ty` must unify with the actual type of `h` for this to work.)\n* A tuple pattern `‚ü®p1, p2, p3‚ü©`, which matches a constructor with many arguments, or a series\n  of nested conjunctions or existentials. For example if the active hypothesis is `a ‚àß b ‚àß c`,\n  then the conjunction will be destructured, and `p1` will be matched against `a`, `p2` against `b`\n  and so on.\n* A `@` before a tuple pattern as in `@‚ü®p1, p2, p3‚ü©` will bind all arguments in the constructor,\n  while leaving the `@` off will only use the patterns on the explicit arguments.\n* An alternation pattern `p1 | p2 | p3`, which matches an inductive type with multiple constructors,\n  or a nested disjunction like `a ‚à® b ‚à® c`.\n\nA pattern like `‚ü®a, b, c‚ü© | ‚ü®d, e‚ü©` will do a split over the inductive datatype,\nnaming the first three parameters of the first constructor as `a,b,c` and the\nfirst two of the second constructor `d,e`. If the list is not as long as the\nnumber of arguments to the constructor or the number of constructors, the\nremaining variables will be automatically named. If there are nested brackets\nsuch as `‚ü®‚ü®a‚ü©, b | c‚ü© | d` then these will cause more case splits as necessary.\nIf there are too many arguments, such as `‚ü®a, b, c‚ü©` for splitting on\n`‚àÉ x, ‚àÉ y, p x`, then it will be treated as `‚ü®a, ‚ü®b, c‚ü©‚ü©`, splitting the last\nparameter as necessary.\n\n`rcases` also has special support for quotient types: quotient induction into Prop works like\nmatching on the constructor `quot.mk`.\n\n`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an\nassumption `h : e = PAT` will be added to the context.\n</code>",
 "239":
 "<code>Star.star.{u} {R : Type u} [self : Star R] : R ‚Üí R</code><span class=\"sep\"></span><code class=\"docstring\">A star operation (e.g. complex conjugate).\n</code>",
 "238": "<code>Star R</code>",
 "237":
 "<code>Complex : Type</code><span class=\"sep\"></span><code class=\"docstring\">Complex numbers consist of two `Real`s: a real part `re` and an imaginary part `im`. </code>",
 "236":
 "<code>ContDiff.{u, uE, uF} (ùïú : Type u) [NontriviallyNormedField ùïú] {E : Type uE} [NormedAddCommGroup E] [NormedSpace ùïú E]\n  {F : Type uF} [NormedAddCommGroup F] [NormedSpace ùïú F] (n : WithTop ‚Ñï‚àû) (f : E ‚Üí F) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function is continuously differentiable up to `n` if it admits derivatives up to\norder `n`, which are continuous. Contrary to the case of definitions in domains (where derivatives\nmight not be unique) we do not need to localize the definition in space or time.\n</code>",
 "235":
 "<code>expNegInvGlue (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">`expNegInvGlue` is the real function given by `x ‚Ü¶ exp (-1/x)` for `x &gt; 0` and `0`\nfor `x ‚â§ 0`. It is a basic building block to construct smooth partitions of unity. Its main property\nis that it vanishes for `x ‚â§ 0`, it is positive for `x &gt; 0`, and the junction between the two\nbehaviors is flat enough to retain smoothness. The fact that this function is `C^‚àû` is proved in\n`expNegInvGlue.contDiff`. </code>",
 "234":
 "<code>False : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`False` is the empty proposition. Thus, it has no introduction rules.\nIt represents a contradiction. `False` elimination rule, `False.rec`,\nexpresses the fact that anything follows from a contradiction.\nThis rule is sometimes called ex falso (short for ex falso sequitur quodlibet),\nor the principle of explosion.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "233":
 "<code>Real.not_summable_one_div_natCast : ¬¨Summable fun n =&gt; 1 / ‚Üën</code><span class=\"sep\"></span><code class=\"docstring\">Harmonic series is not unconditionally summable. </code>",
 "232": "<code>?m.2 ‚Üí ?m.1</code>",
 "231":
 "<code>Real.log (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The real logarithm function, equal to the inverse of the exponential for `x &gt; 0`,\nto `log |x|` for `x &lt; 0`, and to `0` for `0`. We use this unconventional extension to\n`(-‚àû, 0]` as it gives the formula `log (x * y) = log x + log y` for all nonzero `x` and `y`, and\nthe derivative of `log` is `1/x` away from `0`. </code>",
 "230":
 "<code>realEulerNumber : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.5.2 (Euler's number): Euler's number `e` is the real number\ndefined by `e := exp(1)`, with series expansion `e = ‚àë' n : ‚Ñï, 1 / n!`. </code>",
 "23":
 "<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>",
 "229":
 "<code>Real.exp (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The real exponential function, defined as the real part of the complex exponential </code>",
 "228":
 "<code>naturalLog : ‚Üë(Set.Ioi 0) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.5.3 (Natural logarithm): the natural logarithm is the function\n`log : (0, ‚àû) ‚Üí ‚Ñù`, also denoted `ln`, defined as the inverse of `exp : ‚Ñù ‚Üí (0, ‚àû)`. </code>",
 "227":
 "<code>cauchyProductCoeff (c d : ‚Ñï ‚Üí ‚Ñù) (n : ‚Ñï) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The Cauchy-product coefficient sequence attached to `c, d : ‚Ñï ‚Üí ‚Ñù`. </code>",
 "226": "<code>?m.14</code>",
 "225":
 "<code>Summable.{u_1, u_2} {Œ± : Type u_1} {Œ≤ : Type u_2} [AddCommMonoid Œ±] [TopologicalSpace Œ±] (f : Œ≤ ‚Üí Œ±)\n  (L : SummationFilter Œ≤ := SummationFilter.unconditional Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Summable f` means that `f` has some (infinite) sum with respect to `L`. Use `tsum` to get the\nvalue. </code>",
 "224": "<code>?m.30</code>",
 "223":
 "<code>iteratedDeriv.{u_1, u_2} {ùïú : Type u_1} [NontriviallyNormedField ùïú] {F : Type u_2} [NormedAddCommGroup F]\n  [NormedSpace ùïú F] (n : ‚Ñï) (f : ùïú ‚Üí F) (x : ùïú) : F</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th iterated derivative of a function from `ùïú` to `F`, as a function from `ùïú` to `F`. </code>",
 "222":
 "<code class=\"docstring\">The `exact e` and `refine e` tactics require a term `e` whose type is\ndefinitionally equal to the goal. `convert e` is similar to `refine e`,\nbut the type of `e` is not required to exactly match the\ngoal. Instead, new goals are created for differences between the type\nof `e` and the goal using the same strategies as the `congr!` tactic.\nFor example, in the proof state\n\n```lean\nn : ‚Ñï,\ne : Prime (2 * n + 1)\n‚ä¢ Prime (n + n + 1)\n```\n\nthe tactic `convert e using 2` will change the goal to\n\n```lean\n‚ä¢ n + n = 2 * n\n```\n\nIn this example, the new goal can be solved using `ring`.\n\nThe `using 2` indicates it should iterate the congruence algorithm up to two times,\nwhere `convert e` would use an unrestricted number of iterations and lead to two\nimpossible goals: `‚ä¢ HAdd.hAdd = HMul.hMul` and `‚ä¢ n = 2`.\n\nA variant configuration is `convert (config := .unfoldSameFun) e`, which only equates function\napplications for the same function (while doing so at the higher `default` transparency).\nThis gives the same goal of `‚ä¢ n + n = 2 * n` without needing `using 2`.\n\nThe `convert` tactic applies congruence lemmas eagerly before reducing,\ntherefore it can fail in cases where `exact` succeeds:\n```lean\ndef p (n : ‚Ñï) := True\nexample (h : p 0) : p 1 := by exact h -- succeeds\nexample (h : p 0) : p 1 := by convert h -- fails, with leftover goal `1 = 0`\n```\nLimiting the depth of recursion can help with this. For example, `convert h using 1` will work\nin this case.\n\nThe syntax `convert ‚Üê e` will reverse the direction of the new goals\n(producing `‚ä¢ 2 * n = n + n` in this example).\n\nInternally, `convert e` works by creating a new goal asserting that\nthe goal equals the type of `e`, then simplifying it using\n`congr!`. The syntax `convert e using n` can be used to control the\ndepth of matching (like `congr! n`). In the example, `convert e using 1`\nwould produce a new goal `‚ä¢ n + n + 1 = 2 * n + 1`.\n\nRefer to the `congr!` tactic to understand the congruence operations. One of its many\nfeatures is that if `x y : t` and an instance `Subsingleton t` is in scope,\nthen any goals of the form `x = y` are solved automatically.\n\nLike `congr!`, `convert` takes an optional `with` clause of `rintro` patterns,\nfor example `convert e using n with x y z`.\n\nThe `convert` tactic also takes a configuration option, for example\n```lean\nconvert (config := {transparency := .default}) h\n```\nThese are passed to `congr!`. See `Congr!.Config` for options.\n</code>",
 "221":
 "<code>AnalyticOn.{u_1, u_2, u_3} (ùïú : Type u_1) {E : Type u_2} {F : Type u_3} [NontriviallyNormedField ùïú]\n  [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F] (f : E ‚Üí F) (s : Set E) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`f` is analytic within `s` if it is analytic within `s` at each point of `s`.  Note that\nthis is weaker than `AnalyticOnNhd ùïú f s`, as `f` is allowed to be arbitrary outside `s`. </code>",
 "220":
 "<code>IsRealAnalyticOn (E : Set ‚Ñù) (f : ‚ÜëE ‚Üí ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function on `E` is real analytic on `E` when `E` is open and the function is real analytic at each point of `E`. </code>",
 "22": "<code>?m.68</code>",
 "219":
 "<code>HasFPowerSeriesWithinOnBall.{u_1, u_2, u_3} {ùïú : Type u_1} {E : Type u_2} {F : Type u_3} [NontriviallyNormedField ùïú]\n  [NormedAddCommGroup E] [NormedSpace ùïú E] [NormedAddCommGroup F] [NormedSpace ùïú F] (f : E ‚Üí F)\n  (p : FormalMultilinearSeries ùïú E F) (s : Set E) (x : E) (r : ENNReal) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Analogue of `HasFPowerSeriesOnBall` where convergence is required only on a set `s`. We also\nrequire convergence at `x` as the behavior of this notion is very bad otherwise. </code>",
 "218": "<code>ENNReal</code>",
 "217": "<code>E</code>",
 "216": "<code>Set E</code>",
 "215": "<code>FormalMultilinearSeries ùïú E F</code>",
 "214": "<code>E ‚Üí F</code>",
 "213":
 "<code>iteratedDerivWithin.{u_1, u_2} {ùïú : Type u_1} [NontriviallyNormedField ùïú] {F : Type u_2} [NormedAddCommGroup F]\n  [NormedSpace ùïú F] (n : ‚Ñï) (f : ùïú ‚Üí F) (s : Set ùïú) (x : ùïú) : F</code><span class=\"sep\"></span><code class=\"docstring\">The `n`-th iterated derivative of a function from `ùïú` to `F` within a set `s`, as a function\nfrom `ùïú` to `F`. </code>",
 "212": "<code>ùïú</code>",
 "211": "<code>Set ùïú</code>",
 "210": "<code>ùïú ‚Üí F</code>",
 "21": "<code>?m.40</code>",
 "209":
 "<code>IteratedDerivativeSub (E : Set ‚Ñù) (f : ‚ÜëE ‚Üí ‚Ñù) : ‚Ñï ‚Üí ‚ÜëE ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Iterated derivatives on `E`: `f^(0)=f` and `f^(n+1)` is the first derivative of `f^(n)`. </code>",
 "208": "<code>‚ÜëE ‚Üí ‚Ñù</code>",
 "207": "<code>Set ‚Ñù</code>",
 "206":
 "<code>deriv.{u, v} {ùïú : Type u} [NontriviallyNormedField ùïú] {F : Type v} [AddCommGroup F] [Module ùïú F] [TopologicalSpace F]\n  (f : ùïú ‚Üí F) (x : ùïú) : F</code><span class=\"sep\"></span><code class=\"docstring\">Derivative of `f` at the point `x`, if it exists.  Zero otherwise.\n\nIf the derivative exists (i.e., `‚àÉ f', HasDerivAt f f' x`), then\n`f x' = f x + (x' - x) ‚Ä¢ deriv f x + o(x' - x)` where `x'` converges to `x`.\n</code>",
 "205":
 "<code>absCube : ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The function `x ‚Ü¶ |x|^3` on `‚Ñù`. </code>",
 "204":
 "<code>HasNoIsolatedPoints (E : Set ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A set of real numbers has no isolated points if every `x ‚àà E` is a limit point of `E`. </code>",
 "203":
 "<code class=\"docstring\">The tactic `continuity` solves goals of the form `Continuous f` by applying lemmas tagged with the\n`continuity` user attribute.\n\n`fun_prop` is a (usually more powerful) alternative to `continuity`. </code>",
 "202":
 "<code>Set.uIcc.{u_1} {Œ± : Type u_1} [Lattice Œ±] (a b : Œ±) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`uIcc a b` is the set of elements lying between `a` and `b`, with `a` and `b` included.\nNote that we define it more generally in a lattice as `Set.Icc (a ‚äì b) (a ‚äî b)`. In a product type,\n`uIcc` corresponds to the bounding box of the two elements. </code>",
 "201": "<code>?m.12</code>",
 "200":
 "<code>NNReal : Type</code><span class=\"sep\"></span><code class=\"docstring\">Nonnegative real numbers, denoted as `‚Ñù‚â•0` within the NNReal namespace </code>",
 "20": "<code>?m.4</code>",
 "2":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "199":
 "<code>reciprocalOneSub_ext : ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The total real extension of `x ‚Ü¶ 1 / (1 - x)`. </code>",
 "198":
 "<code class=\"docstring\">Apply congruence (recursively) to goals of the form `‚ä¢ f as = f bs` and `‚ä¢ f as ‚âç f bs`.\n* `congr n` controls the depth of the recursive applications.\n  This is useful when `congr` is too aggressive in breaking down the goal.\n  For example, given `‚ä¢ f (g (x + y)) = f (g (y + x))`,\n  `congr` produces the goals `‚ä¢ x = y` and `‚ä¢ y = x`,\n  while `congr 2` produces the intended `‚ä¢ x + y = y + x`.\n* If, at any point, a subgoal matches a hypothesis then the subgoal will be closed.\n* You can use `congr with p (: n)?` to call `ext p (: n)?` to all subgoals generated by `congr`.\n  For example, if the goal is `‚ä¢ f '' s = g '' s` then `congr with x` generates the goal\n  `x : Œ± ‚ä¢ f x = g x`.\n</code>",
 "197":
 "<code>reciprocalOneSub (x : { x // x ‚â† 1 }) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 4.1.3: Define the function `f : ‚Ñù \\ {1} ‚Üí ‚Ñù` by `f(x) = 1 / (1 - x)`. </code>",
 "196": "<code>{ x // x ‚â† 1 }</code>",
 "195":
 "<code>Set.IccExtend.{u_1, u_2} {Œ± : Type u_1} {Œ≤ : Type u_2} [LinearOrder Œ±] {a b : Œ±} (h : a ‚â§ b) (f : ‚Üë(Set.Icc a b) ‚Üí Œ≤) :\n  Œ± ‚Üí Œ≤</code><span class=\"sep\"></span><code class=\"docstring\">Extend a function `[a, b] ‚Üí Œ≤` to a map `Œ± ‚Üí Œ≤`. </code>",
 "194": "<code>‚Üë(Set.Icc a b) ‚Üí Œ≤</code>",
 "193": "<code>a ‚â§ b</code>",
 "192":
 "<code>ConvolutionDefined (f g : ‚Ñù ‚Üí ‚Ñù) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">The convolution of `f` and `g` is absolutely convergent at every point. </code>",
 "191":
 "<code>diracDelta : ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">A formal Dirac delta distribution, treated as a function for convolution statements. </code>",
 "190":
 "<code>HasCompactSupport.{u_2, u_4} {Œ± : Type u_2} {Œ≤ : Type u_4} [TopologicalSpace Œ±] [Zero Œ≤] (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f` *has compact support* or is *compactly supported* if the closure of\nthe support of `f` is compact. In a T‚ÇÇ space this is equivalent to `f` being equal to `0` outside a\ncompact set. </code>",
 "19":
 "<code class=\"docstring\">A type universe. `Type ‚â° Type 0`, `Type u ‚â° Sort (u + 1)`. </code>",
 "189":
 "<code>realConvolutionFun (f g : ‚Ñù ‚Üí ‚Ñù) : ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Convolution of two real functions, defined by `(f*g)(x) = ‚à´ t, f (x - t) * g t`. </code>",
 "188": "<code>‚Ñù ‚Üí ‚Ñù</code>",
 "187": "<code>?m.18</code>",
 "186": "<code>?m.6</code>",
 "185":
 "<code class=\"docstring\">`ac_rfl` proves equalities up to application of an associative and commutative operator.\n```\ninstance : Std.Associative (Œ± := Nat) (.+.) := ‚ü®Nat.add_assoc‚ü©\ninstance : Std.Commutative (Œ± := Nat) (.+.) := ‚ü®Nat.add_comm‚ü©\n\nexample (a b c d : Nat) : a + b + c + d = d + (b + c) + a := by ac_rfl\n```\n</code>",
 "184":
 "<code>Set.Ioc.{u_1} {Œ± : Type u_1} [Preorder Œ±] (a b : Œ±) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`Ioc a b` is the left-open right-closed interval $(a, b]$. </code>",
 "183":
 "<code>WithTop.{u_2} (Œ± : Type u_2) : Type u_2</code><span class=\"sep\"></span><code class=\"docstring\">Attach `‚ä§` to a type. </code>",
 "182":
 "<code>BoundedContinuousFunction.{u, v} (Œ± : Type u) (Œ≤ : Type v) [TopologicalSpace Œ±] [PseudoMetricSpace Œ≤] : Type (max u v)</code><span class=\"sep\"></span><code class=\"docstring\">`Œ± ‚Üí·µá Œ≤` is the type of bounded continuous functions `Œ± ‚Üí Œ≤` from a topological space to a\nmetric space.\n\nWhen possible, instead of parametrizing results over `(f : Œ± ‚Üí·µá Œ≤)`,\nyou should parametrize over `(F : Type*) [BoundedContinuousMapClass F Œ± Œ≤] (f : F)`.\n\nWhen you extend this structure, make sure to extend `BoundedContinuousMapClass`. </code>",
 "181":
 "<code class=\"docstring\">`C(X, Y)` is the type of continuous maps from `X` to `Y`. </code>",
 "180":
 "<code>polynomialFunctionsOnIcc (a b : ‚Ñù) : Set (BoundedContinuousFunction ‚Üë(Set.Icc a b) ‚Ñù)</code><span class=\"sep\"></span><code class=\"docstring\">The set of bounded continuous functions on `[a,b]` that are polynomial on `[a,b]`. </code>",
 "18":
 "<code>Real : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type `‚Ñù` of real numbers constructed as equivalence classes of Cauchy sequences of rational\nnumbers. </code>",
 "179":
 "<code class=\"docstring\">`compute_degree` is a tactic to solve goals of the form\n*  `natDegree f = d`,\n*  `degree f = d`,\n*  `natDegree f ‚â§ d` (or `&lt;`),\n*  `degree f ‚â§ d` (or `&lt;`),\n*  `coeff f d = r`, if `d` is the degree of `f`.\n\nThe tactic may leave goals of the form `d' = d`, `d' ‚â§ d`, `d' &lt; d`, or `r ‚â† 0`, where `d'` in `‚Ñï`\nor `WithBot ‚Ñï` is the tactic's guess of the degree, and `r` is the coefficient's guess of the\nleading coefficient of `f`.\n\n`compute_degree` applies `norm_num` to the left-hand side of all side goals, trying to close them.\n\nThe variant `compute_degree!` first applies `compute_degree`.\nThen it uses `norm_num` on all the remaining goals and tries `assumption`.\n</code>",
 "178":
 "<code class=\"docstring\">Apply congruence (recursively) to goals of the form `‚ä¢ f as = f bs` and `‚ä¢ f as ‚âç f bs`.\nThe optional parameter is the depth of the recursive applications.\nThis is useful when `congr` is too aggressive in breaking down the goal.\nFor example, given `‚ä¢ f (g (x + y)) = f (g (y + x))`,\n`congr` produces the goals `‚ä¢ x = y` and `‚ä¢ y = x`,\nwhile `congr 2` produces the intended `‚ä¢ x + y = y + x`.\n</code>",
 "177":
 "<code class=\"docstring\">The `omega` tactic, for resolving integer and natural linear arithmetic problems.\n\nIt is not yet a full decision procedure (no \"dark\" or \"grey\" shadows),\nbut should be effective on many problems.\n\nWe handle hypotheses of the form `x = y`, `x &lt; y`, `x ‚â§ y`, and `k ‚à£ x` for `x y` in `Nat` or `Int`\n(and `k` a literal), along with negations of these statements.\n\nWe decompose the sides of the inequalities as linear combinations of atoms.\n\nIf we encounter `x / k` or `x % k` for literal integers `k` we introduce new auxiliary variables\nand the relevant inequalities.\n\nOn the first pass, we do not perform case splits on natural subtraction.\nIf `omega` fails, we recursively perform a case split on\na natural subtraction appearing in a hypothesis, and try again.\n\nThe options\n```\nomega +splitDisjunctions +splitNatSub +splitNatAbs +splitMinMax\n```\ncan be used to:\n* `splitDisjunctions`: split any disjunctions found in the context,\n  if the problem is not otherwise solvable.\n* `splitNatSub`: for each appearance of `((a - b : Nat) : Int)`, split on `a ‚â§ b` if necessary.\n* `splitNatAbs`: for each appearance of `Int.natAbs a`, split on `0 ‚â§ a` if necessary.\n* `splitMinMax`: for each occurrence of `min a b`, split on `min a b = a ‚à® min a b = b`\nCurrently, all of these are on by default.\n</code>",
 "176":
 "<code class=\"docstring\">Tactic solving goals of the form `0 ‚â§ x`, `0 &lt; x` and `x ‚â† 0`.  The tactic works recursively\naccording to the syntax of the expression `x`, if the atoms composing the expression all have\nnumeric lower bounds which can be proved positive/nonnegative/nonzero by `norm_num`.  This tactic\neither closes the goal or fails.\n\n`positivity [t‚ÇÅ, ‚Ä¶, t‚Çô]` first executes `have := t‚ÇÅ; ‚Ä¶; have := t‚Çô` in the current goal,\nthen runs `positivity`. This is useful when `positivity` needs derived premises such as `0 &lt; y`\nfor division/reciprocal, or `0 ‚â§ x` for real powers.\n\nExamples:\n```\nexample {a : ‚Ñ§} (ha : 3 &lt; a) : 0 ‚â§ a ^ 3 + a := by positivity\n\nexample {a : ‚Ñ§} (ha : 1 &lt; a) : 0 &lt; |(3:‚Ñ§) + a| := by positivity\n\nexample {b : ‚Ñ§} : 0 ‚â§ max (-3) (b ^ 2) := by positivity\n\nexample {a b c d : ‚Ñù} (hab : 0 &lt; a * b) (hb : 0 ‚â§ b) (hcd : c &lt; d) :\n    0 &lt; a ^ c + 1 / (d - c) := by\n  positivity [sub_pos_of_lt hcd, pos_of_mul_pos_left hab hb]\n```\n</code>",
 "175":
 "<code class=\"docstring\">Assuming `x` is a variable in the local context with an inductive type,\n`induction x` applies induction on `x` to the main goal,\nproducing one goal for each constructor of the inductive type,\nin which the target is replaced by a general instance of that constructor\nand an inductive hypothesis is added for each recursive argument to the constructor.\nIf the type of an element in the local context depends on `x`,\nthat element is reverted and reintroduced afterward,\nso that the inductive hypothesis incorporates that hypothesis as well.\n\nFor example, given `n : Nat` and a goal with a hypothesis `h : P n` and target `Q n`,\n`induction n` produces one goal with hypothesis `h : P 0` and target `Q 0`,\nand one goal with hypotheses `h : P (Nat.succ a)` and `ih‚ÇÅ : P a ‚Üí Q a` and target `Q (Nat.succ a)`.\nHere the names `a` and `ih‚ÇÅ` are chosen automatically and are not accessible.\nYou can use `with` to provide the variables names for each constructor.\n- `induction e`, where `e` is an expression instead of a variable,\n  generalizes `e` in the goal, and then performs induction on the resulting variable.\n- `induction e using r` allows the user to specify the principle of induction that should be used.\n  Here `r` should be a term whose result type must be of the form `C t`,\n  where `C` is a bound variable and `t` is a (possibly empty) sequence of bound variables\n- `induction e generalizing z‚ÇÅ ... z‚Çô`, where `z‚ÇÅ ... z‚Çô` are variables in the local context,\n  generalizes over `z‚ÇÅ ... z‚Çô` before applying the induction but then introduces them in each goal.\n  In other words, the net effect is that each inductive hypothesis is generalized.\n- Given `x : Nat`, `induction x with | zero =&gt; tac‚ÇÅ | succ x' ih =&gt; tac‚ÇÇ`\n  uses tactic `tac‚ÇÅ` for the `zero` case, and `tac‚ÇÇ` for the `succ` case.\n</code>",
 "174":
 "<code class=\"docstring\">`filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô]` replaces a goal of the form `s ‚àà f` and terms\n`h‚ÇÅ : t‚ÇÅ ‚àà f, ‚ãØ, h‚Çô : t‚Çô ‚àà f` with `‚àÄ x, x ‚àà t‚ÇÅ ‚Üí ‚ãØ ‚Üí x ‚àà t‚Çô ‚Üí x ‚àà s`.\nThe list is an optional parameter, `[]` being its default value.\n\n`filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] with a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ` is a short form for\n`{ filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô], intro a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ }`.\n\n`filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] using e` is a short form for\n`{ filter_upwards [h1, ‚ãØ, hn], exact e }`.\n\nCombining both shortcuts is done by writing `filter_upwards [h‚ÇÅ, ‚ãØ, h‚Çô] with a‚ÇÅ a‚ÇÇ ‚ãØ a‚Çñ using e`.\nNote that in this case, the `a·µ¢` terms can be used in `e`.\n</code>",
 "173":
 "<code>sqrtShiftedSeq (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The sequence of functions `f_n(x) = sqrt(1/n^2 + x^2)` on `‚Ñù`. </code>",
 "172":
 "<code>absFun : ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The absolute value function on `‚Ñù`. </code>",
 "171":
 "<code>lim.{u_1} {X : Type u_1} [TopologicalSpace X] [Nonempty X] (f : Filter X) : X</code><span class=\"sep\"></span><code class=\"docstring\">If `f` is a filter, then `Filter.lim f` is a limit of the filter, if it exists. </code>",
 "170":
 "<code class=\"docstring\">`nth_rewrite` is a variant of `rewrite` that only changes the `n‚ÇÅ, ..., n‚Çñ`·µó ∞ _occurrence_ of\nthe expression to be rewritten. `nth_rewrite n‚ÇÅ ... n‚Çñ [eq‚ÇÅ, eq‚ÇÇ,..., eq‚Çò]` will rewrite the\n`n‚ÇÅ, ..., n‚Çñ`·µó ∞ _occurrence_ of each of the `m` equalities `eq·µ¢`in that order. Occurrences are\ncounted beginning with `1` in order of precedence.\n\nFor example,\n```lean\nexample (h : a = 1) : a + a + a + a + a = 5 := by\n  nth_rewrite 2 3 [h]\n/-\na: ‚Ñï\nh: a = 1\n‚ä¢ a + 1 + 1 + a + a = 5\n-/\n```\nNotice that the second and third occurrences of `a` from the left have been rewritten by\n`nth_rewrite`.\n\nTo understand the importance of order of precedence, consider the example below\n```lean\nexample (a b c : Nat) : (a + b) + c = (b + a) + c := by\n  nth_rewrite 2 [Nat.add_comm] -- ‚ä¢ (b + a) + c = (b + a) + c\n```\nHere, although the occurrence parameter is `2`, `(a + b)` is rewritten to `(b + a)`. This happens\nbecause in order of precedence, the first occurrence of `_ + _` is the one that adds `a + b` to `c`.\nThe occurrence in `a + b` counts as the second occurrence.\n\nIf a term `t` is introduced by rewriting with `eq·µ¢`, then this instance of `t` will be counted as an\n_occurrence_ of `t` for all subsequent rewrites of `t` with `eq‚±º` for `j &gt; i`. This behaviour is\nillustrated by the example below\n```lean\nexample (h : a = a + b) : a + a + a + a + a = 0 := by\n  nth_rewrite 3 [h, h]\n/-\na b: ‚Ñï\nh: a = a + b\n‚ä¢ a + a + (a + b + b) + a + a = 0\n-/\n```\nHere, the first `nth_rewrite` with `h` introduces an additional occurrence of `a` in the goal.\nThat is, the goal state after the first rewrite looks like below\n```lean\n/-\na b: ‚Ñï\nh: a = a + b\n‚ä¢ a + a + (a + b) + a + a = 0\n-/\n```\nThis new instance of `a` also turns out to be the third _occurrence_ of `a`.  Therefore,\nthe next `nth_rewrite` with `h` rewrites this `a`.\n</code>",
 "17":
 "<code class=\"docstring\">Normalize numerical expressions. Supports the operations `+` `-` `*` `/` `‚Åª¬π` `^` and `%`\nover numerical types such as `‚Ñï`, `‚Ñ§`, `‚Ñö`, `‚Ñù`, `‚ÑÇ` and some general algebraic types,\nand can prove goals of the form `A = B`, `A ‚â† B`, `A &lt; B` and `A ‚â§ B`, where `A` and `B` are\nnumerical expressions. It also has a relatively simple primality prover.\n</code>",
 "169":
 "<code>HasSum.{u_1, u_2} {Œ± : Type u_1} {Œ≤ : Type u_2} [AddCommMonoid Œ±] [TopologicalSpace Œ±] (f : Œ≤ ‚Üí Œ±) (a : Œ±)\n  (L : SummationFilter Œ≤ := SummationFilter.unconditional Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`HasSum f a L` means that the (potentially infinite) sum of the `f b` for `b : Œ≤`\nconverges to `a` along the SummationFilter `L`.\n\nBy default `L` is the `unconditional` one, corresponding to the limit of all finite sets towards\nthe entire type. So we take the sum over bigger and bigger finite sets. This sum operation is\ninvariant under permuting the terms (while sums for more general summation filters usually are not).\nThis is based on Mario Carneiro's\n[infinite sum `df-tsms` in Metamath](http://us.metamath.org/mpeuni/df-tsms.html).\n\nIn particular, the function `‚Ñï ‚Üí ‚Ñù` sending `n` to `(-1) ^ n / (n + 1)` does not have a\nsum for this definition, although it is summable for the `conditional` summation filter that\ntakes limits of sums over `n ‚àà {0, ..., X}` as `X ‚Üí ‚àû`. However, a series which is *absolutely*\nconvergent with respect to the conditional summation filter is in fact unconditionally summable.\n\nFor the definition and many statements, `Œ±` does not need to be a topological additive monoid,\nonly an additive monoid with a topology (i.e. the addition is not assumed to be continuous). We\nonly add this assumption later, for the lemmas where it is relevant. </code>",
 "168":
 "<code>Set.uIoc.{u_1} {Œ± : Type u_1} [LinearOrder Œ±] : Œ± ‚Üí Œ± ‚Üí Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">The open-closed uIcc with unordered bounds. </code>",
 "167": "<code>Œ±</code>",
 "166":
 "<code>supNorm.{u_1} {X : Type u_1} (f : { f // IsBoundedRealFunction f }) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Definition 3.10: [Sup norm] Let `X` be a set and let `f : X ‚Üí ‚Ñù` be bounded.\nThe sup norm (uniform norm) is `‚Äñf‚Äñ‚àû = sup { |f(x)| : x ‚àà X }`, and if `X = ‚àÖ`\nthen `‚Äñf‚Äñ‚àû = 0`. </code>",
 "165": "<code>X ‚Üí ‚Ñù</code>",
 "164": "<code>{ f // IsBoundedRealFunction f }</code>",
 "163":
 "<code>tsum.{u_4, u_5} {Œ± : Type u_4} {Œ≤ : Type u_5} [AddCommMonoid Œ±] [TopologicalSpace Œ±] (f : Œ≤ ‚Üí Œ±)\n  (L : SummationFilter Œ≤ := SummationFilter.unconditional Œ≤) : Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`‚àë' i, f i` is the unconditional sum of `f` if it exists, or 0 otherwise.\n\nMore generally, if `L` is a `SummationFilter`, `‚àë'[L] i, f i` is the sum of `f` with respect to\n`L` if it exists, and `0` otherwise.\n\n(Note that even if the unconditional sum exists, it might not be unique if the topology is not\nseparated. When the support of `f` is finite, we make the most reasonable choice, to use the sum\nover the support. Otherwise, we choose arbitrarily an `a` satisfying `HasSum f a`. Similar remarks\napply to more general summation filters.)\n</code>",
 "162":
 "<code>optParam (SummationFilter Œ≤) (SummationFilter.unconditional Œ≤)</code>",
 "161":
 "<code>Finset.range (n : ‚Ñï) : Finset ‚Ñï</code><span class=\"sep\"></span><code class=\"docstring\">`range n` is the set of natural numbers less than `n`. </code>",
 "160":
 "<code>seriesPartialSum.{u_1} {X : Type u_1} (f : ‚Ñï ‚Üí X ‚Üí ‚Ñù) (N : ‚Ñï) : X ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Partial sum function `S_N(x) = ‚àë_{n=1}^N f^{(n)}(x)`. </code>",
 "16":
 "<code class=\"docstring\">`classical tacs` runs `tacs` in a scope where `Classical.propDecidable` is a low priority\nlocal instance.\n\nNote that `classical` is a scoping tactic: it adds the instance only within the\nscope of the tactic.\n</code>",
 "159": "<code>‚Ñï ‚Üí X ‚Üí ‚Ñù</code>",
 "158":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "157":
 "<code class=\"docstring\">In Lean, every concrete type other than the universes\nand every type constructor other than dependent arrows\nis an instance of a general family of type constructions known as inductive types.\nIt is remarkable that it is possible to construct a substantial edifice of mathematics\nbased on nothing more than the type universes, dependent arrow types, and inductive types;\neverything else follows from those.\nIntuitively, an inductive type is built up from a specified list of constructors.\nFor example, `List Œ±` is the list of elements of type `Œ±`, and is defined as follows:\n```\ninductive List (Œ± : Type u) where\n| nil\n| cons (head : Œ±) (tail : List Œ±)\n```\nA list of elements of type `Œ±` is either the empty list, `nil`,\nor an element `head : Œ±` followed by a list `tail : List Œ±`.\nSee [Inductive types](https://lean-lang.org/theorem_proving_in_lean4/inductive_types.html)\nfor more information.\n</code>",
 "156":
 "<code>example351_fi : Fin 3 ‚Üí ‚Ñù ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The family of three functions `x`, `x^2`, and `x^3` indexed by `Fin 3`. </code>",
 "155":
 "<code class=\"docstring\">`f.Frequently p` or `‚àÉ·∂† x in f, p x` mean that `{x | ¬¨p x} ‚àâ f`. E.g., `‚àÉ·∂† x in atTop, p x`\nmeans that there exist arbitrarily large `x` for which `p` holds true. </code>",
 "154":
 "<code>Set.Icc.{u_1} {Œ± : Type u_1} [Preorder Œ±] (a b : Œ±) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`Icc a b` is the left-closed right-closed interval $[a, b]$. </code>",
 "153":
 "<code>movingBump (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">A moving bump function on `‚Ñù` given by the indicator of `[n, n+1]`. </code>",
 "152":
 "<code class=\"docstring\">Simplification tactic for expressions in the language of commutative (semi)rings,\nwhich rewrites all ring expressions into a normal form.\n* `ring_nf!` will use a more aggressive reducibility setting to identify atoms.\n* `ring_nf (config := cfg)` allows for additional configuration:\n  * `red`: the reducibility setting (overridden by `!`)\n  * `zetaDelta`: if true, local let variables can be unfolded (overridden by `!`)\n  * `recursive`: if true, `ring_nf` will also recurse into atoms\n* `ring_nf` works as both a tactic and a conv tactic.\n  In tactic mode, `ring_nf at h` can be used to rewrite in a hypothesis.\n\nThis can be used non-terminally to normalize ring expressions in the goal such as\n`‚ä¢ P (x + x + x)` ~&gt; `‚ä¢ P (x * 3)`, as well as being able to prove some equations that\n`ring` cannot because they involve ring reasoning inside a subterm, such as\n`sin (x + y) + sin (y + x) = 2 * sin (x + y)`.\n</code>",
 "151":
 "<code class=\"docstring\">The goal of `field_simp` is to bring expressions in (semi-)fields over a common denominator, i.e. to\nreduce them to expressions of the form `n / d` where neither `n` nor `d` contains any division\nsymbol. For example, `x / (1 - y) / (1 + y / (1 - y))` is reduced to `x / (1 - y + y)`:\n```\nexample (x y z : ‚Ñö) (hy : 1 - y ‚â† 0) :\n    ‚åäx / (1 - y) / (1 + y / (1 - y))‚åã &lt; 3 := by\n  field_simp\n  -- new goal: `‚ä¢ ‚åäx / (1 - y + y)‚åã &lt; 3`\n```\n\nThe `field_simp` tactic will also clear denominators in field *(in)equalities*, by\ncross-multiplying. For example, `field_simp` will clear the `x` denominators in the following\nequation:\n```\nexample {K : Type*} [Field K] {x : K} (hx0 : x ‚â† 0) :\n    (x + 1 / x) ^ 2 + (x + 1 / x) = 1 := by\n  field_simp\n  -- new goal: `‚ä¢ (x ^ 2 + 1) * (x ^ 2 + 1 + x) = x ^ 2`\n```\n\nA very common pattern is `field_simp; ring` (clear denominators, then the resulting goal is\nsolvable by the axioms of a commutative ring). The finishing tactic `field` is a shorthand for this\npattern.\n\nCancelling and combining denominators will generally require checking \"nonzeroness\"/\"positivity\"\nside conditions. The `field_simp` tactic attempts to discharge these, and will omit such steps if it\ncannot discharge the corresponding side conditions. The discharger will try, among other things,\n`positivity` and `norm_num`, and will also use any nonzeroness/positivity proofs included explicitly\n(e.g. `field_simp [hx]`). If your expression is not completely reduced by `field_simp`, check the\ndenominators of the resulting expression and provide proofs that they are nonzero/positive to enable\nfurther progress.\n</code>",
 "150": "<code class=\"docstring\">The Bochner integral </code>",
 "15": "<code>?m.50</code>",
 "149":
 "<code class=\"docstring\">The interval integral `‚à´ x in a..b, f x` is defined\nas `‚à´ x in Ioc a b, f x - ‚à´ x in Ioc b a, f x`. If `a ‚â§ b`, then it equals\n`‚à´ x in Ioc a b, f x`, otherwise it equals `-‚à´ x in Ioc b a, f x`. </code>",
 "148":
 "<code>spikeFunction (n : ‚Ñï) (x : ‚Ñù) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">A spike function on `[0,1]` used in a pointwise-convergence counterexample. </code>",
 "147": "<code>Sort u_2</code>",
 "146":
 "<code class=\"docstring\">* `choose a b h h' using hyp` takes a hypothesis `hyp` of the form\n  `‚àÄ (x : X) (y : Y), ‚àÉ (a : A) (b : B), P x y a b ‚àß Q x y a b`\n  for some `P Q : X ‚Üí Y ‚Üí A ‚Üí B ‚Üí Prop` and outputs\n  into context a function `a : X ‚Üí Y ‚Üí A`, `b : X ‚Üí Y ‚Üí B` and two assumptions:\n  `h : ‚àÄ (x : X) (y : Y), P x y (a x y) (b x y)` and\n  `h' : ‚àÄ (x : X) (y : Y), Q x y (a x y) (b x y)`. It also works with dependent versions.\n\n* `choose! a b h h' using hyp` does the same, except that it will remove dependency of\n  the functions on propositional arguments if possible. For example if `Y` is a proposition\n  and `A` and `B` are nonempty in the above example then we will instead get\n  `a : X ‚Üí A`, `b : X ‚Üí B`, and the assumptions\n  `h : ‚àÄ (x : X) (y : Y), P x y (a x) (b x)` and\n  `h' : ‚àÄ (x : X) (y : Y), Q x y (a x) (b x)`.\n\nThe `using hyp` part can be omitted,\nwhich will effectively cause `choose` to start with an `intro hyp`.\n\nExamples:\n\n```\nexample (h : ‚àÄ n m : ‚Ñï, ‚àÉ i j, m = n + i ‚à® m + j = n) : True := by\n  choose i j h using h\n  guard_hyp i : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï\n  guard_hyp j : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñï\n  guard_hyp h : ‚àÄ (n m : ‚Ñï), m = n + i n m ‚à® m + j n m = n\n  trivial\n```\n\n```\nexample (h : ‚àÄ i : ‚Ñï, i &lt; 7 ‚Üí ‚àÉ j, i &lt; j ‚àß j &lt; i+i) : True := by\n  choose! f h h' using h\n  guard_hyp f : ‚Ñï ‚Üí ‚Ñï\n  guard_hyp h : ‚àÄ (i : ‚Ñï), i &lt; 7 ‚Üí i &lt; f i\n  guard_hyp h' : ‚àÄ (i : ‚Ñï), i &lt; 7 ‚Üí f i &lt; i + i\n  trivial\n```\n</code>",
 "145":
 "<code class=\"docstring\">Push negations into the conclusion or a hypothesis.\nFor instance, a hypothesis `h : ¬¨ ‚àÄ x, ‚àÉ y, x ‚â§ y` will be transformed by `push_neg at h` into\n`h : ‚àÉ x, ‚àÄ y, y &lt; x`. Binder names are preserved.\n\n`push_neg` is a special case of the more general `push` tactic, namely `push Not`.\nThe `push` tactic can be extended using the `@[push]` attribute. `push` has special-casing\nbuilt in for `push Not`, so that it can preserve binder names, and so that `¬¨ (p ‚àß q)` can be\ntransformed to either `p ‚Üí ¬¨ q` (default) or `¬¨ p ‚à® ¬¨ q` (`push_neg +distrib`).\n\nTactics that introduce a negation usually have a version that automatically calls `push_neg` on\nthat negation. These include `by_cases!`, `contrapose!` and `by_contra!`.\n\nAnother example: given a hypothesis\n```lean\nh : ¬¨ ‚àÄ Œµ &gt; 0, ‚àÉ Œ¥ &gt; 0, ‚àÄ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚Üí |f x - y‚ÇÄ| ‚â§ Œµ\n```\nwriting `push_neg at h` will turn `h` into\n```lean\nh : ‚àÉ Œµ &gt; 0, ‚àÄ Œ¥ &gt; 0, ‚àÉ x, |x - x‚ÇÄ| ‚â§ Œ¥ ‚àß Œµ &lt; |f x - y‚ÇÄ|\n```\nNote that binder names are preserved by this tactic, contrary to what would happen with `simp`\nusing the relevant lemmas. One can use this tactic at the goal using `push_neg`,\nat every hypothesis and the goal using `push_neg at *` or at selected hypotheses and the goal\nusing say `push_neg at h h' ‚ä¢`, as usual.\n</code>",
 "144":
 "<code>FirstCountableTopology.{u} (Œ± : Type u) [t : TopologicalSpace Œ±] : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A first-countable space is one in which every point has a\ncountable neighborhood basis. </code>",
 "143": "<code>TopologicalSpace Œ±</code>",
 "142":
 "<code>EReal : Type</code><span class=\"sep\"></span><code class=\"docstring\">The type of extended real numbers `[-‚àû, ‚àû]`, constructed as `WithBot (WithTop ‚Ñù)`. </code>",
 "141":
 "<code>Metric.ball.{u} {Œ± : Type u} [PseudoMetricSpace Œ±] (x : Œ±) (Œµ : ‚Ñù) : Set Œ±</code><span class=\"sep\"></span><code class=\"docstring\">`ball x Œµ` is the set of all points `y` with `dist y x &lt; Œµ` </code>",
 "140":
 "<code>CofiniteTopology.{u_5} (X : Type u_5) : Type u_5</code><span class=\"sep\"></span><code class=\"docstring\">A type synonym equipped with the topology whose open sets are the empty set and the sets with\nfinite complements. </code>",
 "14": "<code>?m.22</code>",
 "139": "<code>Type u_5</code>",
 "138": "<code>sorry</code>",
 "137":
 "<code>Set.{u} (Œ± : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A set is a collection of elements of some type `Œ±`.\n\nAlthough `Set` is defined as `Œ± ‚Üí Prop`, this is an implementation detail which should not be\nrelied on. Instead, `setOf` and membership of a set (`‚àà`) should be used to convert between sets\nand predicates.\n</code>",
 "136": "<code class=\"docstring\">The universe level 1</code>",
 "135":
 "<code>TopologicalSpace.{u} (X : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">A topology on `X`. </code>",
 "134":
 "<code>ConnectedInSubset.{u_1} (X : Type u_1) [MetricSpace X] (x y : X) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Relation on a metric space given by membership in a common connected subset. </code>",
 "133":
 "<code>IsConnectedSubset.{u_1} (X : Type u_1) [MetricSpace X] (Y : Set X) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 2.8: [Connected sets] Let `(X, d)` be a metric space and let `Y ‚äÜ X`. Equip `Y`\nwith the subspace metric. The subset `Y` is called connected if `(Y, d_Y)` is connected; it is\ncalled disconnected if `(Y, d_Y)` is disconnected. </code>",
 "132":
 "<code class=\"docstring\">`tfae_finish` is used to close goals of the form `TFAE [P‚ÇÅ, P‚ÇÇ, ...]` once a sufficient collection\nof hypotheses of the form `P·µ¢ ‚Üí P‚±º` or `P·µ¢ ‚Üî P‚±º` have been introduced to the local context.\n\n`tfae_have` can be used to conveniently introduce these hypotheses; see `tfae_have`.\n\nExample:\n```lean4\nexample : TFAE [P, Q, R] := by\n  tfae_have 1 ‚Üí 2 := sorry /- proof of P ‚Üí Q -/\n  tfae_have 2 ‚Üí 1 := sorry /- proof of Q ‚Üí P -/\n  tfae_have 2 ‚Üî 3 := sorry /- proof of Q ‚Üî R -/\n  tfae_finish\n```\n</code>",
 "131":
 "<code class=\"docstring\">`tfae_have` introduces hypotheses for proving goals of the form `TFAE [P‚ÇÅ, P‚ÇÇ, ...]`. Specifically,\n`tfae_have i &lt;arrow&gt; j := ...` introduces a hypothesis of type `P·µ¢ &lt;arrow&gt; P‚±º` to the local\ncontext, where `&lt;arrow&gt;` can be `‚Üí`, `‚Üê`, or `‚Üî`. Note that `i` and `j` are natural number indices\n(beginning at 1) used to specify the propositions `P‚ÇÅ, P‚ÇÇ, ...` that appear in the goal.\n\n```lean4\nexample (h : P ‚Üí R) : TFAE [P, Q, R] := by\n  tfae_have 1 ‚Üí 3 := h\n  ...\n```\nThe resulting context now includes `tfae_1_to_3 : P ‚Üí R`.\n\nOnce sufficient hypotheses have been introduced by `tfae_have`, `tfae_finish` can be used to close\nthe goal. For example,\n\n```lean4\nexample : TFAE [P, Q, R] := by\n  tfae_have 1 ‚Üí 2 := sorry /- proof of P ‚Üí Q -/\n  tfae_have 2 ‚Üí 1 := sorry /- proof of Q ‚Üí P -/\n  tfae_have 2 ‚Üî 3 := sorry /- proof of Q ‚Üî R -/\n  tfae_finish\n```\n\nAll features of `have` are supported by `tfae_have`, including naming, matching,\ndestructuring, and goal creation. These are demonstrated below.\n\n```lean4\nexample : TFAE [P, Q] := by\n  -- assert `tfae_1_to_2 : P ‚Üí Q`:\n  tfae_have 1 ‚Üí 2 := sorry\n\n  -- assert `hpq : P ‚Üí Q`:\n  tfae_have hpq : 1 ‚Üí 2 := sorry\n\n  -- match on `p : P` and prove `Q` via `f p`:\n  tfae_have 1 ‚Üí 2\n  | p =&gt; f p\n\n  -- assert `pq : P ‚Üí Q`, `qp : Q ‚Üí P`:\n  tfae_have ‚ü®pq, qp‚ü© : 1 ‚Üî 2 := sorry\n\n  -- assert `h : P ‚Üí Q`; `?a` is a new goal:\n  tfae_have h : 1 ‚Üí 2 := f ?a\n  ...\n```\n</code>",
 "130":
 "<code>IsConnected.{u} {Œ± : Type u} [TopologicalSpace Œ±] (s : Set Œ±) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A connected set is one that is nonempty and where there is no non-trivial open partition. </code>",
 "13": "<code>?m.7</code>",
 "129":
 "<code>coordMul : EuclideanSpace ‚Ñù (Fin 2) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The map `m(x,y)=x*y` on `‚Ñù¬≤`, viewed as `EuclideanSpace ‚Ñù (Fin 2)`. </code>",
 "128":
 "<code>coordSub : EuclideanSpace ‚Ñù (Fin 2) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The map `s(x,y)=x-y` on `‚Ñù¬≤`, viewed as `EuclideanSpace ‚Ñù (Fin 2)`. </code>",
 "127":
 "<code>coordAdd : EuclideanSpace ‚Ñù (Fin 2) ‚Üí ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">The map `a(x,y)=x+y` on `‚Ñù¬≤`, viewed as `EuclideanSpace ‚Ñù (Fin 2)`. </code>",
 "126":
 "<code class=\"docstring\">`s(x, y)` is an unordered pair,\nwhich is to say a pair modulo the action of the symmetric group.\n\nIt is equal to `Sym2.mk (x, y)`. </code>",
 "125":
 "<code>Fin (n : ‚Ñï) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Natural numbers less than some upper bound.\n\nIn particular, a `Fin n` is a natural number `i` with the constraint that `i &lt; n`. It is the\ncanonical type with `n` elements.\n</code>",
 "124":
 "<code>EuclideanSpace.{u_7, u_8} (ùïú : Type u_7) (n : Type u_8) : Type (max u_7 u_8)</code><span class=\"sep\"></span><code class=\"docstring\">The standard real/complex Euclidean space, functions on a finite type. For an `n`-dimensional\nspace use `EuclideanSpace ùïú (Fin n)`.\n\nFor the case when `n = Fin _`, there is `!‚ÇÇ[x, y, ...]` notation for building elements of this type,\nanalogous to `![x, y, ...]` notation. </code>",
 "123":
 "<code class=\"docstring\">The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n</code>",
 "122":
 "<code>UniformContinuous.{ua, ub} {Œ± : Type ua} {Œ≤ : Type ub} [UniformSpace Œ±] [UniformSpace Œ≤] (f : Œ± ‚Üí Œ≤) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function `f : Œ± ‚Üí Œ≤` is *uniformly continuous* if `(f x, f y)` tends to the diagonal\nas `(x, y)` tends to the diagonal. In other words, if `x` is sufficiently close to `y`, then\n`f x` is close to `f y` no matter where `x` and `y` are located in `Œ±`. </code>",
 "121": "<code>Œ± ‚Üí Œ≤</code>",
 "120": "<code>Type ub</code>",
 "12": "<code>‚Ñï</code>",
 "119": "<code>Type ua</code>",
 "118":
 "<code>IsUniformlyContinuous.{u_1, u_2} {X : Type u_1} {Y : Type u_2} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">Definition 2.6: [Uniform continuity] Let `(X, d_X)` and `(Y, d_Y)` be metric spaces and\n`f : X ‚Üí Y`. The function `f` is uniformly continuous on `X` if for every `Œµ &gt; 0` there exists\n`Œ¥ &gt; 0` such that for all `x, x' ‚àà X`, `d_X x x' &lt; Œ¥ ‚Üí d_Y (f x) (f x') &lt; Œµ`. </code>",
 "117":
 "<code class=\"docstring\">Apply function extensionality and introduce new hypotheses.\nThe tactic `funext` will keep applying the `funext` lemma until the goal target is not reducible to\n```\n  |-  ((fun x =&gt; ...) = (fun x =&gt; ...))\n```\nThe variant `funext h‚ÇÅ ... h‚Çô` applies `funext` `n` times, and uses the given identifiers to name the new hypotheses.\nPatterns can be used like in the `intro` tactic. Example, given a goal\n```\n  |-  ((fun x : Nat √ó Bool =&gt; ...) = (fun x =&gt; ...))\n```\n`funext (a, b)` applies `funext` once and performs pattern matching on the newly introduced pair.\n</code>",
 "116":
 "<code>nhds.{u_3} {X : Type u_3} [TopologicalSpace X] (x : X) : Filter X</code><span class=\"sep\"></span><code class=\"docstring\">A set is called a neighborhood of `x` if it contains an open set around `x`. The set of all\nneighborhoods of `x` forms a filter, the neighborhood filter at `x`, is here defined as the\ninfimum over the principal filters of all open sets containing `x`. </code>",
 "115": "<code>X</code>",
 "114":
 "<code class=\"docstring\">`set a := t with h` is a variant of `let a := t`. It adds the hypothesis `h : a = t` to\nthe local context and replaces `t` with `a` everywhere it can.\n\n`set a := t with ‚Üê h` will add `h : t = a` instead.\n\n`set! a := t with h` does not do any replacing.\n\n```lean\nexample (x : Nat) (h : x + x - x = 3) : x + x - x = 3 := by\n  set y := x with ‚Üê h2\n  sorry\n/-\nx : Nat\ny : Nat := x\nh : y + y - y = 3\nh2 : x = y\n‚ä¢ y + y - y = 3\n-/\n```\n</code>",
 "113":
 "<code>Min.min.{u} {Œ± : Type u} [self : Min Œ±] : Œ± ‚Üí Œ± ‚Üí Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Returns the lesser of its two arguments. </code>",
 "112": "<code>Min Œ±</code>",
 "111":
 "<code>Max.max.{u} {Œ± : Type u} [self : Max Œ±] : Œ± ‚Üí Œ± ‚Üí Œ±</code><span class=\"sep\"></span><code class=\"docstring\">Returns the greater of its two arguments. </code>",
 "110": "<code>Max Œ±</code>",
 "11":
 "<code class=\"docstring\">The universe of propositions. `Prop ‚â° Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "109": "<code>?m.1</code>",
 "108":
 "<code>Continuous.{u, v} {X : Type u} {Y : Type v} [TopologicalSpace X] [TopologicalSpace Y] (f : X ‚Üí Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function between topological spaces is continuous if the preimage\nof every open set is open. Registered as a structure to make sure it is not unfolded by Lean. </code>",
 "107":
 "<code>IsContinuous.{u_1, u_2} {X : Type u_1} {Y : Type u_2} [MetricSpace X] [MetricSpace Y] (f : X ‚Üí Y) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">A function between metric spaces is continuous if it is continuous at every point. </code>",
 "106": "<code>X ‚Üí Y</code>",
 "105":
 "<code class=\"docstring\">The `obtain` tactic is a combination of `have` and `rcases`. See `rcases` for\na description of supported patterns.\n\n```lean\nobtain ‚ü®patt‚ü© : type := proof\n```\nis equivalent to\n```lean\nhave h : type := proof\nrcases h with ‚ü®patt‚ü©\n```\n\nIf `‚ü®patt‚ü©` is omitted, `rcases` will try to infer the pattern.\n\nIf `type` is omitted, `:= proof` is required.\n</code>",
 "104":
 "<code>intDiscreteDist (m n : ‚Ñ§) : ‚Ñù</code><span class=\"sep\"></span><code class=\"docstring\">Helper for Proposition 1.29: discrete distance on `‚Ñ§`, `0` on the diagonal and `1` off it. </code>",
 "103": "<code>‚Ñ§</code>",
 "102":
 "<code class=\"docstring\">`exfalso` converts a goal `‚ä¢ tgt` into `‚ä¢ False` by applying `False.elim`. </code>",
 "101":
 "<code class=\"docstring\">`if c then t else e` is notation for `ite c t e`, \"if-then-else\", which decides to\nreturn `t` or `e` depending on whether `c` is true or false. The explicit argument\n`c : Prop` does not have any actual computational content, but there is an additional\n`[Decidable c]` argument synthesized by typeclass inference which actually\ndetermines how to evaluate `c` to true or false. Write `if h : c then t else e`\ninstead for a \"dependent if-then-else\" `dite`, which allows `t`/`e` to use the fact\nthat `c` is true/false.\n</code>",
 "100": "<code>?m.2</code>",
 "10":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "1":
 "<code>Int : Type</code><span class=\"sep\"></span><code class=\"docstring\">The integers.\n\nThis type is special-cased by the compiler and overridden with an efficient implementation. The\nruntime has a special representation for `Int` that stores ‚Äúsmall‚Äù signed numbers directly, while\nlarger numbers use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)). A ‚Äúsmall number‚Äù is an integer that can be encoded with one fewer bits\nthan the platform's pointer size (i.e. 63 bits on 64-bit architectures and 31 bits on 32-bit\narchitectures).\n</code>",
 "0":
 "<code class=\"docstring\">A `section`/`end` pair delimits the scope of `variable`, `include`, `open`, `set_option`, and `local`\ncommands. Sections can be nested. `section &lt;id&gt;` provides a label to the section that has to appear\nwith the matching `end`. In either case, the `end` can be omitted, in which case the section is\nclosed at the end of the file.\n</code>"}