/-
Copyright (c) 2026 Zichen Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zichen Wang, Wanli Ma, Yuhao Jiang, Zaiwen Wen
-/

import Mathlib

import Books.ConvexAnalysis_Rockafellar_1970.Chapters.Chap01.section01_part1
import Books.ConvexAnalysis_Rockafellar_1970.Chapters.Chap01.section02_part1

open scoped BigOperators
open scoped Pointwise

section Chap01
section Section02

/-- Positive scaling sends the nonnegative ray into itself. -/
lemma smul_rayNonneg_subset (n : Nat) (S : Set (Fin n â†’ Real)) {t : Real} (ht : 0 < t) :
    t â€¢ rayNonneg n S âŠ† rayNonneg n S := by
  intro y hy
  rcases hy with âŸ¨y', hy', rflâŸ©
  rcases hy' with âŸ¨x, hxS, r, hr, rflâŸ©
  refine âŸ¨x, hxS, t * r, ?_, by simp [smul_smul]âŸ©
  exact mul_nonneg (le_of_lt ht) hr

/-- The convex hull of the ray is closed under positive scaling. -/
lemma convexHull_rayNonneg_smul_closed (n : Nat) (S : Set (Fin n â†’ Real)) :
    âˆ€ x âˆˆ convexHull Real (rayNonneg n S), âˆ€ t : Real, 0 < t â†’
      t â€¢ x âˆˆ convexHull Real (rayNonneg n S) := by
  intro x hx t ht
  have hsubset : t â€¢ rayNonneg n S âŠ† rayNonneg n S :=
    smul_rayNonneg_subset n S ht
  have hx' : t â€¢ x âˆˆ t â€¢ convexHull Real (rayNonneg n S) := âŸ¨x, hx, rflâŸ©
  have hx'' : t â€¢ x âˆˆ convexHull Real (t â€¢ rayNonneg n S) := by
    have :
        t â€¢ convexHull Real (rayNonneg n S) =
          convexHull Real (t â€¢ rayNonneg n S) := by
      simpa using
        (convexHull_smul (ğ•œ:=Real) (a:=t) (s:=rayNonneg n S)).symm
    simpa [this] using hx'
  have hsubsetHull :
      convexHull Real (t â€¢ rayNonneg n S) âŠ† convexHull Real (rayNonneg n S) :=
    convexHull_min (hsubset.trans (subset_convexHull (ğ•œ:=Real) (s:=rayNonneg n S)))
      (convex_convexHull Real (rayNonneg n S))
  exact hsubsetHull hx''

/-- The convex hull of the ray is closed under addition. -/
lemma convexHull_rayNonneg_add_closed (n : Nat) (S : Set (Fin n â†’ Real)) :
    âˆ€ x âˆˆ convexHull Real (rayNonneg n S), âˆ€ y âˆˆ convexHull Real (rayNonneg n S),
      x + y âˆˆ convexHull Real (rayNonneg n S) := by
  intro x hx y hy
  have hmid : midpoint Real x y âˆˆ convexHull Real (rayNonneg n S) :=
    Convex.midpoint_mem (convex_convexHull Real (rayNonneg n S)) hx hy
  have htwo : (2 : Real) â€¢ midpoint Real x y âˆˆ convexHull Real (rayNonneg n S) :=
    convexHull_rayNonneg_smul_closed n S _ hmid 2 (by norm_num)
  have hsum : x + y = (2 : Real) â€¢ midpoint Real x y := by
    calc
      x + y = midpoint Real x y + midpoint Real x y := by simp
      _ = (2 : Real) â€¢ midpoint Real x y := by
            simpa using (two_smul Real (midpoint Real x y)).symm
  simpa [hsum] using htwo

/-- Corollary 2.6.11. For any nonempty subset `S âŠ† Real^n`, the convex cone generated by `S`
satisfies `cone S = conv (ray S)`. -/
theorem convexConeGenerated_eq_convexHull_ray (n : Nat) (S : Set (Fin n â†’ Real))
    (hS : S.Nonempty) :
    convexConeGenerated n S =
      convexHull Real {y : Fin n â†’ Real | âˆƒ x âˆˆ S, âˆƒ t : Real, 0 â‰¤ t âˆ§ y = t â€¢ x} := by
  change convexConeGenerated n S = convexHull Real (rayNonneg n S)
  refine subset_antisymm ?_ ?_
  Â· let K : ConvexCone Real (Fin n â†’ Real) :=
      { carrier := convexHull Real (rayNonneg n S)
        smul_mem' := by
          intro c hc x hx
          exact convexHull_rayNonneg_smul_closed n S x hx c hc
        add_mem' := by
          intro x hx y hy
          exact convexHull_rayNonneg_add_closed n S x hx y hy }
    have hSsub : S âŠ† (K : Set (Fin n â†’ Real)) := by
      intro x hx
      have hxray : x âˆˆ rayNonneg n S := by
        refine âŸ¨x, hx, 1, by norm_num, by simpâŸ©
      exact (subset_convexHull (ğ•œ:=Real) (s:=rayNonneg n S)) hxray
    have hHullSub : (ConvexCone.hull Real S : Set (Fin n â†’ Real)) âŠ† K := by
      intro x hx
      exact (ConvexCone.hull_min (s:=S) (C:=K) hSsub) hx
    rcases hS with âŸ¨x0, hx0âŸ©
    have h0ray : (0 : Fin n â†’ Real) âˆˆ rayNonneg n S := by
      refine âŸ¨x0, hx0, 0, le_rfl, ?_âŸ©
      simp
    have h0conv : (0 : Fin n â†’ Real) âˆˆ convexHull Real (rayNonneg n S) :=
      (subset_convexHull (ğ•œ:=Real) (s:=rayNonneg n S)) h0ray
    intro y hy
    have hy' : y = 0 âˆ¨ y âˆˆ (ConvexCone.hull Real S : Set (Fin n â†’ Real)) := by
      simpa [convexConeGenerated] using hy
    cases hy' with
    | inl hy0 =>
        subst hy0
        simpa using h0conv
    | inr hyHull =>
        exact hHullSub hyHull
  Â· have hconv : Convex Real (convexConeGenerated n S) :=
      convexConeGenerated_convex n S
    have hsubset : rayNonneg n S âŠ† convexConeGenerated n S :=
      rayNonneg_subset_convexConeGenerated n S
    exact convexHull_min hsubset hconv

/-- Theorem 2.7. Let `K` be a convex cone containing `0`. Then the smallest subspace containing
`K` is the set of differences `{x - y | x âˆˆ K, y âˆˆ K}`, which coincides with `aff K`, and the
largest subspace contained in `K` is `(-K) âˆ© K`. -/
theorem convexCone_smallest_largest_subspace (n : Nat) (K : Set (Fin n â†’ Real))
    (hK : IsConvexCone n K) (h0 : (0 : Fin n â†’ Real) âˆˆ K) :
    (Submodule.span Real K : Set (Fin n â†’ Real)) =
        {z : Fin n â†’ Real | âˆƒ x âˆˆ K, âˆƒ y âˆˆ K, z = x - y} âˆ§
      (Submodule.span Real K : Set (Fin n â†’ Real)) = (affineSpan Real K : Set (Fin n â†’ Real)) âˆ§
      (âˆƒ S : Submodule Real (Fin n â†’ Real),
        (S : Set (Fin n â†’ Real)) âŠ† K âˆ§
          (âˆ€ T : Submodule Real (Fin n â†’ Real), (T : Set (Fin n â†’ Real)) âŠ† K â†’ T â‰¤ S) âˆ§
          (S : Set (Fin n â†’ Real)) = {x : Fin n â†’ Real | x âˆˆ K âˆ§ -x âˆˆ K}) := by
  have hadd : âˆ€ x âˆˆ K, âˆ€ y âˆˆ K, x + y âˆˆ K :=
    isConvexCone_add_closed n K hK
  have hsmul_nonneg : âˆ€ x âˆˆ K, âˆ€ t : Real, 0 â‰¤ t â†’ t â€¢ x âˆˆ K := by
    intro x hx t ht
    by_cases ht0 : t = 0
    Â· subst ht0
      simpa using h0
    Â· have htpos : 0 < t := lt_of_le_of_ne ht (Ne.symm ht0)
      exact hK.1 x hx t htpos
  have hspan_eq :
      (Submodule.span Real K : Set (Fin n â†’ Real)) =
        {z : Fin n â†’ Real | âˆƒ x âˆˆ K, âˆƒ y âˆˆ K, z = x - y} := by
    refine subset_antisymm ?_ ?_
    Â· intro z hz
      refine
        Submodule.span_induction
          (p:=fun z _ => âˆƒ x âˆˆ K, âˆƒ y âˆˆ K, z = x - y) ?_ ?_ ?_ ?_ hz
      Â· intro x hx
        exact âŸ¨x, hx, 0, h0, by simpâŸ©
      Â· exact âŸ¨0, h0, 0, h0, by simpâŸ©
      Â· intro x y hx hy hxrep hyrep
        rcases hxrep with âŸ¨x1, hx1, x2, hx2, rflâŸ©
        rcases hyrep with âŸ¨y1, hy1, y2, hy2, rflâŸ©
        refine âŸ¨x1 + y1, hadd _ hx1 _ hy1, x2 + y2, hadd _ hx2 _ hy2, ?_âŸ©
        simp [sub_eq_add_neg, add_comm, add_left_comm, add_assoc]
      Â· intro a x hx hxrep
        rcases hxrep with âŸ¨x1, hx1, x2, hx2, rflâŸ©
        by_cases ha : 0 â‰¤ a
        Â· refine âŸ¨a â€¢ x1, hsmul_nonneg _ hx1 _ ha, a â€¢ x2, hsmul_nonneg _ hx2 _ ha, ?_âŸ©
          simp [smul_sub]
        Â· have ha' : 0 â‰¤ -a := by linarith
          refine
            âŸ¨(-a) â€¢ x2, hsmul_nonneg _ hx2 _ ha', (-a) â€¢ x1, hsmul_nonneg _ hx1 _ ha', ?_âŸ©
          calc
            a â€¢ (x1 - x2) = a â€¢ x1 - a â€¢ x2 := by simp [smul_sub]
            _ = (-a) â€¢ x2 - (-a) â€¢ x1 := by
              simp [sub_eq_add_neg, add_comm, neg_smul]
    Â· intro z hz
      rcases hz with âŸ¨x, hx, y, hy, rflâŸ©
      exact
        Submodule.sub_mem _ (Submodule.subset_span hx) (Submodule.subset_span hy)
  have hspan_affine :
      (Submodule.span Real K : Set (Fin n â†’ Real)) = (affineSpan Real K : Set (Fin n â†’ Real)) := by
    simpa [Set.insert_eq_of_mem h0] using
      (affineSpan_insert_zero (k:=Real) (s:=K)).symm
  let S : Submodule Real (Fin n â†’ Real) :=
    { carrier := {x : Fin n â†’ Real | x âˆˆ K âˆ§ -x âˆˆ K}
      zero_mem' := by
        refine âŸ¨h0, ?_âŸ©
        simpa using h0
      add_mem' := by
        intro x y hx hy
        rcases hx with âŸ¨hxK, hxnegâŸ©
        rcases hy with âŸ¨hyK, hynegâŸ©
        refine âŸ¨hadd _ hxK _ hyK, ?_âŸ©
        simpa [neg_add] using hadd (-y) hyneg (-x) hxneg
      smul_mem' := by
        intro a x hx
        rcases hx with âŸ¨hxK, hxnegâŸ©
        by_cases ha : 0 â‰¤ a
        Â· have h1 : a â€¢ x âˆˆ K := hsmul_nonneg x hxK a ha
          have h2 : a â€¢ (-x) âˆˆ K := hsmul_nonneg (-x) hxneg a ha
          refine âŸ¨h1, ?_âŸ©
          simpa [smul_neg] using h2
        Â· have ha' : 0 â‰¤ -a := by linarith
          have h1 : (-a) â€¢ (-x) âˆˆ K := hsmul_nonneg (-x) hxneg (-a) ha'
          have h2 : (-a) â€¢ x âˆˆ K := hsmul_nonneg x hxK (-a) ha'
          refine âŸ¨?_, ?_âŸ©
          Â· simpa [smul_neg, neg_smul] using h1
          Â· simpa [neg_smul] using h2 }
  have hSsubset : (S : Set (Fin n â†’ Real)) âŠ† K := by
    intro x hx
    exact hx.1
  have hSmax :
      âˆ€ T : Submodule Real (Fin n â†’ Real), (T : Set (Fin n â†’ Real)) âŠ† K â†’ T â‰¤ S := by
    intro T hT x hx
    refine âŸ¨hT hx, ?_âŸ©
    exact hT (by simpa using T.neg_mem hx)
  refine âŸ¨hspan_eq, hspan_affine, ?_âŸ©
  refine âŸ¨S, hSsubset, hSmax, rflâŸ©

/-- Definition 2.7.10. A vector `x*` is normal to a convex set `C` at a point `a âˆˆ C` if
`âŸªx - a, x*âŸ« â‰¤ 0` for every `x âˆˆ C`; the set of all vectors normal to `C` at `a`
is called the normal cone to `C` at `a`. -/
def IsNormalToConvexSet (n : Nat) (C : Set (Fin n â†’ Real)) (a xstar : Fin n â†’ Real) : Prop :=
  a âˆˆ C âˆ§ âˆ€ x âˆˆ C, (x - a) â¬áµ¥ xstar â‰¤ 0

/-- Definition 2.7.10. The normal cone to `C` at `a` is the set of all vectors normal to `C`
at `a`. -/
def normalConeAt (n : Nat) (C : Set (Fin n â†’ Real)) (a : Fin n â†’ Real) :
    Set (Fin n â†’ Real) :=
  {xstar : Fin n â†’ Real | IsNormalToConvexSet n C a xstar}

/-- Definition 2.7.11. The barrier cone of a convex set `C` is the set of all vectors `x*`
such that there exists `Î² âˆˆ â„` with `âŸªx, x*âŸ« â‰¤ Î²` for every `x âˆˆ C`. -/
def barrierCone (n : Nat) (C : Set (Fin n â†’ Real)) : Set (Fin n â†’ Real) :=
  {xstar : Fin n â†’ Real | âˆƒ Î² : Real, âˆ€ x âˆˆ C, x â¬áµ¥ xstar â‰¤ Î²}

/-- The barrier cone is closed under positive scalar multiplication. -/
lemma barrierCone_smul_mem (n : Nat) (C : Set (Fin n â†’ Real)) {xstar : Fin n â†’ Real}
    (hx : xstar âˆˆ barrierCone n C) {t : Real} (ht : 0 < t) :
    t â€¢ xstar âˆˆ barrierCone n C := by
  rcases hx with âŸ¨Î², hxÎ²âŸ©
  refine âŸ¨t * Î², ?_âŸ©
  intro x hxC
  have hle : x â¬áµ¥ xstar â‰¤ Î² := hxÎ² x hxC
  have hmul : t * (x â¬áµ¥ xstar) â‰¤ t * Î² := by
    exact mul_le_mul_of_nonneg_left hle (le_of_lt ht)
  simpa [dotProduct_smul, mul_assoc, mul_left_comm, mul_comm] using hmul

/-- The barrier cone is closed under addition. -/
lemma barrierCone_add_mem (n : Nat) (C : Set (Fin n â†’ Real)) {xstar1 : Fin n â†’ Real}
    (hx1 : xstar1 âˆˆ barrierCone n C) {xstar2 : Fin n â†’ Real} (hx2 : xstar2 âˆˆ barrierCone n C) :
    xstar1 + xstar2 âˆˆ barrierCone n C := by
  rcases hx1 with âŸ¨Î²1, hx1Î²âŸ©
  rcases hx2 with âŸ¨Î²2, hx2Î²âŸ©
  refine âŸ¨Î²1 + Î²2, ?_âŸ©
  intro x hxC
  have h1 : x â¬áµ¥ xstar1 â‰¤ Î²1 := hx1Î² x hxC
  have h2 : x â¬áµ¥ xstar2 â‰¤ Î²2 := hx2Î² x hxC
  have hsum : x â¬áµ¥ xstar1 + x â¬áµ¥ xstar2 â‰¤ Î²1 + Î²2 := add_le_add h1 h2
  simpa [dotProduct_add] using hsum

/-- The normal cone at `a` is closed under addition. -/
lemma normalConeAt_add_mem (n : Nat) (C : Set (Fin n â†’ Real)) (a : Fin n â†’ Real)
    {xstar1 : Fin n â†’ Real} (hx1 : xstar1 âˆˆ normalConeAt n C a)
    {xstar2 : Fin n â†’ Real} (hx2 : xstar2 âˆˆ normalConeAt n C a) :
    xstar1 + xstar2 âˆˆ normalConeAt n C a := by
  rcases hx1 with âŸ¨ha1, hx1âŸ©
  rcases hx2 with âŸ¨_, hx2âŸ©
  refine âŸ¨ha1, ?_âŸ©
  intro x hxC
  have h1 : (x - a) â¬áµ¥ xstar1 â‰¤ 0 := hx1 x hxC
  have h2 : (x - a) â¬áµ¥ xstar2 â‰¤ 0 := hx2 x hxC
  have hsum : (x - a) â¬áµ¥ xstar1 + (x - a) â¬áµ¥ xstar2 â‰¤ 0 := add_nonpos h1 h2
  simpa [dotProduct_add] using hsum

/-- The normal cone at `a` is closed under positive scalar multiplication. -/
lemma normalConeAt_smul_mem (n : Nat) (C : Set (Fin n â†’ Real)) (a : Fin n â†’ Real)
    {xstar : Fin n â†’ Real} (hx : xstar âˆˆ normalConeAt n C a) {t : Real} (ht : 0 < t) :
    t â€¢ xstar âˆˆ normalConeAt n C a := by
  rcases hx with âŸ¨ha, hxâŸ©
  refine âŸ¨ha, ?_âŸ©
  intro x hxC
  have h : (x - a) â¬áµ¥ xstar â‰¤ 0 := hx x hxC
  have hsmul : t â€¢ ((x - a) â¬áµ¥ xstar) â‰¤ 0 :=
    smul_nonpos_of_nonneg_of_nonpos (le_of_lt ht) h
  simpa [dotProduct_smul] using hsmul

/-- Proposition 2.7.12. For a convex set `C âŠ† â„^n` and a point `a âˆˆ C`, the normal cone to
`C` at `a` is a convex cone. -/
theorem normalConeAt_isConvexCone (n : Nat) (C : Set (Fin n â†’ Real)) (a : Fin n â†’ Real)
    (_hC : Convex Real C) (_ha : a âˆˆ C) :
    IsConvexCone n (normalConeAt n C a) := by
  refine (isConvexCone_iff_add_closed_and_pos_smul_closed n (normalConeAt n C a)).2 ?_
  refine âŸ¨?_, ?_âŸ©
  Â· intro x hx y hy
    exact normalConeAt_add_mem n C a hx hy
  Â· intro x hx t ht
    exact normalConeAt_smul_mem n C a hx ht

/-- Proposition 2.7.13. For a convex set `C âŠ† â„^n`, the barrier cone of `C` is a convex cone. -/
theorem barrierCone_isConvexCone (n : Nat) (C : Set (Fin n â†’ Real)) (_hC : Convex Real C) :
    IsConvexCone n (barrierCone n C) := by
  refine (isConvexCone_iff_add_closed_and_pos_smul_closed n (barrierCone n C)).2 ?_
  refine âŸ¨?_, ?_âŸ©
  Â· intro x hx y hy
    exact barrierCone_add_mem n C hx hy
  Â· intro x hx t ht
    exact barrierCone_smul_mem n C hx ht

/-- The `â‰¤` dot-product half-space is convex. -/
lemma convex_closedHalfSpaceLE_dotProduct (n : Nat) (b : Fin n â†’ Real) (Î² : Real) :
    Convex Real (closedHalfSpaceLE n b Î²) := by
  simpa [closedHalfSpaceLE] using (convex_dotProduct_le n b Î²)

/-- The `â‰¥` dot-product half-space is convex. -/
lemma convex_closedHalfSpaceGE_dotProduct (n : Nat) (b : Fin n â†’ Real) (Î² : Real) :
    Convex Real (closedHalfSpaceGE n b Î²) := by
  simpa [closedHalfSpaceGE] using
    (convex_halfSpace_ge (f := fun x : Fin n â†’ Real => x â¬áµ¥ b)
      (h := isLinearMap_dotProduct_left n b) Î²)

/-- The strict dot-product half-spaces (`<` and `>`) are convex. -/
lemma convex_openHalfSpaces_dotProduct (n : Nat) (b : Fin n â†’ Real) (Î² : Real) :
    Convex Real (openHalfSpaceLT n b Î²) âˆ§ Convex Real (openHalfSpaceGT n b Î²) := by
  constructor
  Â· simpa [openHalfSpaceLT] using
      (convex_halfSpace_lt (f := fun x : Fin n â†’ Real => x â¬áµ¥ b)
        (h := isLinearMap_dotProduct_left n b) Î²)
  Â· simpa [openHalfSpaceGT] using
      (convex_halfSpace_gt (f := fun x : Fin n â†’ Real => x â¬áµ¥ b)
        (h := isLinearMap_dotProduct_left n b) Î²)

/-- Corollary 2.0.4. For non-zero `b âˆˆ Real^n` and `Î² âˆˆ Real`, each of the four half-spaces
`{x | âŸªx, bâŸ« â‰¤ Î²}`, `{x | âŸªx, bâŸ« â‰¥ Î²}`, `{x | âŸªx, bâŸ« < Î²}`, `{x | âŸªx, bâŸ« > Î²}` is a convex
subset of `Real^n`. -/
theorem convex_halfSpaces_dotProduct (n : Nat) (b : Fin n â†’ Real) (hb : b â‰  0) (Î² : Real) :
    Convex Real (closedHalfSpaceLE n b Î²) âˆ§
      Convex Real (closedHalfSpaceGE n b Î²) âˆ§
      Convex Real (openHalfSpaceLT n b Î²) âˆ§
      Convex Real (openHalfSpaceGT n b Î²) := by
  have hb' : b â‰  0 := hb
  clear hb'
  refine âŸ¨convex_closedHalfSpaceLE_dotProduct n b Î², ?_âŸ©
  refine âŸ¨convex_closedHalfSpaceGE_dotProduct n b Î², ?_âŸ©
  exact convex_openHalfSpaces_dotProduct n b Î²

/-- Proposition 2.0.5. Every affine subset of `â„^n` (including `âˆ…` and `â„^n` itself) is convex. -/
theorem isAffineSet_imp_convex (n : Nat) (M : Set (Fin n â†’ Real)) (hM : IsAffineSet n M) :
    Convex Real M := by
  rcases (isAffineSet_iff_affineSubspace n M).1 hM with âŸ¨s, rflâŸ©
  simpa using (s.convex : Convex Real (s : Set (Fin n â†’ Real)))

/-- A nonzero vector has positive dot product with itself. -/
lemma dotProduct_self_pos_of_ne_zero {n : Nat} {b : Fin n â†’ Real} (hb : b â‰  0) : 0 < b â¬áµ¥ b := by
  have hb' : (0 < b â¬áµ¥ b â†” b â‰  0) := by
    simpa using (Matrix.dotProduct_self_star_pos_iff (v := b))
  exact hb'.2 hb

/-- For nonzero `b`, there is a vector with prescribed dot product with `b`. -/
lemma exists_dotProduct_eq_of_ne_zero (n : Nat) (b : Fin n â†’ Real) (Î² : Real) (hb : b â‰  0) :
    âˆƒ x0 : Fin n â†’ Real, x0 â¬áµ¥ b = Î² := by
  have hbpos : 0 < b â¬áµ¥ b := dotProduct_self_pos_of_ne_zero (b := b) hb
  have hbne : b â¬áµ¥ b â‰  0 := ne_of_gt hbpos
  refine âŸ¨(Î² / (b â¬áµ¥ b)) â€¢ b, ?_âŸ©
  simp [div_eq_mul_inv, hbne]

/-- Dot products with `b` after shifting by `Â± b` in the left argument. -/
lemma dotProduct_shift_by_b (n : Nat) (b x : Fin n â†’ Real) :
    (x + b) â¬áµ¥ b = x â¬áµ¥ b + b â¬áµ¥ b âˆ§ (x - b) â¬áµ¥ b = x â¬áµ¥ b - b â¬áµ¥ b := by
  constructor <;> simp

/-- Proposition 2.0.6. For any non-zero `b âˆˆ Real^n` and any `Î² âˆˆ Real`, each of the four
half-spaces `{x | âŸªx, bâŸ« â‰¤ Î²}`, `{x | âŸªx, bâŸ« â‰¥ Î²}`, `{x | âŸªx, bâŸ« < Î²}`, `{x | âŸªx, bâŸ« > Î²}`
is non-empty. -/
theorem halfSpaces_dotProduct_nonempty (n : Nat) (b : Fin n â†’ Real) (hb : b â‰  0) (Î² : Real) :
    (closedHalfSpaceLE n b Î²).Nonempty âˆ§
      (closedHalfSpaceGE n b Î²).Nonempty âˆ§
      (openHalfSpaceLT n b Î²).Nonempty âˆ§
      (openHalfSpaceGT n b Î²).Nonempty := by
  have hbpos : 0 < b â¬áµ¥ b := dotProduct_self_pos_of_ne_zero (b := b) hb
  obtain âŸ¨x0, hx0âŸ© := exists_dotProduct_eq_of_ne_zero n b Î² hb
  refine âŸ¨?_, ?_âŸ©
  Â· refine âŸ¨x0, ?_âŸ©
    simp [closedHalfSpaceLE, hx0]
  refine âŸ¨?_, ?_âŸ©
  Â· refine âŸ¨x0, ?_âŸ©
    simp [closedHalfSpaceGE, hx0]
  refine âŸ¨?_, ?_âŸ©
  Â· refine âŸ¨x0 - b, ?_âŸ©
    have hminus : (x0 - b) â¬áµ¥ b = x0 â¬áµ¥ b - b â¬áµ¥ b :=
      (dotProduct_shift_by_b n b x0).2
    have : Î² - b â¬áµ¥ b < Î² := sub_lt_self Î² hbpos
    simpa [openHalfSpaceLT, hminus, hx0] using this
  Â· refine âŸ¨x0 + b, ?_âŸ©
    have hplus : (x0 + b) â¬áµ¥ b = x0 â¬áµ¥ b + b â¬áµ¥ b :=
      (dotProduct_shift_by_b n b x0).1
    have : Î² < Î² + b â¬áµ¥ b := lt_add_of_pos_right Î² hbpos
    simpa [openHalfSpaceGT, hplus, hx0] using this

/-- A comparison symbol for linear inequalities/equations. -/
inductive LinearComparison : Type
  | le
  | ge
  | lt
  | gt
  | eq

/-- Interpret `âŸªx, bâŸ« (rel) Î²` as a subset of `Real^n`. -/
def linearComparisonSet (n : Nat) (b : Fin n â†’ Real) (Î² : Real) :
    LinearComparison â†’ Set (Fin n â†’ Real)
  | .le => closedHalfSpaceLE n b Î²
  | .ge => closedHalfSpaceGE n b Î²
  | .lt => openHalfSpaceLT n b Î²
  | .gt => openHalfSpaceGT n b Î²
  | .eq => {x : Fin n â†’ Real | x â¬áµ¥ b = Î²}

/-- The hyperplane `{x | âŸªx, bâŸ« = Î²}` is convex, as an intersection of the two closed half-spaces
`{x | âŸªx, bâŸ« â‰¤ Î²}` and `{x | âŸªx, bâŸ« â‰¥ Î²}`. -/
lemma convex_dotProduct_eq (n : Nat) (b : Fin n â†’ Real) (Î² : Real) :
    Convex Real {x : Fin n â†’ Real | x â¬áµ¥ b = Î²} := by
  have hset :
      ({x : Fin n â†’ Real | x â¬áµ¥ b = Î²} : Set (Fin n â†’ Real)) =
        closedHalfSpaceLE n b Î² âˆ© closedHalfSpaceGE n b Î² := by
    ext x
    constructor
    Â· intro hx
      have hx' : x â¬áµ¥ b = Î² := by simpa using hx
      refine âŸ¨?_, ?_âŸ©
      Â· simp [closedHalfSpaceLE, hx']
      Â· simp [closedHalfSpaceGE, hx']
    Â· rintro âŸ¨hxle, hxgeâŸ©
      show x â¬áµ¥ b = Î²
      exact le_antisymm hxle hxge
  simpa [hset] using
    (convex_closedHalfSpaceLE_dotProduct n b Î²).inter (convex_closedHalfSpaceGE_dotProduct n b Î²)

/-- Each of the five comparison relations (`â‰¤`, `â‰¥`, `<`, `>`, `=`) defines a convex subset of
`Real^n` via `linearComparisonSet`. -/
lemma convex_linearComparisonSet (n : Nat) (b : Fin n â†’ Real) (Î² : Real) (r : LinearComparison) :
    Convex Real (linearComparisonSet n b Î² r) := by
  cases r with
  | le =>
      simpa [linearComparisonSet] using (convex_closedHalfSpaceLE_dotProduct n b Î²)
  | ge =>
      simpa [linearComparisonSet] using (convex_closedHalfSpaceGE_dotProduct n b Î²)
  | lt =>
      simpa [linearComparisonSet] using (convex_openHalfSpaces_dotProduct n b Î²).1
  | gt =>
      simpa [linearComparisonSet] using (convex_openHalfSpaces_dotProduct n b Î²).2
  | eq =>
      simpa [linearComparisonSet] using (convex_dotProduct_eq n b Î²)

/-- The solution set of a family of linear comparisons is the intersection of the individual
constraint sets. -/
lemma solutionSet_linearComparison_eq_iInter {Î¹ : Sort*} (n : Nat) (b : Î¹ â†’ Fin n â†’ Real)
    (Î² : Î¹ â†’ Real) (rel : Î¹ â†’ LinearComparison) :
    {x : Fin n â†’ Real | âˆ€ i, x âˆˆ linearComparisonSet n (b i) (Î² i) (rel i)} =
      â‹‚ i, linearComparisonSet n (b i) (Î² i) (rel i) := by
  ext x
  simp

/-- Corollary 2.1.2. Given any system of simultaneous linear inequalities and equations in `n`
variables, obtained by combining relations of the form `âŸªx, b iâŸ« â‰¤ Î² i`, `âŸªx, b iâŸ« â‰¥ Î² i`,
`âŸªx, b iâŸ« < Î² i`, `âŸªx, b iâŸ« > Î² i`, and `âŸªx, b iâŸ« = Î² i` (with `b i âˆˆ Real^n` and
`Î² i âˆˆ Real`), the set of all solutions `C âŠ† Real^n` is convex. -/
theorem convex_solutionSet_linearComparison {Î¹ : Sort*} (n : Nat) (b : Î¹ â†’ Fin n â†’ Real)
    (Î² : Î¹ â†’ Real) (rel : Î¹ â†’ LinearComparison) :
    Convex Real {x : Fin n â†’ Real | âˆ€ i, x âˆˆ linearComparisonSet n (b i) (Î² i) (rel i)} := by
  have hC : âˆ€ i, Convex Real (linearComparisonSet n (b i) (Î² i) (rel i)) := fun i =>
    convex_linearComparisonSet n (b i) (Î² i) (rel i)
  simpa [solutionSet_linearComparison_eq_iInter (n := n) (b := b) (Î² := Î²) (rel := rel)] using
    (convex_iInter_family (n := n) (C := fun i => linearComparisonSet n (b i) (Î² i) (rel i)) hC)

/-- If `D` lies in an affine subspace `A`, then the dimension of `D` is at most the finrank of
`A.direction`. -/
lemma convexSetDim_le_finrank_direction_of_subset_affineSubspace {n : Nat}
    {D : Set (Fin n â†’ Real)} {A : AffineSubspace Real (Fin n â†’ Real)}
    (hDA : D âŠ† (A : Set (Fin n â†’ Real))) :
    convexSetDim n D â‰¤ Module.finrank Real A.direction := by
  have hspan : affineSpan Real D â‰¤ A := affineSpan_le_of_subset_coe (k := Real) hDA
  have hdir : (affineSpan Real D).direction â‰¤ A.direction := AffineSubspace.direction_le hspan
  simpa [convexSetDim] using (Submodule.finrank_mono hdir)

/-- If `D` contains a `2`-simplex, then the dimension of `D` is at least `2`. -/
lemma two_le_convexSetDim_of_exists_simplex_two {n : Nat} {D : Set (Fin n â†’ Real)}
    (hsimplex : âˆƒ P, P âŠ† D âˆ§ IsSimplex n 2 P) :
    2 â‰¤ convexSetDim n D := by
  rcases hsimplex with âŸ¨P, hPD, hPâŸ©
  simpa using (simplex_dim_le_convexSetDim n D 2 P hPD hP)

/-- Proposition 2.4.11. Every convex disk in `â„^n` has dimension `2`, independently of the
ambient dimension `n`. -/
theorem convexDisk_convexSetDim_eq_two (n : Nat) (D : Set (Fin n â†’ Real))
    (hconv : Convex Real D)
    (hsub :
      âˆƒ A : AffineSubspace Real (Fin n â†’ Real),
        D âŠ† (A : Set (Fin n â†’ Real)) âˆ§ Module.finrank Real A.direction = 2)
    (hsimplex : âˆƒ P, P âŠ† D âˆ§ IsSimplex n 2 P) :
    convexSetDim n D = 2 := by
  have _hconv : Convex Real D := hconv
  rcases hsub with âŸ¨A, hDA, hArankâŸ©
  have hle : convexSetDim n D â‰¤ 2 := by
    simpa [hArank] using
      (convexSetDim_le_finrank_direction_of_subset_affineSubspace (n := n) (D := D) (A := A) hDA)
  have hge : 2 â‰¤ convexSetDim n D :=
    two_le_convexSetDim_of_exists_simplex_two (n := n) (D := D) hsimplex
  exact Nat.le_antisymm hle hge

/-- Rewrite `âˆ€ i, 0 â‰¤ âŸªx, b iâŸ«` as `âˆ€ i, âŸªx, -b iâŸ« â‰¤ 0`. -/
lemma setOf_forall_dotProduct_ge_zero_eq_setOf_forall_dotProduct_le_zero_neg {Î¹ : Sort*}
    (n : Nat) (b : Î¹ â†’ Fin n â†’ Real) :
    {x : Fin n â†’ Real | âˆ€ i, 0 â‰¤ x â¬áµ¥ b i} =
      {x : Fin n â†’ Real | âˆ€ i, x â¬áµ¥ (-b i) â‰¤ 0} := by
  ext x
  constructor
  Â· intro hx i
    have : -(x â¬áµ¥ b i) â‰¤ (0 : Real) := (neg_nonpos).2 (hx i)
    simpa [dotProduct_neg] using this
  Â· intro hx i
    have : -(x â¬áµ¥ b i) â‰¤ (0 : Real) := by
      simpa [dotProduct_neg] using hx i
    exact (neg_nonpos).1 this

/-- Corollary 2.5.2. Let `b i âˆˆ Real^n` for `i âˆˆ I`, where `I` is an arbitrary index set.
Then `K = {x âˆˆ Real^n | âŸªx, b iâŸ« â‰¥ 0, i âˆˆ I}` is a convex cone. -/
theorem convexCone_of_dotProduct_ge_zero {Î¹ : Sort*} (n : Nat) (b : Î¹ â†’ Fin n â†’ Real) :
    IsConvexCone n {x : Fin n â†’ Real | âˆ€ i, 0 â‰¤ x â¬áµ¥ b i} := by
  simpa [setOf_forall_dotProduct_ge_zero_eq_setOf_forall_dotProduct_le_zero_neg (n := n) (b := b)]
    using (convexCone_of_dotProduct_le_zero (n := n) (b := fun i => -b i))

/-- Pointwise add-closure for `{x | âˆ€ i, 0 < x â¬áµ¥ b i}`. -/
lemma add_mem_setOf_forall_dotProduct_pos {Î¹ : Sort*} {n : Nat} {b : Î¹ â†’ Fin n â†’ Real}
    {x y : Fin n â†’ Real} :
    (âˆ€ i, 0 < x â¬áµ¥ b i) â†’ (âˆ€ i, 0 < y â¬áµ¥ b i) â†’ (âˆ€ i, 0 < (x + y) â¬áµ¥ b i) := by
  intro hx hy i
  have hpos : 0 < x â¬áµ¥ b i + y â¬áµ¥ b i := add_pos (hx i) (hy i)
  simpa [add_dotProduct] using hpos

/-- Pointwise positive-scalar closure for `{x | âˆ€ i, 0 < x â¬áµ¥ b i}`. -/
lemma smul_mem_setOf_forall_dotProduct_pos {Î¹ : Sort*} {n : Nat} {b : Î¹ â†’ Fin n â†’ Real}
    {x : Fin n â†’ Real} {t : Real} :
    (âˆ€ i, 0 < x â¬áµ¥ b i) â†’ 0 < t â†’ (âˆ€ i, 0 < (t â€¢ x) â¬áµ¥ b i) := by
  intro hx ht i
  have hpos : 0 < t * (x â¬áµ¥ b i) := mul_pos ht (hx i)
  simpa [smul_dotProduct] using hpos

/-- Corollary 2.5.3. Let `b i âˆˆ Real^n` for `i âˆˆ I`, where `I` is an arbitrary index set.
Then `K = {x âˆˆ Real^n | âŸªx, b iâŸ« > 0, i âˆˆ I}` is a convex cone. -/
theorem convexCone_of_dotProduct_pos {Î¹ : Sort*} (n : Nat) (b : Î¹ â†’ Fin n â†’ Real) :
    IsConvexCone n {x : Fin n â†’ Real | âˆ€ i, 0 < x â¬áµ¥ b i} := by
  refine (isConvexCone_iff_add_closed_and_pos_smul_closed n
    {x : Fin n â†’ Real | âˆ€ i, 0 < x â¬áµ¥ b i}).2 ?_
  refine âŸ¨?_, ?_âŸ©
  Â· intro x hx y hy
    exact add_mem_setOf_forall_dotProduct_pos (x := x) (y := y) hx hy
  Â· intro x hx t ht
    exact smul_mem_setOf_forall_dotProduct_pos (x := x) (t := t) hx ht

/-- Rewrite `âˆ€ i, âŸªx, b iâŸ« < 0` as `âˆ€ i, 0 < âŸªx, -b iâŸ«`. -/
lemma setOf_forall_dotProduct_lt_zero_eq_setOf_forall_dotProduct_pos_neg {Î¹ : Sort*}
    (n : Nat) (b : Î¹ â†’ Fin n â†’ Real) :
    {x : Fin n â†’ Real | âˆ€ i, x â¬áµ¥ b i < 0} =
      {x : Fin n â†’ Real | âˆ€ i, 0 < x â¬áµ¥ (-b i)} := by
  ext x
  constructor
  Â· intro hx i
    have : 0 < -(x â¬áµ¥ b i) := (neg_pos).2 (hx i)
    simpa [dotProduct_neg] using this
  Â· intro hx i
    have : 0 < -(x â¬áµ¥ b i) := by
      simpa [dotProduct_neg] using hx i
    exact (neg_pos).1 this

/-- Corollary 2.5.4. Let `b i âˆˆ Real^n` for `i âˆˆ I`, where `I` is an arbitrary index set.
Then `K = {x âˆˆ Real^n | âŸªx, b iâŸ« < 0, i âˆˆ I}` is a convex cone. -/
theorem convexCone_of_dotProduct_lt_zero {Î¹ : Sort*} (n : Nat) (b : Î¹ â†’ Fin n â†’ Real) :
    IsConvexCone n {x : Fin n â†’ Real | âˆ€ i, x â¬áµ¥ b i < 0} := by
  simpa [setOf_forall_dotProduct_lt_zero_eq_setOf_forall_dotProduct_pos_neg (n := n) (b := b)]
    using (convexCone_of_dotProduct_pos (Î¹ := Î¹) (n := n) (b := fun i => -b i))

/-- Pointwise add-closure for `{x | âˆ€ i, x â¬áµ¥ b i = 0}`. -/
lemma add_mem_setOf_forall_dotProduct_eq_zero {Î¹ : Sort*} {n : Nat} {b : Î¹ â†’ Fin n â†’ Real}
    {x y : Fin n â†’ Real} :
    (âˆ€ i, x â¬áµ¥ b i = 0) â†’ (âˆ€ i, y â¬áµ¥ b i = 0) â†’ (âˆ€ i, (x + y) â¬áµ¥ b i = 0) := by
  intro hx hy i
  simp [add_dotProduct, hx i, hy i]

/-- Pointwise scalar closure for `{x | âˆ€ i, x â¬áµ¥ b i = 0}`. -/
lemma smul_mem_setOf_forall_dotProduct_eq_zero {Î¹ : Sort*} {n : Nat} {b : Î¹ â†’ Fin n â†’ Real}
    {x : Fin n â†’ Real} {t : Real} :
    (âˆ€ i, x â¬áµ¥ b i = 0) â†’ (âˆ€ i, (t â€¢ x) â¬áµ¥ b i = 0) := by
  intro hx i
  simp [smul_dotProduct, hx i]

/-- Corollary 2.5.5. Let `b i âˆˆ Real^n` for `i âˆˆ I`, where `I` is an arbitrary index set.
Then `K = {x âˆˆ Real^n | âŸªx, b iâŸ« = 0, i âˆˆ I}` is a convex cone. -/
theorem convexCone_of_dotProduct_eq_zero {Î¹ : Sort*} (n : Nat) (b : Î¹ â†’ Fin n â†’ Real) :
    IsConvexCone n {x : Fin n â†’ Real | âˆ€ i, x â¬áµ¥ b i = 0} := by
  refine (isConvexCone_iff_add_closed_and_pos_smul_closed n
    {x : Fin n â†’ Real | âˆ€ i, x â¬áµ¥ b i = 0}).2 ?_
  refine âŸ¨?_, ?_âŸ©
  Â· intro x hx y hy
    exact add_mem_setOf_forall_dotProduct_eq_zero (x := x) (y := y) hx hy
  Â· intro x hx t ht
    exact smul_mem_setOf_forall_dotProduct_eq_zero (x := x) (t := t) hx

/-- Each homogeneous linear comparison set `âŸªx, bâŸ« (rel) 0` is a convex cone. -/
lemma convexCone_linearComparisonSet_zero (n : Nat) (b : Fin n â†’ Real) (r : LinearComparison) :
    IsConvexCone n (linearComparisonSet n b (0 : Real) r) := by
  cases r with
  | le =>
      simpa [linearComparisonSet, closedHalfSpaceLE] using
        (IsConvexCone_dotProduct_le_zero n b)
  | ge =>
      have hset :
          (linearComparisonSet n b (0 : Real) LinearComparison.ge) =
            {x : Fin n â†’ Real | x â¬áµ¥ (-b) â‰¤ 0} := by
        ext x
        constructor
        Â· intro hx
          have : 0 â‰¤ x â¬áµ¥ b := by simpa [linearComparisonSet, closedHalfSpaceGE] using hx
          have : -(x â¬áµ¥ b) â‰¤ 0 := (neg_nonpos).2 this
          simpa [dotProduct_neg] using this
        Â· intro hx
          have : -(x â¬áµ¥ b) â‰¤ 0 := by simpa [dotProduct_neg] using hx
          have : 0 â‰¤ x â¬áµ¥ b := (neg_nonpos).1 this
          simpa [linearComparisonSet, closedHalfSpaceGE] using this
      simpa [hset] using (IsConvexCone_dotProduct_le_zero n (-b))
  | lt =>
      have hset :
          (linearComparisonSet n b (0 : Real) LinearComparison.lt) =
            {x : Fin n â†’ Real | 0 < x â¬áµ¥ (-b)} := by
        ext x
        constructor
        Â· intro hx
          have : x â¬áµ¥ b < 0 := by simpa [linearComparisonSet, openHalfSpaceLT] using hx
          have : 0 < -(x â¬áµ¥ b) := (neg_pos).2 this
          simpa [dotProduct_neg] using this
        Â· intro hx
          have : 0 < -(x â¬áµ¥ b) := by simpa [dotProduct_neg] using hx
          have : x â¬áµ¥ b < 0 := (neg_pos).1 this
          simpa [linearComparisonSet, openHalfSpaceLT] using this
      -- Reuse Corollary 2.5.3 on `-b` and the set equality above.
      have : IsConvexCone n {x : Fin n â†’ Real | 0 < x â¬áµ¥ (-b)} := by
        simpa using (convexCone_of_dotProduct_pos (Î¹ := PUnit.{0}) (n := n) (b := fun _ => -b))
      simpa [hset] using this
  | gt =>
      -- Directly show closure under addition and positive scaling.
      refine (isConvexCone_iff_add_closed_and_pos_smul_closed n
        (linearComparisonSet n b (0 : Real) LinearComparison.gt)).2 ?_
      refine âŸ¨?_, ?_âŸ©
      Â· intro x hx y hy
        have hx' : 0 < x â¬áµ¥ b := by simpa [linearComparisonSet, openHalfSpaceGT] using hx
        have hy' : 0 < y â¬áµ¥ b := by simpa [linearComparisonSet, openHalfSpaceGT] using hy
        have hpos : 0 < x â¬áµ¥ b + y â¬áµ¥ b := add_pos hx' hy'
        have : 0 < (x + y) â¬áµ¥ b := by simpa [add_dotProduct] using hpos
        simpa [linearComparisonSet, openHalfSpaceGT] using this
      Â· intro x hx t ht
        have hx' : 0 < x â¬áµ¥ b := by simpa [linearComparisonSet, openHalfSpaceGT] using hx
        have hpos : 0 < t * (x â¬áµ¥ b) := mul_pos ht hx'
        have : 0 < (t â€¢ x) â¬áµ¥ b := by simpa [smul_dotProduct] using hpos
        simpa [linearComparisonSet, openHalfSpaceGT] using this
  | eq =>
      refine (isConvexCone_iff_add_closed_and_pos_smul_closed n
        (linearComparisonSet n b (0 : Real) LinearComparison.eq)).2 ?_
      refine âŸ¨?_, ?_âŸ©
      Â· intro x hx y hy
        have hx' : x â¬áµ¥ b = 0 := by simpa [linearComparisonSet] using hx
        have hy' : y â¬áµ¥ b = 0 := by simpa [linearComparisonSet] using hy
        have : (x + y) â¬áµ¥ b = 0 := by simp [add_dotProduct, hx', hy']
        simpa [linearComparisonSet] using this
      Â· intro x hx t _ht
        have hx' : x â¬áµ¥ b = 0 := by simpa [linearComparisonSet] using hx
        have : (t â€¢ x) â¬áµ¥ b = 0 := by simp [smul_dotProduct, hx']
        simpa [linearComparisonSet] using this

/-- Corollary 2.5.6. Let `b i âˆˆ Real^n` for `i âˆˆ I`, where `I` is an arbitrary index set, and
consider a system of homogeneous linear relations of the form `âŸªx, b iâŸ« â‰¤ 0`, `âŸªx, b iâŸ« â‰¥ 0`,
`âŸªx, b iâŸ« < 0`, `âŸªx, b iâŸ« > 0`, and `âŸªx, b iâŸ« = 0` for various indices `i âˆˆ I`. Then the set
`K` of all solutions `x âˆˆ Real^n` is a convex cone. -/
theorem convexCone_solutionSet_homogeneous_linearComparison {Î¹ : Sort*} (n : Nat)
    (b : Î¹ â†’ Fin n â†’ Real) (rel : Î¹ â†’ LinearComparison) :
    IsConvexCone n
      {x : Fin n â†’ Real | âˆ€ i, x âˆˆ linearComparisonSet n (b i) (0 : Real) (rel i)} := by
  have hK : âˆ€ i, IsConvexCone n (linearComparisonSet n (b i) (0 : Real) (rel i)) := fun i =>
    convexCone_linearComparisonSet_zero n (b i) (rel i)
  simpa [solutionSet_linearComparison_eq_iInter (n := n) (b := b) (Î² := fun _ => (0 : Real))
    (rel := rel)] using
    (convexCone_iInter_family (n := n)
      (K := fun i => linearComparisonSet n (b i) (0 : Real) (rel i)) hK)

/-- A submodule (linear subspace) is closed under addition. -/
lemma submodule_add_closed (n : Nat) (S : Submodule Real (Fin n â†’ Real)) :
    âˆ€ x âˆˆ (S : Set (Fin n â†’ Real)), âˆ€ y âˆˆ (S : Set (Fin n â†’ Real)), x + y âˆˆ (S : Set (Fin n â†’ Real)) := by
  intro x hx y hy
  exact S.add_mem hx hy

/-- A submodule (linear subspace) is closed under positive scalar multiplication. -/
lemma submodule_pos_smul_closed (n : Nat) (S : Submodule Real (Fin n â†’ Real)) :
    âˆ€ x âˆˆ (S : Set (Fin n â†’ Real)), âˆ€ t : Real, 0 < t â†’ t â€¢ x âˆˆ (S : Set (Fin n â†’ Real)) := by
  intro x hx t _ht
  exact S.smul_mem t hx

/-- Proposition 2.5.14. Every linear subspace of `Real^n` is a convex cone. -/
theorem submodule_isConvexCone (n : Nat) (S : Submodule Real (Fin n â†’ Real)) :
    IsConvexCone n (S : Set (Fin n â†’ Real)) := by
  refine (isConvexCone_iff_add_closed_and_pos_smul_closed n (S : Set (Fin n â†’ Real))).2 ?_
  exact âŸ¨submodule_add_closed n S, submodule_pos_smul_closed n SâŸ©

/-- The nonnegative orthant is closed under addition. -/
lemma nonNegativeOrthant_add_mem (n : Nat) :
    âˆ€ x âˆˆ nonNegativeOrthant n, âˆ€ y âˆˆ nonNegativeOrthant n, x + y âˆˆ nonNegativeOrthant n := by
  intro x hx y hy
  simp [nonNegativeOrthant] at hx hy âŠ¢
  intro i
  exact add_nonneg (hx i) (hy i)

/-- The nonnegative orthant is closed under positive scalar multiplication. -/
lemma nonNegativeOrthant_pos_smul_mem (n : Nat) :
    âˆ€ x âˆˆ nonNegativeOrthant n, âˆ€ t : Real, 0 < t â†’ t â€¢ x âˆˆ nonNegativeOrthant n := by
  intro x hx t ht
  simp [nonNegativeOrthant] at hx âŠ¢
  intro i
  have : 0 â‰¤ t * x i := mul_nonneg (le_of_lt ht) (hx i)
  simpa [smul_eq_mul] using this

/-- The positive orthant is closed under addition. -/
lemma positiveOrthant_add_mem (n : Nat) :
    âˆ€ x âˆˆ positiveOrthant n, âˆ€ y âˆˆ positiveOrthant n, x + y âˆˆ positiveOrthant n := by
  intro x hx y hy
  simp [positiveOrthant] at hx hy âŠ¢
  intro i
  exact add_pos (hx i) (hy i)

/-- The positive orthant is closed under positive scalar multiplication. -/
lemma positiveOrthant_pos_smul_mem (n : Nat) :
    âˆ€ x âˆˆ positiveOrthant n, âˆ€ t : Real, 0 < t â†’ t â€¢ x âˆˆ positiveOrthant n := by
  intro x hx t ht
  simp [positiveOrthant] at hx âŠ¢
  intro i
  have : 0 < t * x i := mul_pos ht (hx i)
  simpa [smul_eq_mul] using this

/-- Proposition 2.5.15. The non-negative orthant and the positive orthant of `Real^n`
are convex cones. -/
theorem orthants_isConvexCone (n : Nat) :
    IsConvexCone n (nonNegativeOrthant n) âˆ§ IsConvexCone n (positiveOrthant n) := by
  refine âŸ¨?_, ?_âŸ©
  Â· refine (isConvexCone_iff_add_closed_and_pos_smul_closed n (nonNegativeOrthant n)).2 ?_
    exact âŸ¨nonNegativeOrthant_add_mem n, nonNegativeOrthant_pos_smul_mem nâŸ©
  Â· refine (isConvexCone_iff_add_closed_and_pos_smul_closed n (positiveOrthant n)).2 ?_
    exact âŸ¨positiveOrthant_add_mem n, positiveOrthant_pos_smul_mem nâŸ©

/-- Proposition 2.5.16. The open and closed half-spaces corresponding to a hyperplane through
the origin are convex cones. Concretely, for `b : Real^n`, the hyperplane `{x | âŸªx, bâŸ« = 0}`
has associated closed half-spaces `{x | âŸªx, bâŸ« â‰¤ 0}`, `{x | âŸªx, bâŸ« â‰¥ 0}` and open half-spaces
`{x | âŸªx, bâŸ« < 0}`, `{x | âŸªx, bâŸ« > 0}`. -/
theorem halfSpaces_through_origin_isConvexCone (n : Nat) (b : Fin n â†’ Real) :
    IsConvexCone n (closedHalfSpaceLE n b (0 : Real)) âˆ§
      IsConvexCone n (closedHalfSpaceGE n b (0 : Real)) âˆ§
      IsConvexCone n (openHalfSpaceLT n b (0 : Real)) âˆ§
      IsConvexCone n (openHalfSpaceGT n b (0 : Real)) := by
  refine âŸ¨?_, ?_âŸ©
  Â· simpa [closedHalfSpaceLE] using
      (convexCone_of_dotProduct_le_zero (Î¹ := Unit) (n := n) (b := fun _ : Unit => b))
  refine âŸ¨?_, ?_âŸ©
  Â· simpa [closedHalfSpaceGE, ge_iff_le] using
      (convexCone_of_dotProduct_ge_zero (Î¹ := Unit) (n := n) (b := fun _ : Unit => b))
  refine âŸ¨?_, ?_âŸ©
  Â· simpa [openHalfSpaceLT] using
      (convexCone_of_dotProduct_lt_zero (Î¹ := Unit) (n := n) (b := fun _ : Unit => b))
  Â· simpa [openHalfSpaceGT, gt_iff_lt] using
      (convexCone_of_dotProduct_pos (Î¹ := Unit) (n := n) (b := fun _ : Unit => b))

/-- Reading off the `0`-th coordinate of a `Fin.cons` equality gives the normalization
`âˆ‘ w = 1`. -/
lemma convexConeSection_sum_weights_eq_one_of_cons_eq {n m : Nat}
    {y : Fin n â†’ Real} {x : Fin (m + 1) â†’ Fin n â†’ Real} {w : Fin (m + 1) â†’ Real}
    (h :
      (Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) y) =
        âˆ‘ i : Fin (m + 1),
          w i â€¢ (Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) (x i))) :
    (âˆ‘ i : Fin (m + 1), w i) = 1 := by
  have h0 := congrArg (fun f : Fin (n + 1) â†’ Real => f 0) h
  have : (1 : Real) = âˆ‘ i : Fin (m + 1), w i := by
    simpa [Finset.sum_apply, smul_eq_mul, mul_assoc] using h0
  simpa using this.symm

/-- Reading off the tail coordinates of a `Fin.cons` equality gives the corresponding
weighted-sum identity in `Fin n â†’ â„`. -/
lemma convexConeSection_tail_eq_sum_smul_of_cons_eq {n m : Nat}
    {y : Fin n â†’ Real} {x : Fin (m + 1) â†’ Fin n â†’ Real} {w : Fin (m + 1) â†’ Real}
    (h :
      (Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) y) =
        âˆ‘ i : Fin (m + 1),
          w i â€¢ (Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) (x i))) :
    y = âˆ‘ i : Fin (m + 1), w i â€¢ x i := by
  funext j
  have hj := congrArg (fun f : Fin (n + 1) â†’ Real => f (Fin.succ j)) h
  simpa [Finset.sum_apply, smul_eq_mul, mul_assoc] using hj

/-- Proposition 2.6.12. Every convex set `C âŠ† â„^n` can be realized as a cross-section of a
convex cone in a higher-dimensional space: there exists a convex cone `K âŠ† â„^{n+1}` such that
`C = {x âˆˆ â„^n | (1, x) âˆˆ K}`. -/
theorem exists_convexCone_section_eq (n : Nat) (C : Set (Fin n â†’ Real)) (hC : Convex Real C) :
    âˆƒ K : Set (Fin (n + 1) â†’ Real),
      IsConvexCone (n + 1) K âˆ§ C = {x : Fin n â†’ Real | Fin.cons (n := n) (1 : Real) x âˆˆ K} := by
  classical
  let S : Set (Fin (n + 1) â†’ Real) :=
    {z : Fin (n + 1) â†’ Real | âˆƒ x âˆˆ C, z = Fin.cons (n := n) (1 : Real) x}
  let K : Set (Fin (n + 1) â†’ Real) :=
    {y : Fin (n + 1) â†’ Real |
      âˆƒ m : Nat, âˆƒ x : Fin (m + 1) â†’ Fin (n + 1) â†’ Real, âˆƒ w : Fin (m + 1) â†’ Real,
        (âˆ€ i, x i âˆˆ S) âˆ§ (âˆ€ i, 0 < w i) âˆ§ y = âˆ‘ i, w i â€¢ x i}
  have hKdata :
      IsConvexCone (n + 1) K âˆ§ S âŠ† K âˆ§
        âˆ€ K' : Set (Fin (n + 1) â†’ Real), IsConvexCone (n + 1) K' â†’ S âŠ† K' â†’ K âŠ† K' := by
    simpa [K, S] using (positiveLinearCombinationCone_isSmallest (n := n + 1) S)
  refine âŸ¨K, hKdata.1, ?_âŸ©
  ext y
  constructor
  Â· intro hyC
    have hyS :
        Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) y âˆˆ S := âŸ¨y, hyC, rflâŸ©
    exact hKdata.2.1 hyS
  Â· intro hyK
    have hyK' :
        âˆƒ m : Nat, âˆƒ x : Fin (m + 1) â†’ Fin (n + 1) â†’ Real, âˆƒ w : Fin (m + 1) â†’ Real,
          (âˆ€ i, x i âˆˆ S) âˆ§ (âˆ€ i, 0 < w i) âˆ§
            Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) y =
              âˆ‘ i, w i â€¢ x i := by
      simpa [K] using hyK
    rcases hyK' with âŸ¨m, x, w, hxS, hwpos, hsumâŸ©
    have hxrepr :
        âˆ€ i : Fin (m + 1),
          âˆƒ xi : Fin n â†’ Real, xi âˆˆ C âˆ§
            x i = Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) xi := by
      intro i
      rcases hxS i with âŸ¨xi, hxiC, hxiâŸ©
      exact âŸ¨xi, hxiC, hxiâŸ©
    choose xC hxC hxEq using hxrepr
    have hsum' :
        Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) y =
          âˆ‘ i : Fin (m + 1),
            w i â€¢
              (Fin.cons (n := n) (Î± := fun _ : Fin (n + 1) => Real) (1 : Real) (xC i)) := by
      simpa [hxEq] using hsum
    have hwsum : (âˆ‘ i : Fin (m + 1), w i) = 1 :=
      convexConeSection_sum_weights_eq_one_of_cons_eq (n := n) (m := m) (y := y) (x := xC)
        (w := w) hsum'
    have hy_eq : y = âˆ‘ i : Fin (m + 1), w i â€¢ xC i :=
      convexConeSection_tail_eq_sum_smul_of_cons_eq (n := n) (m := m) (y := y) (x := xC)
        (w := w) hsum'
    have hy_mem :
        (âˆ‘ i : Fin (m + 1), w i â€¢ xC i) âˆˆ C := by
      refine hC.sum_mem ?_ ?_ ?_
      Â· intro i hi
        exact le_of_lt (hwpos i)
      Â· simpa using hwsum
      Â· intro i hi
        exact hxC i
    simpa [hy_eq] using hy_mem

end Section02
end Chap01
