import Mathlib
import ConvexAnalysis_Rockafellar_1970.Chapters.Chap04.section19_part5

open scoped BigOperators
open scoped Pointwise
open Topology

section Chap19
section Section19

/-- Helper for Corollary 19.1.2: in `EReal`, if a nonempty closed set has infimum a finite real
value, then that value belongs to the set. -/
lemma helperForCorollary_19_1_2_mem_of_sInf_eq_real_of_closed
    {S : Set EReal} {r : ‚Ñù}
    (hSnonempty : S.Nonempty)
    (hSclosed : IsClosed S)
    (hsInf_real : sInf S = (r : EReal)) :
    (r : EReal) ‚àà S := by
  have hsInf_mem : sInf S ‚àà S := IsClosed.sInf_mem hSnonempty hSclosed
  simpa [hsInf_real] using hsInf_mem

/-- Helper for Corollary 19.1.2: extract finite indexed point and ray generator families for the
transformed epigraph from `IsFinitelyGeneratedConvexSet`. -/
lemma helperForCorollary_19_1_2_unpack_mixedHull_generators_for_transformedEpigraph_extractData
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hfg_epi :
      IsFinitelyGeneratedConvexSet (n + 1)
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) :
    ‚àÉ (k m : ‚Ñï) (p : Fin k ‚Üí Fin (n + 1) ‚Üí ‚Ñù) (d : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù),
      ((fun q => (prodLinearEquiv_append_coord (n := n)) q) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) =
        mixedConvexHull (n := n + 1) (Set.range p) (Set.range d) := by
  classical
  rcases hfg_epi with ‚ü®S‚ÇÄ, S‚ÇÅ, hS‚ÇÄfin, hS‚ÇÅfin, hEq‚ü©
  let I‚ÇÄ : Type := {x : Fin (n + 1) ‚Üí ‚Ñù // x ‚àà S‚ÇÄ}
  let I‚ÇÅ : Type := {x : Fin (n + 1) ‚Üí ‚Ñù // x ‚àà S‚ÇÅ}
  letI : Fintype I‚ÇÄ := hS‚ÇÄfin.fintype
  letI : Fintype I‚ÇÅ := hS‚ÇÅfin.fintype
  let e‚ÇÄ : I‚ÇÄ ‚âÉ Fin (Fintype.card I‚ÇÄ) := Fintype.equivFin I‚ÇÄ
  let e‚ÇÅ : I‚ÇÅ ‚âÉ Fin (Fintype.card I‚ÇÅ) := Fintype.equivFin I‚ÇÅ
  let p : Fin (Fintype.card I‚ÇÄ) ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
    fun i => (e‚ÇÄ.symm i).1
  let d : Fin (Fintype.card I‚ÇÅ) ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
    fun j => (e‚ÇÅ.symm j).1
  have hRangeP : Set.range p = S‚ÇÄ := by
    ext x
    constructor
    ¬∑ rintro ‚ü®i, rfl‚ü©
      exact (e‚ÇÄ.symm i).2
    ¬∑ intro hx
      refine ‚ü®e‚ÇÄ ‚ü®x, hx‚ü©, ?_‚ü©
      simp [p]
  have hRangeD : Set.range d = S‚ÇÅ := by
    ext x
    constructor
    ¬∑ rintro ‚ü®j, rfl‚ü©
      exact (e‚ÇÅ.symm j).2
    ¬∑ intro hx
      refine ‚ü®e‚ÇÅ ‚ü®x, hx‚ü©, ?_‚ü©
      simp [d]
  refine ‚ü®Fintype.card I‚ÇÄ, Fintype.card I‚ÇÅ, p, d, ?_‚ü©
  simpa [hRangeP, hRangeD] using hEq

/-- Helper for Corollary 19.1.2: from membership in a mixed convex hull generated by finite
families, extract fixed-index coefficient functions on those families. -/
lemma helperForCorollary_19_1_2_exists_fixedCoeffs_of_mem_mixedConvexHull_range
    {n k m : ‚Ñï} (p : Fin k ‚Üí Fin n ‚Üí ‚Ñù) (d : Fin m ‚Üí Fin n ‚Üí ‚Ñù) {y : Fin n ‚Üí ‚Ñù}
    (hy : y ‚àà mixedConvexHull (n := n) (Set.range p) (Set.range d)) :
    ‚àÉ a : Fin k ‚Üí ‚Ñù, ‚àÉ b : Fin m ‚Üí ‚Ñù,
      (‚àÄ i, 0 ‚â§ a i) ‚àß
      (‚àÄ j, 0 ‚â§ b j) ‚àß
      (‚àë i, a i) = 1 ‚àß
      y = (‚àë i, a i ‚Ä¢ p i) + (‚àë j, b j ‚Ä¢ d j) := by
  classical
  rcases
      exists_strict_mixedConvexCombination_of_mem_mixedConvexHull
        (n := n) (S‚ÇÄ := Set.range p) (S‚ÇÅ := Set.range d) (x := y) hy with
    ‚ü®k', m', p', d', a', b', hp', hd', ha', hb', hsum', hy'‚ü©
  choose ip hip using hp'
  choose id hid using hd'
  let a : Fin k ‚Üí ‚Ñù :=
    fun i =>
      Finset.sum (Finset.univ.filter (fun u : Fin k' => ip u = i)) (fun t => a' t)
  let b : Fin m ‚Üí ‚Ñù :=
    fun j =>
      Finset.sum (Finset.univ.filter (fun u : Fin m' => id u = j)) (fun t => b' t)
  have ha_nonneg : ‚àÄ i, 0 ‚â§ a i := by
    intro i
    unfold a
    refine Finset.sum_nonneg ?_
    intro t ht
    exact le_of_lt (ha' t)
  have hb_nonneg : ‚àÄ j, 0 ‚â§ b j := by
    intro j
    unfold b
    refine Finset.sum_nonneg ?_
    intro t ht
    exact le_of_lt (hb' t)
  have hsum_a : (‚àë i, a i) = 1 := by
    unfold a
    calc
      (‚àë i, Finset.sum (Finset.univ.filter (fun u : Fin k' => ip u = i)) (fun t => a' t))
          = ‚àë i, ‚àë t, (if ip t = i then a' t else 0) := by
              refine Finset.sum_congr rfl ?_
              intro i hi
              simpa using
                (Finset.sum_filter (s := (Finset.univ : Finset (Fin k')))
                  (p := fun u : Fin k' => ip u = i) (f := fun t : Fin k' => a' t))
      _ = ‚àë t, ‚àë i, (if ip t = i then a' t else 0) := by
            simpa [Finset.sum_comm]
      _ = ‚àë t, a' t := by
            refine Finset.sum_congr rfl ?_
            intro t ht
            simp
      _ = 1 := hsum'
  have hsum_points :
      (‚àë i, a i ‚Ä¢ p i) = ‚àë t, a' t ‚Ä¢ p (ip t) := by
    unfold a
    calc
      (‚àë i,
        (Finset.sum (Finset.univ.filter (fun u : Fin k' => ip u = i)) (fun t => a' t)) ‚Ä¢ p i)
          = ‚àë i, Finset.sum (Finset.univ.filter (fun u : Fin k' => ip u = i))
              (fun t => a' t ‚Ä¢ p i) := by
              refine Finset.sum_congr rfl ?_
              intro i hi
              simpa using
                (Finset.sum_smul
                  (s := Finset.univ.filter (fun u : Fin k' => ip u = i))
                  (f := fun t : Fin k' => a' t) (x := p i))
      _ = ‚àë i, ‚àë t, (if ip t = i then a' t ‚Ä¢ p i else 0) := by
            refine Finset.sum_congr rfl ?_
            intro i hi
            simpa using
              (Finset.sum_filter (s := (Finset.univ : Finset (Fin k')))
                (p := fun u : Fin k' => ip u = i)
                (f := fun t : Fin k' => a' t ‚Ä¢ p i))
      _ = ‚àë t, ‚àë i, (if ip t = i then a' t ‚Ä¢ p i else 0) := by
            simpa [Finset.sum_comm]
      _ = ‚àë t, a' t ‚Ä¢ p (ip t) := by
            refine Finset.sum_congr rfl ?_
            intro t ht
            simp
  have hsum_dirs :
      (‚àë j, b j ‚Ä¢ d j) = ‚àë t, b' t ‚Ä¢ d (id t) := by
    unfold b
    calc
      (‚àë j,
        (Finset.sum (Finset.univ.filter (fun u : Fin m' => id u = j)) (fun t => b' t)) ‚Ä¢ d j)
          = ‚àë j, Finset.sum (Finset.univ.filter (fun u : Fin m' => id u = j))
              (fun t => b' t ‚Ä¢ d j) := by
              refine Finset.sum_congr rfl ?_
              intro j hj
              simpa using
                (Finset.sum_smul
                  (s := Finset.univ.filter (fun u : Fin m' => id u = j))
                  (f := fun t : Fin m' => b' t) (x := d j))
      _ = ‚àë j, ‚àë t, (if id t = j then b' t ‚Ä¢ d j else 0) := by
            refine Finset.sum_congr rfl ?_
            intro j hj
            simpa using
              (Finset.sum_filter (s := (Finset.univ : Finset (Fin m')))
                (p := fun u : Fin m' => id u = j)
                (f := fun t : Fin m' => b' t ‚Ä¢ d j))
      _ = ‚àë t, ‚àë j, (if id t = j then b' t ‚Ä¢ d j else 0) := by
            simpa [Finset.sum_comm]
      _ = ‚àë t, b' t ‚Ä¢ d (id t) := by
            refine Finset.sum_congr rfl ?_
            intro t ht
            simp
  have hsum_points' :
      (‚àë t, a' t ‚Ä¢ p (ip t)) = (‚àë t, a' t ‚Ä¢ p' t) := by
    refine Finset.sum_congr rfl ?_
    intro t ht
    simpa [hip t]
  have hsum_dirs' :
      (‚àë t, b' t ‚Ä¢ d (id t)) = (‚àë t, b' t ‚Ä¢ d' t) := by
    refine Finset.sum_congr rfl ?_
    intro t ht
    simpa [hid t]
  refine ‚ü®a, b, ha_nonneg, hb_nonneg, hsum_a, ?_‚ü©
  calc
    y = (‚àë t, a' t ‚Ä¢ p' t) + (‚àë t, b' t ‚Ä¢ d' t) := hy'
    _ = (‚àë t, a' t ‚Ä¢ p (ip t)) + (‚àë t, b' t ‚Ä¢ d (id t)) := by
          simp [hsum_points', hsum_dirs']
    _ = (‚àë i, a i ‚Ä¢ p i) + (‚àë j, b j ‚Ä¢ d j) := by
          simp [hsum_points, hsum_dirs]

/-- Helper for Corollary 19.1.2: linear maps send mixed convex hulls generated by finite
families to mixed convex hulls generated by the mapped families. -/
lemma helperForCorollary_19_1_2_linearImage_mixedConvexHull_range
    {n p k m : ‚Ñï}
    (L : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] (Fin p ‚Üí ‚Ñù))
    (pointGen : Fin k ‚Üí Fin n ‚Üí ‚Ñù)
    (dirGen : Fin m ‚Üí Fin n ‚Üí ‚Ñù) :
    L '' mixedConvexHull (n := n) (Set.range pointGen) (Set.range dirGen) =
      mixedConvexHull (n := p)
        (Set.range (fun i => L (pointGen i)))
        (Set.range (fun j => L (dirGen j))) := by
  ext y
  constructor
  ¬∑ intro hy
    rcases hy with ‚ü®x, hx, rfl‚ü©
    rcases
        helperForCorollary_19_1_2_exists_fixedCoeffs_of_mem_mixedConvexHull_range
          (n := n) (k := k) (m := m) pointGen dirGen hx with
      ‚ü®a, b, ha_nonneg, hb_nonneg, hsum_a, hx_repr‚ü©
    have hLx_repr :
        L x = (‚àë i, a i ‚Ä¢ L (pointGen i)) + (‚àë j, b j ‚Ä¢ L (dirGen j)) := by
      calc
        L x = L ((‚àë i, a i ‚Ä¢ pointGen i) + (‚àë j, b j ‚Ä¢ dirGen j)) := by
              simpa [hx_repr]
        _ = L (‚àë i, a i ‚Ä¢ pointGen i) + L (‚àë j, b j ‚Ä¢ dirGen j) := by
              simp
        _ = (‚àë i, a i ‚Ä¢ L (pointGen i)) + (‚àë j, b j ‚Ä¢ L (dirGen j)) := by
              simp
    exact
      mem_mixedConvexHull_range_of_exists_coeffs
        (n := p) (p := fun i => L (pointGen i)) (d := fun j => L (dirGen j))
        (y := L x) a b ha_nonneg hb_nonneg hsum_a hLx_repr
  ¬∑ intro hy
    rcases
        helperForCorollary_19_1_2_exists_fixedCoeffs_of_mem_mixedConvexHull_range
          (n := p) (k := k) (m := m)
          (fun i => L (pointGen i))
          (fun j => L (dirGen j)) hy with
      ‚ü®a, b, ha_nonneg, hb_nonneg, hsum_a, hy_repr‚ü©
    let x : Fin n ‚Üí ‚Ñù :=
      (‚àë i, a i ‚Ä¢ pointGen i) + (‚àë j, b j ‚Ä¢ dirGen j)
    have hx_mixed :
        x ‚àà mixedConvexHull (n := n) (Set.range pointGen) (Set.range dirGen) :=
      mem_mixedConvexHull_range_of_exists_coeffs
        (n := n) (p := pointGen) (d := dirGen)
        (y := x) a b ha_nonneg hb_nonneg hsum_a rfl
    have hLx : L x = y := by
      calc
        L x = (‚àë i, a i ‚Ä¢ L (pointGen i)) + (‚àë j, b j ‚Ä¢ L (dirGen j)) := by
              simp [x]
        _ = y := by
              simpa [hy_repr] using hy_repr.symm
    exact ‚ü®x, hx_mixed, hLx‚ü©

/-- Helper for Corollary 19.1.2: linear images of finitely generated convex sets remain
finitely generated. -/
lemma helperForCorollary_19_1_2_linearImage_finitelyGeneratedSet
    {n p : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)}
    (hfg : IsFinitelyGeneratedConvexSet n C)
    (L : (Fin n ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] (Fin p ‚Üí ‚Ñù)) :
    IsFinitelyGeneratedConvexSet p (L '' C) := by
  classical
  rcases hfg with ‚ü®S‚ÇÄ, S‚ÇÅ, hS‚ÇÄfinite, hS‚ÇÅfinite, hEqC‚ü©
  let I‚ÇÄ : Type := {x : Fin n ‚Üí ‚Ñù // x ‚àà S‚ÇÄ}
  let I‚ÇÅ : Type := {x : Fin n ‚Üí ‚Ñù // x ‚àà S‚ÇÅ}
  letI : Fintype I‚ÇÄ := hS‚ÇÄfinite.fintype
  letI : Fintype I‚ÇÅ := hS‚ÇÅfinite.fintype
  let e‚ÇÄ : I‚ÇÄ ‚âÉ Fin (Fintype.card I‚ÇÄ) := Fintype.equivFin I‚ÇÄ
  let e‚ÇÅ : I‚ÇÅ ‚âÉ Fin (Fintype.card I‚ÇÅ) := Fintype.equivFin I‚ÇÅ
  let pointGen : Fin (Fintype.card I‚ÇÄ) ‚Üí Fin n ‚Üí ‚Ñù :=
    fun i => (e‚ÇÄ.symm i).1
  let dirGen : Fin (Fintype.card I‚ÇÅ) ‚Üí Fin n ‚Üí ‚Ñù :=
    fun j => (e‚ÇÅ.symm j).1
  have hRangePoint : Set.range pointGen = S‚ÇÄ := by
    ext x
    constructor
    ¬∑ rintro ‚ü®i, rfl‚ü©
      exact (e‚ÇÄ.symm i).2
    ¬∑ intro hx
      refine ‚ü®e‚ÇÄ ‚ü®x, hx‚ü©, ?_‚ü©
      simp [pointGen]
  have hRangeDir : Set.range dirGen = S‚ÇÅ := by
    ext x
    constructor
    ¬∑ rintro ‚ü®j, rfl‚ü©
      exact (e‚ÇÅ.symm j).2
    ¬∑ intro hx
      refine ‚ü®e‚ÇÅ ‚ü®x, hx‚ü©, ?_‚ü©
      simp [dirGen]
  have hEqC' :
      C = mixedConvexHull (n := n) (Set.range pointGen) (Set.range dirGen) := by
    simpa [hRangePoint, hRangeDir] using hEqC
  have hImageEq :
      L '' C =
        mixedConvexHull (n := p)
          (Set.range (fun i => L (pointGen i)))
          (Set.range (fun j => L (dirGen j))) := by
    calc
      L '' C =
          L '' mixedConvexHull (n := n) (Set.range pointGen) (Set.range dirGen) := by
            simpa [hEqC']
      _ =
          mixedConvexHull (n := p)
            (Set.range (fun i => L (pointGen i)))
            (Set.range (fun j => L (dirGen j))) :=
            helperForCorollary_19_1_2_linearImage_mixedConvexHull_range
              (n := n) (p := p)
              (k := Fintype.card I‚ÇÄ) (m := Fintype.card I‚ÇÅ)
              L pointGen dirGen
  refine ‚ü®Set.range (fun i => L (pointGen i)), Set.range (fun j => L (dirGen j)),
    Set.finite_range _, Set.finite_range _, ?_‚ü©
  exact hImageEq

/-- Helper for Corollary 19.1.2: decode fixed-index mixed-hull coefficients in transformed
epigraph coordinates into Text 19.0.10 coefficient data. -/
lemma helperForCorollary_19_1_2_decode_transformedGeneratorCoeffs_to_Text19_0_10_lam
    {n k' m' : ‚Ñï}
    (p : Fin k' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    (d : Fin m' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    {a' : Fin k' ‚Üí ‚Ñù} {b' : Fin m' ‚Üí ‚Ñù}
    (ha_nonneg : ‚àÄ i, 0 ‚â§ a' i)
    (hb_nonneg : ‚àÄ j, 0 ‚â§ b' j)
    (hsum_a : (‚àë i, a' i) = 1)
    (hy_repr :
      (prodLinearEquiv_append_coord (n := n)) (x, Œº) =
        (‚àë i, a' i ‚Ä¢ p i) + (‚àë j, b' j ‚Ä¢ d j)) :
    ‚àÉ (lam : Fin (k' + m') ‚Üí ‚Ñù),
      (‚àÄ j0,
        (‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).1)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).1)
              i) j0) = x j0) ‚àß
      (Finset.sum (Finset.univ.filter (fun i : Fin (k' + m') => (i : ‚Ñï) < k'))
        (fun i => lam i)) = 1 ‚àß
      (‚àÄ i, 0 ‚â§ lam i) ‚àß
      ((‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
              i : ‚Ñù)) = Œº) := by
  let preP : Fin k' ‚Üí (Fin n ‚Üí ‚Ñù) √ó ‚Ñù :=
    fun i => (prodLinearEquiv_append_coord (n := n)).symm (p i)
  let preD : Fin m' ‚Üí (Fin n ‚Üí ‚Ñù) √ó ‚Ñù :=
    fun j => (prodLinearEquiv_append_coord (n := n)).symm (d j)
  let aDec : Fin (k' + m') ‚Üí Fin n ‚Üí ‚Ñù :=
    Fin.append (fun i => (preP i).1) (fun j => (preD j).1)
  let Œ±Dec : Fin (k' + m') ‚Üí ‚Ñù :=
    Fin.append (fun i => (preP i).2) (fun j => (preD j).2)
  let lamDec : Fin (k' + m') ‚Üí ‚Ñù := Fin.append a' b'
  have hpair :
      (x, Œº) =
        (‚àë i, a' i ‚Ä¢ preP i) + (‚àë j, b' j ‚Ä¢ preD j) := by
    have hmap := congrArg (fun y => (prodLinearEquiv_append_coord (n := n)).symm y) hy_repr
    simpa [preP, preD] using hmap
  have hx_repr :
      x = (‚àë i, a' i ‚Ä¢ (preP i).1) + (‚àë j, b' j ‚Ä¢ (preD j).1) := by
    have hfst := congrArg Prod.fst hpair
    simpa [Prod.fst_sum, Prod.smul_fst, smul_eq_mul] using hfst
  have hŒº_repr :
      Œº = (‚àë i, a' i * (preP i).2) + (‚àë j, b' j * (preD j).2) := by
    have hsnd := congrArg Prod.snd hpair
    simpa [Prod.snd_sum, Prod.smul_snd, smul_eq_mul] using hsnd
  have hlin : ‚àÄ j0, (‚àë i, lamDec i * aDec i j0) = x j0 := by
    intro j0
    have hsplit :
        (‚àë i, lamDec i * aDec i j0) =
          (‚àë i, a' i * (preP i).1 j0) + (‚àë j, b' j * (preD j).1 j0) := by
      calc
        (‚àë i, lamDec i * aDec i j0)
            =
              (‚àë i : Fin k', lamDec (Fin.castAdd m' i) * aDec (Fin.castAdd m' i) j0) +
                (‚àë j : Fin m', lamDec (Fin.natAdd k' j) * aDec (Fin.natAdd k' j) j0) := by
                simpa using
                  (Fin.sum_univ_add
                    (f := fun i : Fin (k' + m') => lamDec i * aDec i j0))
        _ = (‚àë i, a' i * (preP i).1 j0) + (‚àë j, b' j * (preD j).1 j0) := by
              simp [lamDec, aDec]
    have hxj := congrArg (fun u : Fin n ‚Üí ‚Ñù => u j0) hx_repr
    calc
      (‚àë i, lamDec i * aDec i j0)
          = (‚àë i, a' i * (preP i).1 j0) + (‚àë j, b' j * (preD j).1 j0) := hsplit
      _ = x j0 := by
            simpa [hxj] using hxj.symm
  have hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin (k' + m') => (i : ‚Ñï) < k'))
        (fun i => lamDec i)) = 1 := by
    rw [helperForCorollary_19_1_2_sum_filter_lt_eq_sum_castAdd
      (k := k') (m := m') (g := lamDec)]
    simpa [lamDec] using hsum_a
  have hnonneg : ‚àÄ i, 0 ‚â§ lamDec i := by
    intro i
    exact Fin.addCases
      (fun i0 => by
        simpa [lamDec] using ha_nonneg i0)
      (fun j0 => by
        simpa [lamDec] using hb_nonneg j0)
      i
  have hobj : (‚àë i, lamDec i * Œ±Dec i : ‚Ñù) = Œº := by
    have hsplit :
        (‚àë i, lamDec i * Œ±Dec i : ‚Ñù) =
          (‚àë i, a' i * (preP i).2) + (‚àë j, b' j * (preD j).2) := by
      calc
        (‚àë i, lamDec i * Œ±Dec i : ‚Ñù)
            =
              (‚àë i : Fin k', lamDec (Fin.castAdd m' i) * Œ±Dec (Fin.castAdd m' i)) +
                (‚àë j : Fin m', lamDec (Fin.natAdd k' j) * Œ±Dec (Fin.natAdd k' j)) := by
                simpa using
                  (Fin.sum_univ_add
                    (f := fun i : Fin (k' + m') => lamDec i * Œ±Dec i))
        _ = (‚àë i, a' i * (preP i).2) + (‚àë j, b' j * (preD j).2) := by
              simp [lamDec, Œ±Dec]
    calc
      (‚àë i, lamDec i * Œ±Dec i : ‚Ñù)
          = (‚àë i, a' i * (preP i).2) + (‚àë j, b' j * (preD j).2) := hsplit
      _ = Œº := by
            simpa [hŒº_repr] using hŒº_repr.symm
  refine ‚ü®lamDec, ?_, hnorm, hnonneg, ?_‚ü©
  ¬∑ simpa [aDec, preP, preD] using hlin
  ¬∑ simpa [Œ±Dec, preP, preD] using hobj

/-- Helper for Corollary 19.1.2: decode mixed-hull membership in packed transformed-epigraph
coordinates into feasible Text 19.0.10 coefficients with an objective value bounded by `Œº`. -/
lemma helperForCorollary_19_1_2_unpack_packGenerators_coeffs_to_Text19_0_10_le
    {n k' m' : ‚Ñï}
    (p : Fin k' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    (d : Fin m' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hy :
      (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
        mixedConvexHull (n := n + 1) (Set.range p) (Set.range d)) :
    ‚àÉ (lam : Fin (k' + m') ‚Üí ‚Ñù) (q : ‚Ñù),
      (‚àÄ j0,
        (‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).1)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).1)
              i) j0) = x j0) ‚àß
      (Finset.sum (Finset.univ.filter (fun i : Fin (k' + m') => (i : ‚Ñï) < k'))
        (fun i => lam i)) = 1 ‚àß
      (‚àÄ i, 0 ‚â§ lam i) ‚àß
      q ‚â§ Œº ‚àß
      q =
        (‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
              i : ‚Ñù)) := by
  rcases
      helperForCorollary_19_1_2_exists_fixedCoeffs_of_mem_mixedConvexHull_range
        (n := n + 1) (k := k') (m := m') p d hy with
    ‚ü®a', b', ha_nonneg, hb_nonneg, hsum_a, hy_repr‚ü©
  rcases
      helperForCorollary_19_1_2_decode_transformedGeneratorCoeffs_to_Text19_0_10_lam
        (n := n) (k' := k') (m' := m') p d
        (x := x) (Œº := Œº) (a' := a') (b' := b')
        ha_nonneg hb_nonneg hsum_a hy_repr with
    ‚ü®lam, hlin, hnorm, hnonneg, hobj‚ü©
  let q : ‚Ñù :=
    (‚àë i,
      lam i *
        (Fin.append
          (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
          (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
          i : ‚Ñù))
  have hq_le : q ‚â§ Œº := by
    have hq_eq : q = Œº := by
      simpa [q] using hobj
    exact hq_eq.le
  exact ‚ü®lam, q, hlin, hnorm, hnonneg, hq_le, rfl‚ü©

/-- Helper for Corollary 19.1.2: unpack packed transformed-epigraph mixed-hull membership
into feasible decoded coefficients with objective value bounded above by `Œº`. -/
lemma helperForCorollary_19_1_2_unpack_packedMembership_to_Text19_0_10_le
    {n k' m' : ‚Ñï}
    (p : Fin k' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    (d : Fin m' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hy :
      (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
        mixedConvexHull (n := n + 1) (Set.range p) (Set.range d)) :
    ‚àÉ (lam : Fin (k' + m') ‚Üí ‚Ñù),
      (‚àÄ j0,
        (‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).1)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).1)
              i) j0) = x j0) ‚àß
      (Finset.sum (Finset.univ.filter (fun i : Fin (k' + m') => (i : ‚Ñï) < k'))
        (fun i => lam i)) = 1 ‚àß
      (‚àÄ i, 0 ‚â§ lam i) ‚àß
      ((‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
              i : ‚Ñù)) : EReal) ‚â§ (Œº : EReal) := by
  rcases
      helperForCorollary_19_1_2_unpack_packGenerators_coeffs_to_Text19_0_10_le
        (n := n) (k' := k') (m' := m') p d (x := x) (Œº := Œº) hy with
    ‚ü®lam, q, hlin, hnorm, hnonneg, hq_le, hq_eq‚ü©
  refine ‚ü®lam, hlin, hnorm, hnonneg, ?_‚ü©
  let Œ≤ : Fin (k' + m') ‚Üí ‚Ñù :=
    Fin.append
      (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
      (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
  have hcoe_sum :
      (‚àë i, (lam i : EReal) * (Œ≤ i : EReal)) =
        ((‚àë i, lam i * Œ≤ i : ‚Ñù) : EReal) := by
    classical
    refine Finset.induction_on (Finset.univ : Finset (Fin (k' + m'))) ?_ ?_
    ¬∑ simp
    ¬∑ intro x s hx hs
      simp [Finset.sum_insert, hx, hs, EReal.coe_add, EReal.coe_mul]
  have hq_le' : (‚àë i, lam i * Œ≤ i : ‚Ñù) ‚â§ Œº := by
    calc
      (‚àë i, lam i * Œ≤ i : ‚Ñù) = q := by
        simpa [Œ≤] using hq_eq.symm
      _ ‚â§ Œº := hq_le
  have hq_leE : ((‚àë i, lam i * Œ≤ i : ‚Ñù) : EReal) ‚â§ (Œº : EReal) := by
    exact_mod_cast hq_le'
  have hgoalE : (‚àë i, (lam i : EReal) * (Œ≤ i : EReal)) ‚â§ (Œº : EReal) := by
    rw [hcoe_sum]
    exact hq_leE
  simpa [Œ≤] using hgoalE

/-- Helper for Corollary 19.1.2: feasible decoded Text 19.0.10 coefficients transport to
membership in the mixed convex hull generated by transformed epigraph families. -/
lemma helperForCorollary_19_1_2_unpack_mixedHull_generators_for_transformedEpigraph_transport_feasible
    {n k' m' : ‚Ñï}
    (p : Fin k' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    (d : Fin m' ‚Üí Fin (n + 1) ‚Üí ‚Ñù)
    {x : Fin n ‚Üí ‚Ñù}
    {lam : Fin (k' + m') ‚Üí ‚Ñù}
    (hlin :
      ‚àÄ j0,
        (‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).1)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).1)
              i) j0) = x j0)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin (k' + m') => (i : ‚Ñï) < k'))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i) :
    (prodLinearEquiv_append_coord (n := n))
        (x, (‚àë i,
          lam i *
            (Fin.append
              (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
              (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
              i : ‚Ñù))) ‚àà
      mixedConvexHull (n := n + 1) (Set.range p) (Set.range d) := by
  let preP : Fin k' ‚Üí (Fin n ‚Üí ‚Ñù) √ó ‚Ñù :=
    fun i => (prodLinearEquiv_append_coord (n := n)).symm (p i)
  let preD : Fin m' ‚Üí (Fin n ‚Üí ‚Ñù) √ó ‚Ñù :=
    fun j => (prodLinearEquiv_append_coord (n := n)).symm (d j)
  let aDec : Fin (k' + m') ‚Üí Fin n ‚Üí ‚Ñù :=
    Fin.append (fun i => (preP i).1) (fun j => (preD j).1)
  let Œ±Dec : Fin (k' + m') ‚Üí ‚Ñù :=
    Fin.append (fun i => (preP i).2) (fun j => (preD j).2)
  let aCoeff : Fin k' ‚Üí ‚Ñù := fun i => lam (Fin.castAdd m' i)
  let bCoeff : Fin m' ‚Üí ‚Ñù := fun j => lam (Fin.natAdd k' j)
  have hlin' : ‚àÄ j0, (‚àë i, lam i * aDec i j0) = x j0 := by
    intro j0
    simpa [aDec, preP, preD] using hlin j0
  have hsum_a : (‚àë i, aCoeff i) = 1 := by
    have hnorm' := hnorm
    rw [helperForCorollary_19_1_2_sum_filter_lt_eq_sum_castAdd
      (k := k') (m := m') (g := lam)] at hnorm'
    simpa [aCoeff] using hnorm'
  have ha_nonneg : ‚àÄ i, 0 ‚â§ aCoeff i := by
    intro i
    simpa [aCoeff] using hnonneg (Fin.castAdd m' i)
  have hb_nonneg : ‚àÄ j, 0 ‚â§ bCoeff j := by
    intro j
    simpa [bCoeff] using hnonneg (Fin.natAdd k' j)
  let Œº : ‚Ñù := ‚àë i, lam i * Œ±Dec i
  have hpair :
      (x, Œº) =
        (‚àë i, aCoeff i ‚Ä¢ preP i) + (‚àë j, bCoeff j ‚Ä¢ preD j) := by
    apply Prod.ext
    ¬∑ ext j0
      have hsplit :
          (‚àë i, lam i * aDec i j0) =
            (‚àë i : Fin k', aCoeff i * (preP i).1 j0) +
              (‚àë j : Fin m', bCoeff j * (preD j).1 j0) := by
        calc
          (‚àë i, lam i * aDec i j0)
              =
                (‚àë i : Fin k', lam (Fin.castAdd m' i) * aDec (Fin.castAdd m' i) j0) +
                  (‚àë j : Fin m', lam (Fin.natAdd k' j) * aDec (Fin.natAdd k' j) j0) := by
                  simpa using
                    (Fin.sum_univ_add
                      (f := fun i : Fin (k' + m') => lam i * aDec i j0))
          _ = (‚àë i : Fin k', aCoeff i * (preP i).1 j0) +
                (‚àë j : Fin m', bCoeff j * (preD j).1 j0) := by
                simp [aCoeff, bCoeff, aDec, preP, preD]
      have hxj : x j0 = (‚àë i, lam i * aDec i j0) := by
        simpa [hlin' j0] using (hlin' j0).symm
      calc
        x j0 = (‚àë i, lam i * aDec i j0) := hxj
        _ =
            (‚àë i : Fin k', aCoeff i * (preP i).1 j0) +
              (‚àë j : Fin m', bCoeff j * (preD j).1 j0) := hsplit
        _ =
            ((
              (‚àë i, aCoeff i ‚Ä¢ preP i) +
                (‚àë j, bCoeff j ‚Ä¢ preD j)).1) j0 := by
              simp [Prod.fst_sum, Prod.smul_fst, smul_eq_mul]
    ¬∑ have hsplit :
          Œº =
            (‚àë i : Fin k', aCoeff i * (preP i).2) +
              (‚àë j : Fin m', bCoeff j * (preD j).2) := by
        calc
          Œº = ‚àë i, lam i * Œ±Dec i := rfl
          _ =
              (‚àë i : Fin k', lam (Fin.castAdd m' i) * Œ±Dec (Fin.castAdd m' i)) +
                (‚àë j : Fin m', lam (Fin.natAdd k' j) * Œ±Dec (Fin.natAdd k' j)) := by
                simpa using
                  (Fin.sum_univ_add
                    (f := fun i : Fin (k' + m') => lam i * Œ±Dec i))
          _ =
              (‚àë i : Fin k', aCoeff i * (preP i).2) +
                (‚àë j : Fin m', bCoeff j * (preD j).2) := by
                simp [aCoeff, bCoeff, Œ±Dec, preP, preD]
      calc
        Œº =
            (‚àë i : Fin k', aCoeff i * (preP i).2) +
              (‚àë j : Fin m', bCoeff j * (preD j).2) := hsplit
        _ =
            ((
              (‚àë i, aCoeff i ‚Ä¢ preP i) +
                (‚àë j, bCoeff j ‚Ä¢ preD j)).2) := by
              simp [Prod.snd_sum, Prod.smul_snd, smul_eq_mul]
  have hy_repr :
      (prodLinearEquiv_append_coord (n := n)) (x, Œº) =
        (‚àë i, aCoeff i ‚Ä¢ p i) + (‚àë j, bCoeff j ‚Ä¢ d j) := by
    have hmap := congrArg (prodLinearEquiv_append_coord (n := n)) hpair
    simpa [preP, preD] using hmap
  exact
    mem_mixedConvexHull_range_of_exists_coeffs
      (n := n + 1) (p := p) (d := d)
      (y := (prodLinearEquiv_append_coord (n := n)) (x, Œº))
      aCoeff bCoeff ha_nonneg hb_nonneg hsum_a hy_repr

/-- Helper for Corollary 19.1.2: unpacking transformed-epigraph finite-generation data into
the coefficient representation of Text 19.0.10. -/
lemma helperForCorollary_19_1_2_unpack_mixedHull_generators_for_transformedEpigraph
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hfg_epi :
      IsFinitelyGeneratedConvexSet (n + 1)
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) :
    ‚àÉ (k m : ‚Ñï) (a : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ± : Fin m ‚Üí ‚Ñù),
      k ‚â§ m ‚àß
        ‚àÄ x,
          f x =
            sInf {r : EReal |
              ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
                (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
                (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                  (fun i => lam i)) = 1 ‚àß
                (‚àÄ i, 0 ‚â§ lam i) ‚àß
                r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)} := by
  rcases
      helperForCorollary_19_1_2_unpack_mixedHull_generators_for_transformedEpigraph_extractData
        (n := n) (f := f) hfg_epi with
    ‚ü®k', m', p, d, hEq_mixed‚ü©
  have hEq_mixed' :
      ((fun q => (prodLinearEquiv_append_coord (n := n)) q) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) =
        mixedConvexHull (n := n + 1) (Set.range p) (Set.range d) := hEq_mixed
  clear hEq_mixed
  have hfixedCoeffs :
      ‚àÄ {y : Fin (n + 1) ‚Üí ‚Ñù},
        y ‚àà mixedConvexHull (n := n + 1) (Set.range p) (Set.range d) ‚Üí
        ‚àÉ a' : Fin k' ‚Üí ‚Ñù, ‚àÉ b' : Fin m' ‚Üí ‚Ñù,
          (‚àÄ i, 0 ‚â§ a' i) ‚àß
          (‚àÄ j, 0 ‚â§ b' j) ‚àß
          (‚àë i, a' i) = 1 ‚àß
          y = (‚àë i, a' i ‚Ä¢ p i) + (‚àë j, b' j ‚Ä¢ d j) := by
    intro y hy
    exact
      helperForCorollary_19_1_2_exists_fixedCoeffs_of_mem_mixedConvexHull_range
        (n := n + 1) (k := k') (m := m') p d hy
  let aDec : Fin (k' + m') ‚Üí Fin n ‚Üí ‚Ñù :=
    Fin.append
      (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).1)
      (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).1)
  let Œ±Dec : Fin (k' + m') ‚Üí ‚Ñù :=
    Fin.append
      (fun i => ((prodLinearEquiv_append_coord (n := n)).symm (p i)).2)
      (fun j => ((prodLinearEquiv_append_coord (n := n)).symm (d j)).2)
  refine ‚ü®k', k' + m', aDec, Œ±Dec, Nat.le_add_right k' m', ?_‚ü©
  intro x
  let Sx : Set EReal :=
    {r : EReal |
      ‚àÉ (lam : Fin (k' + m') ‚Üí ‚Ñù),
        (‚àÄ j,
          (‚àë i, lam i * aDec i j) = x j) ‚àß
        (Finset.sum (Finset.univ.filter (fun i : Fin (k' + m') => (i : ‚Ñï) < k'))
          (fun i => lam i)) = 1 ‚àß
        (‚àÄ i, 0 ‚â§ lam i) ‚àß
        r = ((‚àë i, lam i * Œ±Dec i : ‚Ñù) : EReal)}
  have hfx_le_sInf : f x ‚â§ sInf Sx := by
    refine le_sInf ?_
    intro r hrSx
    rcases hrSx with ‚ü®lam, hlin, hnorm, hnonneg, hrEq‚ü©
    let Œº : ‚Ñù := ‚àë i, lam i * Œ±Dec i
    have hmem_mixed :
        (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
          mixedConvexHull (n := n + 1) (Set.range p) (Set.range d) := by
      exact
        helperForCorollary_19_1_2_unpack_mixedHull_generators_for_transformedEpigraph_transport_feasible
          (n := n) (k' := k') (m' := m') p d
          (x := x) (lam := lam) hlin hnorm hnonneg
    have hmem_img :
        (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
          ((fun q => (prodLinearEquiv_append_coord (n := n)) q) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
      simpa [hEq_mixed'] using hmem_mixed
    rcases hmem_img with ‚ü®q, hqepi, hqeq‚ü©
    have hq_pair : q = (x, Œº) := by
      apply (prodLinearEquiv_append_coord (n := n)).injective
      simpa using hqeq
    have hleŒº : f x ‚â§ (Œº : EReal) := by
      have hq_le : f q.1 ‚â§ (q.2 : EReal) := (mem_epigraph_univ_iff (f := f)).1 hqepi
      simpa [hq_pair] using hq_le
    simpa [Sx, Œº, hrEq] using hleŒº
  have hmem_Sx_of_le_real :
      ‚àÄ {Œº : ‚Ñù}, f x ‚â§ (Œº : EReal) ‚Üí (Œº : EReal) ‚àà Sx := by
    intro Œº hleŒº
    have hqepi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f :=
      (mem_epigraph_univ_iff (f := f)).2 hleŒº
    have hmem_img :
        (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
          ((fun q => (prodLinearEquiv_append_coord (n := n)) q) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
      exact ‚ü®(x, Œº), hqepi, rfl‚ü©
    have hmem_mixed :
        (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
          mixedConvexHull (n := n + 1) (Set.range p) (Set.range d) := by
      simpa [hEq_mixed'] using hmem_img
    rcases hfixedCoeffs hmem_mixed with
      ‚ü®a', b', ha_nonneg, hb_nonneg, hsum_a, hy_repr‚ü©
    rcases
      helperForCorollary_19_1_2_decode_transformedGeneratorCoeffs_to_Text19_0_10_lam
        (n := n) (k' := k') (m' := m') p d
        (x := x) (Œº := Œº) (a' := a') (b' := b')
        ha_nonneg hb_nonneg hsum_a hy_repr with
      ‚ü®lam, hlin, hnorm, hnonneg, hobj‚ü©
    have hlin' : ‚àÄ j, (‚àë i, lam i * aDec i j) = x j := by
      simpa [aDec] using hlin
    have hobj' : (‚àë i, lam i * Œ±Dec i : ‚Ñù) = Œº := by
      simpa [Œ±Dec] using hobj
    have hobjE : (Œº : EReal) = ((‚àë i, lam i * Œ±Dec i : ‚Ñù) : EReal) := by
      exact congrArg (fun t : ‚Ñù => (t : EReal)) hobj'.symm
    exact ‚ü®lam, hlin', hnorm, hnonneg, hobjE‚ü©
  have hsInf_le_fx : sInf Sx ‚â§ f x := by
    by_cases htop : f x = ‚ä§
    ¬∑ simpa [htop] using (le_top : sInf Sx ‚â§ (‚ä§ : EReal))
    ¬∑ by_cases hbot : f x = ‚ä•
      ¬∑ have hforall_real_mem : ‚àÄ z : ‚Ñù, (z : EReal) ‚àà Sx := by
          intro z
          have hle : f x ‚â§ (z : EReal) := by
            simpa [hbot] using (EReal.bot_lt_coe z).le
          exact hmem_Sx_of_le_real (Œº := z) hle
        have hforall_real_le : ‚àÄ z : ‚Ñù, sInf Sx ‚â§ (z : EReal) := by
          intro z
          exact sInf_le (hforall_real_mem z)
        have hle_bot : sInf Sx ‚â§ (‚ä• : EReal) := by
          exact
            (EReal.le_of_forall_lt_iff_le (x := (‚ä• : EReal)) (y := sInf Sx)).1
              (by
                intro z hz
                exact hforall_real_le z)
        simpa [hbot] using hle_bot
      ¬∑ let r : ‚Ñù := (f x).toReal
        have hrfx : f x = (r : EReal) := by
          have hcoe : ((f x).toReal : EReal) = f x :=
            EReal.coe_toReal htop hbot
          simpa [r] using hcoe.symm
        have hr_mem : (r : EReal) ‚àà Sx := by
          have hle : f x ‚â§ (r : EReal) := by
            simpa [hrfx]
          exact hmem_Sx_of_le_real (Œº := r) hle
        have hsInf_le_r : sInf Sx ‚â§ (r : EReal) := sInf_le hr_mem
        simpa [hrfx] using hsInf_le_r
  exact le_antisymm hfx_le_sInf hsInf_le_fx

/-- Helper for Corollary 19.1.2: finite-generation of the transformed epigraph induces
finite-generation of the function representation. -/
lemma helperForCorollary_19_1_2_finitelyGeneratedFunction_of_epigraphFG
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hconv : ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)
    (hfg_epi :
      IsFinitelyGeneratedConvexSet (n + 1)
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) :
    IsFinitelyGeneratedConvexFunction n f :=
  by
    have hfpoly : IsPolyhedralConvexFunction n f :=
      helperForCorollary_19_1_2_polyhedralFunction_of_epigraphFG
        (n := n) (f := f) hconv hfg_epi
    have hconv_from_poly : ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := hfpoly.1
    rcases
      helperForCorollary_19_1_2_unpack_mixedHull_generators_for_transformedEpigraph
        (n := n) (f := f) hfg_epi with
      ‚ü®k, m, a, Œ±, hk, hrepr‚ü©
    exact ‚ü®hconv_from_poly, ‚ü®k, m, a, Œ±, hk, hrepr‚ü©‚ü©

/-- Helper for Corollary 19.1.2: finite-generation of the function representation induces
finite-generation of the transformed epigraph. -/
lemma helperForCorollary_19_1_2_epigraphFG_of_finitelyGeneratedFunction
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} :
    IsFinitelyGeneratedConvexFunction n f ‚Üí
      IsFinitelyGeneratedConvexSet (n + 1)
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) :=
  by
    intro hfgen
    rcases
      helperForCorollary_19_1_2_unpack_finitelyGeneratedData
        (n := n) (f := f) hfgen with
      ‚ü®k, m, a, Œ±, hk, hrepr‚ü©
    exact
      helperForCorollary_19_1_2_pack_transformedEpigraph_from_functionRepresentation
        (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±) hk hrepr

/-- Helper for Corollary 19.1.2: polyhedral convex functions are finitely generated. -/
lemma helperForCorollary_19_1_2_polyhedral_imp_finitelyGenerated
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} :
    IsPolyhedralConvexFunction n f ‚Üí IsFinitelyGeneratedConvexFunction n f := by
  intro hfpoly
  let C : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
    ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
      epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)
  have hpolyC : IsPolyhedralConvexSet (n + 1) C := by
    simpa [C, prodLinearEquiv_append_coord] using hfpoly.2
  have hconvC : Convex ‚Ñù C :=
    helperForTheorem_19_1_polyhedral_isConvex (n := n + 1) (C := C) hpolyC
  have hTFAE :
      [IsPolyhedralConvexSet (n + 1) C,
          (IsClosed C ‚àß {C' : Set (Fin (n + 1) ‚Üí ‚Ñù) | IsFace (ùïú := ‚Ñù) C C'}.Finite),
        IsFinitelyGeneratedConvexSet (n + 1) C].TFAE :=
    polyhedral_closed_finiteFaces_finitelyGenerated_equiv (n := n + 1) (C := C) hconvC
  have hfgC : IsFinitelyGeneratedConvexSet (n + 1) C :=
    (hTFAE.out 0 2).1 hpolyC
  exact
    helperForCorollary_19_1_2_finitelyGeneratedFunction_of_epigraphFG
      (n := n) (f := f) hfpoly.1 (by simpa [C] using hfgC)

/-- Helper for Corollary 19.1.2: finitely generated convex functions are polyhedral. -/
lemma helperForCorollary_19_1_2_finitelyGenerated_imp_polyhedral
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} :
    IsFinitelyGeneratedConvexFunction n f ‚Üí IsPolyhedralConvexFunction n f := by
  intro hfgen
  let C : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
    ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
      epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)
  have hconv_epi : Convex ‚Ñù (epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) :=
    convex_epigraph_of_convexFunctionOn (f := f) (hf := hfgen.1)
  have hconvC : Convex ‚Ñù C := by
    simpa [C] using
      hconv_epi.linear_image (prodLinearEquiv_append_coord (n := n)).toLinearMap
  have hTFAE :
      [IsPolyhedralConvexSet (n + 1) C,
          (IsClosed C ‚àß {C' : Set (Fin (n + 1) ‚Üí ‚Ñù) | IsFace (ùïú := ‚Ñù) C C'}.Finite),
        IsFinitelyGeneratedConvexSet (n + 1) C].TFAE :=
    polyhedral_closed_finiteFaces_finitelyGenerated_equiv (n := n + 1) (C := C) hconvC
  have hfgC : IsFinitelyGeneratedConvexSet (n + 1) C :=
    helperForCorollary_19_1_2_epigraphFG_of_finitelyGeneratedFunction
      (n := n) (f := f) hfgen
  have hpolyC : IsPolyhedralConvexSet (n + 1) C :=
    (hTFAE.out 2 0).1 hfgC
  have hpoly_append :
      IsPolyhedralConvexSet (n + 1)
        ((fun p => (prodLinearEquiv_append (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
    simpa [C, prodLinearEquiv_append_coord] using hpolyC
  exact ‚ü®hfgen.1, hpoly_append‚ü©

/-- Helper for Corollary 19.1.2: a proper polyhedral convex function is closed. -/
lemma helperForCorollary_19_1_2_closed_of_polyhedral_proper
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} :
    IsPolyhedralConvexFunction n f ‚Üí
      ProperConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f ‚Üí
      ClosedConvexFunction f := by
  intro hfpoly hfproper
  have hclosed_transformedEpigraph :
      IsClosed
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
    exact
      (helperForTheorem_19_1_polyhedral_imp_closed_finiteFaces
        (n := n + 1)
        (C := ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f))
        (by
          simpa [prodLinearEquiv_append_coord] using hfpoly.2)).1
  let hhome :=
    ((prodLinearEquiv_append_coord (n := n)).toAffineEquiv).toHomeomorphOfFiniteDimensional
  have hclosed_epigraph :
      IsClosed (epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
    have hclosed_image_homeomorph :
        IsClosed
          ((hhome : ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù) ‚Üí (Fin (n + 1) ‚Üí ‚Ñù)) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
      simpa [hhome, AffineEquiv.coe_toHomeomorphOfFiniteDimensional] using
        hclosed_transformedEpigraph
    exact
      (hhome.isClosed_image (s := epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)).1
        hclosed_image_homeomorph
  have hclosed_sublevel :
      ‚àÄ Œ± : ‚Ñù, IsClosed {x : Fin n ‚Üí ‚Ñù | f x ‚â§ (Œ± : EReal)} :=
    (lowerSemicontinuous_iff_closed_sublevel_iff_closed_epigraph
      (f := f)).2.mpr hclosed_epigraph
  have hlsc : LowerSemicontinuous f :=
    (lowerSemicontinuous_iff_closed_sublevel_iff_closed_epigraph
      (f := f)).1.mpr hclosed_sublevel
  exact
    (properConvexFunction_closed_iff_lowerSemicontinuous
      (f := f) hfproper).2 hlsc

/-- Helper for Corollary 19.1.2: an `EReal` infimum equal to a finite real value
cannot come from the empty set. -/
lemma helperForCorollary_19_1_2_nonempty_of_sInf_eq_real
    {S : Set EReal} {r : ‚Ñù} (hr : sInf S = (r : EReal)) :
    S.Nonempty := by
  by_contra hSempty
  have hS : S = (‚àÖ : Set EReal) := (Set.not_nonempty_iff_eq_empty).1 hSempty
  have hsInfTop : sInf S = (‚ä§ : EReal) := by
    simpa [hS] using (sInf_empty : sInf (‚àÖ : Set EReal) = (‚ä§ : EReal))
  have hrtop : (r : EReal) = (‚ä§ : EReal) := by
    calc
      (r : EReal) = sInf S := by simpa [hr]
      _ = (‚ä§ : EReal) := hsInfTop
  exact (EReal.coe_ne_top r) hrtop


end Section19
end Chap19
