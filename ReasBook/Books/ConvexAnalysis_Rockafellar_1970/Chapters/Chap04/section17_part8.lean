import Mathlib
import ConvexAnalysis_Rockafellar_1970.Chapters.Chap04.section17_part7
import ConvexAnalysis_Rockafellar_1970.Chapters.Chap02.section09_part11

open scoped BigOperators Pointwise
open Topology
open Filter

section Chap04
section Section17

/-- Corollary 17.1.6. Let `f : ‚Ñù‚Åø ‚Üí (-‚àû, +‚àû]` be any function (modeled here as
`f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal` together with the side condition `‚àÄ x, f x ‚â† ‚ä•`). Let `k` be the
positively homogeneous convex function generated by `f` (equivalently, generated by `conv f`,
modeled here as `convexHullFunction f`).

Then, for each vector `x ‚â† 0`,
`k x = inf { ‚àë i, Œª i * f (x·µ¢ i) | ‚àë i, Œª i ‚Ä¢ x·µ¢ i = x }`,
where the infimum is taken over all expressions of `x` as a nonnegative linear combination of
at most `n+1` vectors (allowing zero coefficients to pad the representation). -/
theorem positivelyHomogeneousConvexFunctionGenerated_convexHullFunction_eq_sInf_nonnegLinearCombination
    {n : Nat} {f : (Fin n ‚Üí Real) ‚Üí EReal} (h_not_bot : ‚àÄ x, f x ‚â† (‚ä• : EReal)) :
    ‚àÄ x : Fin n ‚Üí Real,
      x ‚â† 0 ‚Üí
        positivelyHomogeneousConvexFunctionGenerated (convexHullFunction f) x =
          sInf { z : EReal |
            ‚àÉ (x' : Fin (n + 1) ‚Üí Fin n ‚Üí Real) (c : Fin (n + 1) ‚Üí Real),
              (‚àÄ i, 0 ‚â§ c i) ‚àß
                (‚àë i, c i ‚Ä¢ x' i = x) ‚àß
                z = ‚àë i, ((c i : Real) : EReal) * f (x' i) } := by
  classical
  intro x hx
  by_cases hfinite : ‚àÉ x0, f x0 ‚â† (‚ä§ : EReal)
  ¬∑
    have hpos :
        positivelyHomogeneousConvexFunctionGenerated (convexHullFunction f) x =
          sInf { z : EReal |
            ‚àÉ lam : Real, 0 < lam ‚àß
              z = rightScalarMultiple (convexHullFunction f) lam x } := by
      have hconv :
          ConvexFunctionOn (S := (Set.univ : Set (Fin n ‚Üí Real))) (convexHullFunction f) := by
        simpa using (convexHullFunction_greatest_convex_minorant (g := f)).1
      have hfinite' : ‚àÉ x, convexHullFunction f x ‚â† (‚ä§ : EReal) := by
        rcases hfinite with ‚ü®x0, hx0‚ü©
        rcases (convexHullFunction_greatest_convex_minorant (g := f)) with ‚ü®_hconv, hle, -‚ü©
        refine ‚ü®x0, ?_‚ü©
        intro htop
        have htop_le : (‚ä§ : EReal) ‚â§ f x0 := by
          simpa [htop] using hle x0
        have htop_eq : f x0 = (‚ä§ : EReal) := (top_le_iff).1 htop_le
        exact hx0 htop_eq
      have hmain :=
        (infimumRepresentation_posHomogeneousHull (n := n)
          (h := convexHullFunction f) hconv hfinite').2
      have hmain' := hmain x (Or.inl hx)
      simpa using hmain'
    have hstep1 :=
      sInf_pos_rightScalarMultiple_convexHullFunction_eq_sInf_exists_scaled_convexCombination_add_one
        (f := f) (h_not_bot := h_not_bot) (x := x)
    have hstep2 :=
      scaled_convexCombination_add_one_witness_iff_nonneg_coeff_witness (f := f) (x := x) hx
    have hstep2' :
        sInf { z : EReal |
          ‚àÉ lam : Real, 0 < lam ‚àß
            ‚àÉ (x' : Fin (n + 1) ‚Üí Fin n ‚Üí Real) (w : Fin (n + 1) ‚Üí Real),
              IsConvexWeights (n + 1) w ‚àß
                x = ‚àë i, (lam * w i) ‚Ä¢ x' i ‚àß
                z = ‚àë i, ((lam * w i : Real) : EReal) * f (x' i) } =
          sInf { z : EReal |
            ‚àÉ (x' : Fin (n + 1) ‚Üí Fin n ‚Üí Real) (c : Fin (n + 1) ‚Üí Real),
              (‚àÄ i, 0 ‚â§ c i) ‚àß
                (‚àë i, c i ‚Ä¢ x' i = x) ‚àß
                z = ‚àë i, ((c i : Real) : EReal) * f (x' i) } := by
      simpa [eq_comm] using hstep2
    exact hpos.trans (hstep1.trans hstep2')
  ¬∑
    have htop : ‚àÄ x, f x = (‚ä§ : EReal) := by
      intro x0
      by_contra hx0
      exact hfinite ‚ü®x0, hx0‚ü©
    have hconv_top :
        ConvexFunctionOn (S := (Set.univ : Set (Fin n ‚Üí Real)))
          (fun _ : Fin n ‚Üí Real => (‚ä§ : EReal)) := by
      have hE :
          epigraph (Set.univ : Set (Fin n ‚Üí Real))
              (fun _ : Fin n ‚Üí Real => (‚ä§ : EReal)) =
            (‚àÖ : Set ((Fin n ‚Üí Real) √ó Real)) := by
        ext p
        constructor
        ¬∑ intro hp
          rcases hp with ‚ü®-, hp‚ü©
          have htop' : (p.2 : EReal) = ‚ä§ := (top_le_iff).1 hp
          exact (EReal.coe_ne_top _ htop').elim
        ¬∑ intro hp
          cases hp
      have hconv_empty :
          Convex ‚Ñù (‚àÖ : Set ((Fin n ‚Üí Real) √ó Real)) := by
        simpa using (convex_empty : Convex ‚Ñù (‚àÖ : Set ((Fin n ‚Üí Real) √ó Real)))
      simpa [ConvexFunctionOn, hE] using hconv_empty
    have hle_top : (fun _ : Fin n ‚Üí Real => (‚ä§ : EReal)) ‚â§ f := by
      intro x0
      simp [htop x0]
    have hle_conv :
        (fun _ : Fin n ‚Üí Real => (‚ä§ : EReal)) ‚â§ convexHullFunction f :=
      (convexHullFunction_greatest_convex_minorant (g := f)).2.2
        (fun _ => (‚ä§ : EReal)) hconv_top hle_top
    have hconvHull_top : ‚àÄ y, convexHullFunction f y = (‚ä§ : EReal) := by
      intro y
      have htop_y : (‚ä§ : EReal) ‚â§ convexHullFunction f y := by
        simpa using hle_conv y
      exact (top_le_iff).1 htop_y
    have hepigraph_empty :
        epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction f) =
          (‚àÖ : Set ((Fin n ‚Üí Real) √ó Real)) := by
      ext p
      constructor
      ¬∑ intro hp
        rcases hp with ‚ü®-, hp‚ü©
        have htop' : (p.2 : EReal) = ‚ä§ := by
          have hp' : (‚ä§ : EReal) ‚â§ p.2 := by
            convert hp using 1; simp [hconvHull_top p.1]
          exact (top_le_iff).1 hp'
        exact (EReal.coe_ne_top _ htop').elim
      ¬∑ intro hp
        cases hp
    have hconv :
        ConvexFunctionOn (S := (Set.univ : Set (Fin n ‚Üí Real))) (convexHullFunction f) := by
      simpa using (convexHullFunction_greatest_convex_minorant (g := f)).1
    have hempty :
        { Œº : ‚Ñù | (x, Œº) ‚àà convexConeGeneratedEpigraph (convexHullFunction f) } = ‚àÖ := by
      ext Œº
      constructor
      ¬∑ intro hmem
        have hmem' :=
          (mem_convexConeGeneratedEpigraph_iff (h := convexHullFunction f) hconv).1 hmem
        rcases hmem' with hzero | ‚ü®lam, hlam, hmem'‚ü©
        ¬∑
          have hx0 : x = 0 := by
            simpa using congrArg Prod.fst hzero
          exact (hx hx0).elim
        ¬∑
          have hmem'' : (x, Œº) ‚àà (‚àÖ : Set ((Fin n ‚Üí Real) √ó Real)) := by
            convert hmem' using 1; simp [hepigraph_empty]
          exact hmem''.elim
      ¬∑ intro hmem
        cases hmem
    have hleft : positivelyHomogeneousConvexFunctionGenerated (convexHullFunction f) x = ‚ä§ := by
      simp [positivelyHomogeneousConvexFunctionGenerated, hempty]
    have hright :
        sInf { z : EReal |
          ‚àÉ (x' : Fin (n + 1) ‚Üí Fin n ‚Üí Real) (c : Fin (n + 1) ‚Üí Real),
            (‚àÄ i, 0 ‚â§ c i) ‚àß
              (‚àë i, c i ‚Ä¢ x' i = x) ‚àß
              z = ‚àë i, ((c i : Real) : EReal) * f (x' i) } = ‚ä§ := by
      refine le_antisymm ?_ ?_
      ¬∑ exact le_top
      ¬∑
        refine le_sInf ?_
        intro z hz
        rcases hz with ‚ü®x', c, hc, hxsum, hz‚ü©
        have hpos : ‚àÉ i, 0 < c i := by
          by_contra hpos
          have hzero : ‚àÄ i, c i = 0 := by
            intro i
            have hle : c i ‚â§ 0 := le_of_not_gt ((not_exists.mp hpos) i)
            exact le_antisymm hle (hc i)
          have hx0 : x = 0 := by
            simpa [hzero] using hxsum.symm
          exact (hx hx0).elim
        rcases hpos with ‚ü®i0, hi0‚ü©
        have hterm_top :
            ((c i0 : Real) : EReal) * f (x' i0) = ‚ä§ := by
          have hposE : (0 : EReal) < (c i0 : EReal) := (EReal.coe_pos).2 hi0
          simpa [htop (x' i0)] using
            (EReal.mul_top_of_pos (x := (c i0 : EReal)) hposE)
        have hsum_top :
            (‚àë i, ((c i : Real) : EReal) * f (x' i)) = ‚ä§ := by
          have hsum :=
            (Finset.add_sum_erase (s := Finset.univ)
              (f := fun i => ((c i : Real) : EReal) * f (x' i))
              (a := i0) (h := by simp))
          calc
            (‚àë i, ((c i : Real) : EReal) * f (x' i)) =
                ((c i0 : Real) : EReal) * f (x' i0) +
                  (Finset.univ.erase i0).sum
                    (fun i => ((c i : Real) : EReal) * f (x' i)) := by
              simpa using hsum.symm
            _ = ‚ä§ := by
              have hsum_ne_bot :
                  (Finset.univ.erase i0).sum
                      (fun i => ((c i : Real) : EReal) * f (x' i)) ‚â† ‚ä• := by
                refine
                  sum_ne_bot_of_ne_bot (s := Finset.univ.erase i0)
                    (f := fun i => ((c i : Real) : EReal) * f (x' i)) ?_
                intro i hi
                have hne_bot : f (x' i) ‚â† ‚ä• := h_not_bot (x' i)
                refine (EReal.mul_ne_bot ((c i : Real) : EReal) (f (x' i))).2 ?_
                refine ‚ü®?_, ?_, ?_, ?_‚ü©
                ¬∑ left
                  exact EReal.coe_ne_bot _
                ¬∑ right
                  exact hne_bot
                ¬∑ left
                  exact EReal.coe_ne_top _
                ¬∑ left
                  exact (EReal.coe_nonneg).2 (hc i)
              simpa [hterm_top] using (EReal.top_add_of_ne_bot hsum_ne_bot)
        have hz' : z = ‚ä§ := by
          simp [hz, hsum_top]
        simp [hz']
    simp [hleft, hright]

/-- Linear independence of the lifted points `(1, p i)` from affine independence of `p`. -/
lemma linearIndependent_lift1_of_affineIndependent {n d : Nat}
    {p : Fin (d + 1) ‚Üí Fin n ‚Üí ‚Ñù} (hp : AffineIndependent ‚Ñù p) :
    LinearIndependent ‚Ñù (fun i => (Fin.cases (1 : ‚Ñù) (p i) : Fin (n + 1) ‚Üí ‚Ñù)) := by
  classical
  let lift1 : (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := fun x => Fin.cases (1 : ‚Ñù) x
  have hp' := (affineIndependent_iff (k := ‚Ñù) (p := p)).1 hp
  refine (linearIndependent_iff' (R := ‚Ñù) (v := fun i => lift1 (p i))).2 ?_
  intro s g hsum
  have hsum0' : (‚àë i ‚àà s, g i ‚Ä¢ lift1 (p i)) 0 = 0 := by
    simpa using congrArg (fun v => v 0) hsum
  have hsum0 : s.sum g = 0 := by
    simp [lift1] at hsum0'
    simpa using hsum0'
  have hsumP : ‚àë i ‚àà s, g i ‚Ä¢ p i = 0 := by
    ext j
    have hsumj : (‚àë i ‚àà s, g i ‚Ä¢ lift1 (p i)) (Fin.succ j) = 0 := by
      simpa using congrArg (fun v => v (Fin.succ j)) hsum
    simp [lift1] at hsumj
    simpa using hsumj
  exact hp' s g hsum0 hsumP

/-- Convex hull of affinely independent vertices is a generalized simplex. -/
lemma isGeneralizedSimplex_conv_range_of_affineIndependent
    {n d : Nat} {p : Fin (d + 1) ‚Üí Fin n ‚Üí ‚Ñù} (hp : AffineIndependent ‚Ñù p) :
    IsGeneralizedSimplex n d (conv (Set.range p)) := by
  classical
  let lift1 : (Fin n ‚Üí ‚Ñù) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := fun x => Fin.cases (1 : ‚Ñù) x
  let v : Fin (d + 1) ‚Üí Fin (n + 1) ‚Üí ‚Ñù := fun i => lift1 (p i)
  let f_lin : (Fin (d + 1) ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] (Fin (n + 1) ‚Üí ‚Ñù) :=
    Fintype.linearCombination ‚Ñù v
  let f : (Fin (d + 1) ‚Üí ‚Ñù) ‚Üí·µÉ[‚Ñù] (Fin (n + 1) ‚Üí ‚Ñù) := f_lin.toAffineMap
  let O : Set (Fin (n + 1) ‚Üí ‚Ñù) := f '' nonnegOrthant (d + 1)
  refine ‚ü®O, ?_, ?_‚ü©
  ¬∑
    have hlin : LinearIndependent ‚Ñù v :=
      linearIndependent_lift1_of_affineIndependent (p := p) hp
    have hf_inj : Function.Injective f := by
      have hlin_inj : Function.Injective f_lin :=
        (LinearIndependent.fintypeLinearCombination_injective (v := v) hlin)
      simpa [f, f_lin] using hlin_inj
    exact ‚ü®f, hf_inj, rfl‚ü©
  ¬∑
    ext x
    constructor
    ¬∑ intro hx
      -- use affine combination representation
      rcases (by
        simpa [convexHull_range_eq_exists_affineCombination (R := ‚Ñù) (v := p)] using hx) with
        ‚ü®s, w, hw_nonneg, hw_sum, hx_aff‚ü©
      let c : Fin (d + 1) ‚Üí ‚Ñù := fun i => if i ‚àà s then w i else 0
      have hc_nonneg : ‚àÄ i, 0 ‚â§ c i := by
        intro i
        by_cases hi : i ‚àà s
        ¬∑ simp [c, hi, hw_nonneg i hi]
        ¬∑ simp [c, hi]
      have hsum_c : ‚àë i, c i = 1 := by
        have hsum' : ‚àë i, c i = ‚àë i ‚àà s, w i := by
          calc
            ‚àë i, c i = ‚àë i, if i ‚àà s then w i else 0 := by
              simp [c]
            _ = ‚àë i ‚àà s, w i := Fintype.sum_ite_mem s w
        have hsum'' : ‚àë i ‚àà s, w i = 1 := by
          simpa using hw_sum
        exact hsum'.trans hsum''
      have hx_sum : ‚àë i, c i ‚Ä¢ p i = x := by
        have hx_aff' : ‚àë i ‚àà s, w i ‚Ä¢ p i = x := by
          have hsum'' : s.sum w = 1 := hw_sum
          calc
            ‚àë i ‚àà s, w i ‚Ä¢ p i = (Finset.affineCombination ‚Ñù s p) w := by
              symm
              exact (Finset.affineCombination_eq_linear_combination (k := ‚Ñù) (s := s) (p := p)
                (w := w) (by simpa using hsum''))
            _ = x := hx_aff
        have hx_sum' : ‚àë i, c i ‚Ä¢ p i = ‚àë i ‚àà s, w i ‚Ä¢ p i := by
          calc
            ‚àë i, c i ‚Ä¢ p i = ‚àë i, if i ‚àà s then w i ‚Ä¢ p i else 0 := by
              simp [c]
            _ = ‚àë i ‚àà s, w i ‚Ä¢ p i :=
              Fintype.sum_ite_mem s (fun i => w i ‚Ä¢ p i)
        exact hx_sum'.trans hx_aff'
      -- show lift1 x in O ‚à© liftingHyperplane
      refine ‚ü®?memO, ?memH‚ü©
      ¬∑ refine ‚ü®c, ?_, ?_‚ü©
        ¬∑ change ‚àÄ i, 0 ‚â§ c i
          exact hc_nonneg
        ¬∑ -- f c = lift1 x
          ext i
          cases i using Fin.cases with
          | zero =>
              -- coordinate 0: sum of weights
              simp [f, f_lin, v, lift1, Fintype.linearCombination_apply, hsum_c]
          | succ j =>
              have hx_sum' := congrArg (fun v => v j) hx_sum
              have hsucc : (f c) (Fin.succ j) = (‚àë i, c i ‚Ä¢ p i) j := by
                simp [f, f_lin, v, lift1, Fintype.linearCombination_apply]
              simpa [hsucc, lift1] using hx_sum'
      ¬∑ -- lift1 x is always in the lifting hyperplane
        simp [liftingHyperplane_eq]
    ¬∑ intro hx
      rcases hx with ‚ü®hxO, _hxH‚ü©
      rcases hxO with ‚ü®c, hc, hc_eq‚ü©
      have hc_nonneg : ‚àÄ i, 0 ‚â§ c i := by
        simpa [nonnegOrthant] using hc
      -- compute sum weights from coordinate 0
      have hsum_c : ‚àë i, c i = 1 := by
        have h0 : (f c) 0 = 1 := by
          have h0' : (f c) 0 = (lift1 x) 0 := by
            simpa using congrArg (fun v => v 0) hc_eq
          simpa [lift1] using h0'
        simpa [f, f_lin, v, lift1, Fintype.linearCombination_apply] using h0
      -- compute x as combination
      have hx_sum : ‚àë i, c i ‚Ä¢ p i = x := by
        ext j
        have hsj : (f c) (Fin.succ j) = (lift1 x) (Fin.succ j) := by
          simpa using congrArg (fun v => v (Fin.succ j)) hc_eq
        simp [f, f_lin, v, lift1, Fintype.linearCombination_apply] at hsj
        simpa [lift1] using hsj
      -- conclude membership in convex hull
      refine mem_convexHull_of_exists_fintype (Œπ := Fin (d + 1)) (s := Set.range p)
        (w := c) (z := p) ?_ ?_ ?_ ?_
      ¬∑ exact hc_nonneg
      ¬∑ exact hsum_c
      ¬∑ intro i; exact ‚ü®i, rfl‚ü©
      ¬∑ exact hx_sum

/-- For any `x ‚àà C`, there are `d+1` affinely independent points of `C` with `x` as the first vertex,
where `d` is the finrank of the direction of `affineSpan ‚Ñù C`. -/
lemma exists_affineIndependent_vertices_through_point_finrank_direction
    {n : Nat} {C : Set (Fin n ‚Üí ‚Ñù)} {x : Fin n ‚Üí ‚Ñù} (hx : x ‚àà C) :
    let d := Module.finrank ‚Ñù (affineSpan ‚Ñù C).direction
    ‚àÉ p : Fin (d + 1) ‚Üí Fin n ‚Üí ‚Ñù, p 0 = x ‚àß (‚àÄ i, p i ‚àà C) ‚àß
      AffineIndependent ‚Ñù p := by
  classical
  intro d
  let s : Set (Fin n ‚Üí ‚Ñù) := (fun y => y -·µ• x) '' C
  have hdir : (affineSpan ‚Ñù C).direction = Submodule.span ‚Ñù s := by
    simpa [direction_affineSpan] using
      (vectorSpan_eq_span_vsub_set_right (k := ‚Ñù) (s := C) (p := x) hx)
  -- equality of finranks
  have hfinrank : Module.finrank ‚Ñù ‚Ü•(Submodule.span ‚Ñù s) =
      Module.finrank ‚Ñù ‚Ü•(affineSpan ‚Ñù C).direction := by
    have hlin : ‚Ü•(Submodule.span ‚Ñù s) ‚âÉ‚Çó[‚Ñù] ‚Ü•(affineSpan ‚Ñù C).direction :=
      LinearEquiv.ofEq (Submodule.span ‚Ñù s) (affineSpan ‚Ñù C).direction hdir.symm
    simpa using (LinearEquiv.finrank_eq hlin)
  -- choose a spanning linearly independent family of vsub vectors
  obtain ‚ü®f, hfmem, _hfspan, hlin‚ü© :=
    (Submodule.exists_fun_fin_finrank_span_eq (K := ‚Ñù) s)
  -- reindex to `Fin d`
  let g : Fin d ‚Üí Fin n ‚Üí ‚Ñù := fun i => f (Fin.cast hfinrank.symm i)
  have hgmem : ‚àÄ i, g i ‚àà s := by
    intro i
    simpa [g] using hfmem (Fin.cast hfinrank.symm i)
  have hlin_g : LinearIndependent ‚Ñù g :=
    hlin.comp (Fin.cast hfinrank.symm) (Fin.cast_injective _)
  -- pick points in C whose differences are g
  have hmem : ‚àÄ i, ‚àÉ y ‚àà C, g i = y -·µ• x := by
    intro i
    rcases hgmem i with ‚ü®y, hyC, hy‚ü©
    exact ‚ü®y, hyC, hy.symm‚ü©
  choose q hqC hqeq using hmem
  -- build the vertex family
  let p : Fin (d + 1) ‚Üí Fin n ‚Üí ‚Ñù := Fin.cases x q
  have hp0 : p 0 = x := by simp [p]
  have hpC : ‚àÄ i, p i ‚àà C := by
    intro i
    cases i using Fin.cases with
    | zero => simpa [p] using hx
    | succ i => simpa [p] using hqC i
  -- affine independence
  let e : Fin d ‚âÉ {i : Fin (d + 1) // i ‚â† 0} :=
    { toFun := fun i => ‚ü®Fin.succ i, by simp‚ü©
      invFun := fun i => Fin.pred i.1 i.2
      left_inv := by
        intro i
        simp
      right_inv := by
        intro i
        ext
        simp [Fin.succ_pred] }
  have hlin_sub :
      LinearIndependent ‚Ñù ((fun i : {i : Fin (d + 1) // i ‚â† 0} => p i -·µ• p 0) ‚àò e) := by
    -- reduce to g
    simpa [e, p, g, hqeq] using hlin_g
  have hlin_vsub :
      LinearIndependent ‚Ñù (fun i : {i : Fin (d + 1) // i ‚â† 0} => p i -·µ• p 0) :=
    (linearIndependent_equiv e).1 hlin_sub
  have haff : AffineIndependent ‚Ñù p :=
    (affineIndependent_iff_linearIndependent_vsub (k := ‚Ñù) (p := p) (i1 := (0 : Fin (d + 1)))).2
      hlin_vsub
  exact ‚ü®p, hp0, hpC, haff‚ü©

/-- Theorem 17.1 (Caratheodory's Theorem), union-of-simplices formulation. With
`C := mixedConvexHull S‚ÇÄ S‚ÇÅ` and `d := dim C` (here `d := finrank (affineSpan ‚Ñù C).direction`),
the set `C` is the union of all generalized `d`-dimensional simplices contained in `C`. -/
theorem mixedConvexHull_eq_sUnion_generalizedSimplex_finrank_affineSpan_direction
    {n : Nat} (S‚ÇÄ S‚ÇÅ : Set (Fin n ‚Üí Real)) :
    (let C := mixedConvexHull (n := n) S‚ÇÄ S‚ÇÅ
      let d := Module.finrank Real (affineSpan Real C).direction
      C = ‚ãÉ‚ÇÄ {T : Set (Fin n ‚Üí Real) | IsGeneralizedSimplex n d T ‚àß T ‚äÜ C}) := by
  classical
  intro C d
  ext x
  constructor
  ¬∑ intro hx
    -- choose an affinely independent simplex through x
    rcases (exists_affineIndependent_vertices_through_point_finrank_direction (C := C) (x := x) hx) with
      ‚ü®p, hp0, hpC, hpAI‚ü©
    let T : Set (Fin n ‚Üí Real) := conv (Set.range p)
    have hxT : x ‚àà T := by
      have hxrange : x ‚àà Set.range p := by
        exact ‚ü®0, hp0‚ü©
      exact (subset_convexHull ‚Ñù (Set.range p)) hxrange
    have hsubset : T ‚äÜ C := by
      have hsubset_range : Set.range p ‚äÜ C := by
        intro y hy
        rcases hy with ‚ü®i, rfl‚ü©
        exact hpC i
      exact convexHull_min hsubset_range (convex_mixedConvexHull (n := n) S‚ÇÄ S‚ÇÅ)
    have hT_simplex : IsGeneralizedSimplex n d T := by
      -- use affinely independent vertices
      dsimp [T]
      exact isGeneralizedSimplex_conv_range_of_affineIndependent (p := p) hpAI
    refine Set.mem_sUnion.mpr ?_
    refine ‚ü®T, ?_, hxT‚ü©
    exact ‚ü®hT_simplex, hsubset‚ü©
  ¬∑ intro hx
    rcases Set.mem_sUnion.mp hx with ‚ü®T, hT, hxT‚ü©
    rcases hT with ‚ü®_hT_simplex, hsubset‚ü©
    exact hsubset hxT

private def cor1717_xAxis : Set (Fin 2 ‚Üí Real) := {x | x 1 = 0}
private def cor1717_p : Fin 2 ‚Üí Real := ![0, 1]
private def cor1717_q (k : Nat) : Fin 2 ‚Üí Real := ![(k + 1 : Real), 0]
private noncomputable def cor1717_z (k : Nat) : Fin 2 ‚Üí Real :=
  (1 - (1 / (k + 1 : Real))) ‚Ä¢ cor1717_p + (1 / (k + 1 : Real)) ‚Ä¢ cor1717_q k
private def cor1717_lim : Fin 2 ‚Üí Real := ![1, 1]

/-- The x-axis union the point `(0,1)` is closed in `Fin 2 ‚Üí ‚Ñù`. -/
lemma cor1717_isClosed_xAxis_union_point :
    IsClosed (cor1717_xAxis ‚à™ {cor1717_p}) := by
  have hxAxis : IsClosed cor1717_xAxis := by
    have hcont : Continuous (fun x : Fin 2 ‚Üí Real => x 1) := continuous_apply 1
    have hconst : Continuous (fun _ : Fin 2 ‚Üí Real => (0 : Real)) := continuous_const
    simpa [cor1717_xAxis] using (isClosed_eq hcont hconst)
  simpa using hxAxis.union (isClosed_singleton : IsClosed ({cor1717_p} : Set (Fin 2 ‚Üí Real)))

/-- The explicit convex-combination sequence lies in the convex hull. -/
lemma cor1717_zSeq_mem_conv :
    ‚àÄ k, cor1717_z k ‚àà conv (cor1717_xAxis ‚à™ {cor1717_p}) := by
  classical
  intro k
  have ht_nonneg : 0 ‚â§ (1 / (k + 1 : Real)) := by
    have hkpos : (0 : Real) < (k + 1 : Real) := by
      exact_mod_cast (Nat.succ_pos k)
    exact le_of_lt (one_div_pos.mpr hkpos)
  have ht_le : (1 / (k + 1 : Real)) ‚â§ 1 := by
    have hle : (1 : Real) ‚â§ (k + 1 : Real) := by
      exact_mod_cast (Nat.succ_le_succ (Nat.zero_le k))
    have ha : (0 : Real) < (1 : Real) := by norm_num
    simpa using (one_div_le_one_div_of_le ha hle)
  have ha : 0 ‚â§ (1 - (1 / (k + 1 : Real))) := sub_nonneg.mpr ht_le
  have hab : (1 - (1 / (k + 1 : Real))) + (1 / (k + 1 : Real)) = 1 := by
    ring
  have hz :
      cor1717_z k ‚àà convexHull ‚Ñù (cor1717_xAxis ‚à™ {cor1717_p}) := by
    refine (mem_convexHull_iff_exists_fin_isConvexCombination 2
      (cor1717_xAxis ‚à™ {cor1717_p}) (cor1717_z k)).2 ?_
    refine ‚ü®2, (fun i : Fin 2 => if i = 0 then cor1717_p else cor1717_q k), ?_, ?_‚ü©
    ¬∑ intro i
      fin_cases i <;> simp [cor1717_xAxis, cor1717_p, cor1717_q]
    ¬∑
      have hcomb :
          IsConvexCombination 2 2
            (fun i : Fin 2 => if i = 0 then cor1717_p else cor1717_q k)
            ((1 - (1 / (k + 1 : Real))) ‚Ä¢ cor1717_p +
              (1 / (k + 1 : Real)) ‚Ä¢ cor1717_q k) :=
        isConvexCombination_two 2 cor1717_p (cor1717_q k)
          (1 - (1 / (k + 1 : Real))) (1 / (k + 1 : Real)) ha ht_nonneg hab
      simpa [cor1717_z] using hcomb
  simpa [conv] using hz

/-- The explicit sequence converges to `(1,1)`. -/
lemma cor1717_tendsto_zSeq : Tendsto cor1717_z atTop (ùìù cor1717_lim) := by
  refine tendsto_pi_nhds.2 ?_
  intro i
  fin_cases i
  ¬∑
    have hconst : Tendsto (fun _ : Nat => (1 : Real)) atTop (ùìù (1 : Real)) :=
      tendsto_const_nhds
    have h0 : (fun k : Nat => cor1717_z k 0) = fun _ => (1 : Real) := by
      funext k
      have hk : (k + 1 : Real) ‚â† 0 := by
        exact_mod_cast (Nat.succ_ne_zero k)
      simp [cor1717_z, cor1717_p, cor1717_q, hk]
    simp [cor1717_lim, h0]
  ¬∑
    have hdiv :
        Tendsto (fun k : Nat => (1 : Real) / ((k : Real) + 1)) atTop (ùìù (0 : Real)) := by
      simpa using (tendsto_one_div_add_atTop_nhds_zero_nat :
        Tendsto (fun k : Nat => (1 : Real) / ((k : Real) + 1)) atTop (ùìù (0 : Real)))
    have hdiv' :
        Tendsto (fun k : Nat => (1 : Real) / (k + 1 : Real)) atTop (ùìù (0 : Real)) := by
      simpa using hdiv
    have hconst : Tendsto (fun _ : Nat => (1 : Real)) atTop (ùìù (1 : Real)) :=
      tendsto_const_nhds
    have hsub :
        Tendsto (fun k : Nat => (1 : Real) - (1 : Real) / (k + 1 : Real)) atTop
          (ùìù (1 - 0)) :=
      hconst.sub hdiv'
    simpa [cor1717_z, cor1717_p, cor1717_q, cor1717_lim] using hsub

/-- The limit point `(1,1)` is not in the convex hull of the x-axis union `(0,1)`. -/
lemma cor1717_limit_not_mem_conv :
    cor1717_lim ‚àâ conv (cor1717_xAxis ‚à™ {cor1717_p}) := by
  classical
  intro hmem
  have hmem' :
      cor1717_lim ‚àà convexHull ‚Ñù (cor1717_xAxis ‚à™ {cor1717_p}) := by
    simpa [conv] using hmem
  rcases (mem_convexHull_iff_exists_fin_isConvexCombination 2
    (cor1717_xAxis ‚à™ {cor1717_p}) cor1717_lim).1 hmem' with ‚ü®m, x, hxS, hcomb‚ü©
  rcases hcomb with ‚ü®w, hw0, hw1, hsum‚ü©
  have hsum1 : (‚àë i, w i * x i 1) = (1 : Real) := by
    have hsum1' :
        (1 : Real) = ‚àë i, w i * x i 1 := by
      simpa [cor1717_lim, Finset.sum_apply, smul_eq_mul] using
        (congrArg (fun v : Fin 2 ‚Üí Real => v 1) hsum)
    exact hsum1'.symm
  have hx01 : ‚àÄ i, x i 1 = 0 ‚à® x i 1 = 1 := by
    intro i
    rcases hxS i with hxS' | hxS'
    ¬∑ left
      simpa [cor1717_xAxis] using hxS'
    ¬∑ right
      have hx' : x i = cor1717_p := by
        simpa using hxS'
      simpa [cor1717_p] using congrArg (fun v : Fin 2 ‚Üí Real => v 1) hx'
  have hnonneg : ‚àÄ i, 0 ‚â§ w i * (1 - x i 1) := by
    intro i
    have hxle : 0 ‚â§ 1 - x i 1 := by
      rcases hx01 i with h0 | h1
      ¬∑ simp [h0]
      ¬∑ simp [h1]
    exact mul_nonneg (hw0 i) hxle
  have hsum0 : (‚àë i, w i * (1 - x i 1)) = 0 := by
    calc
      ‚àë i, w i * (1 - x i 1) =
          (‚àë i, w i) - ‚àë i, w i * x i 1 := by
        simp [mul_sub, Finset.sum_sub_distrib, mul_one]
      _ = 0 := by
        simp [hw1, hsum1]
  have hterm_zero : ‚àÄ i, w i * (1 - x i 1) = 0 := by
    have hnonneg' :
        ‚àÄ i ‚àà (Finset.univ : Finset (Fin m)), 0 ‚â§ w i * (1 - x i 1) := by
      intro i _
      exact hnonneg i
    have hterm_zero' :=
      (Finset.sum_eq_zero_iff_of_nonneg (s := (Finset.univ : Finset (Fin m)))
          (f := fun i => w i * (1 - x i 1)) hnonneg').1 (by
        simpa using hsum0)
    intro i
    exact hterm_zero' i (by simp)
  have hw_zero_of_axis : ‚àÄ i, x i 1 = 0 ‚Üí w i = 0 := by
    intro i h0
    have hterm := hterm_zero i
    simpa [h0] using hterm
  have hx_eq_p : ‚àÄ i, x i 1 = 1 ‚Üí x i = cor1717_p := by
    intro i h1
    rcases hxS i with hxS' | hxS'
    ¬∑
      have h0 : x i 1 = 0 := by
        simpa [cor1717_xAxis] using hxS'
      exfalso
      exact one_ne_zero (h1.symm.trans h0)
    ¬∑
      simpa [cor1717_p] using hxS'
  have hterm_eq : ‚àÄ i, w i ‚Ä¢ x i = w i ‚Ä¢ cor1717_p := by
    intro i
    rcases hx01 i with h0 | h1
    ¬∑
      have hw : w i = 0 := hw_zero_of_axis i h0
      simp [hw]
    ¬∑
      have hx : x i = cor1717_p := hx_eq_p i h1
      simp [hx]
  have hsum_eq_p : ‚àë i, w i ‚Ä¢ x i = cor1717_p := by
    calc
      ‚àë i, w i ‚Ä¢ x i = ‚àë i, w i ‚Ä¢ cor1717_p := by
        classical
        refine Finset.sum_congr rfl ?_
        intro i _
        exact hterm_eq i
      _ = (‚àë i, w i) ‚Ä¢ cor1717_p := by
        simpa using
          (Finset.sum_smul (s := (Finset.univ : Finset (Fin m))) (f := w)
            (x := cor1717_p)).symm
      _ = cor1717_p := by
        simp [hw1]
  have hlim_eq : cor1717_lim = cor1717_p := by
    calc
      cor1717_lim = ‚àë i, w i ‚Ä¢ x i := hsum
      _ = cor1717_p := hsum_eq_p
  have h0 := congrArg (fun v : Fin 2 ‚Üí Real => v 0) hlim_eq
  simp [cor1717_lim, cor1717_p] at h0

/-- Crollary 17.1.7 (Convex hull of a closed set need not be closed), LaTeX label
`cor:conv-closed-not-closed`.

In general, the convex hull of a closed subset of `‚Ñù‚Åø` need not be closed.
In particular, if `S ‚äÜ ‚Ñù¬≤` is the union of a line and a single point not on that line, then
`conv(S)` is not closed. -/
theorem exists_isClosed_set_conv_not_isClosed :
    ‚àÉ (n : Nat) (S : Set (Fin n ‚Üí Real)), IsClosed S ‚àß ¬¨ IsClosed (conv S) := by
  classical
  refine ‚ü®2, cor1717_xAxis ‚à™ {cor1717_p}, ?_, ?_‚ü©
  ¬∑ simpa using cor1717_isClosed_xAxis_union_point
  ¬∑ intro hclosed
    have hzmem :
        ‚àÄ k, cor1717_z k ‚àà conv (cor1717_xAxis ‚à™ {cor1717_p}) :=
      cor1717_zSeq_mem_conv
    have hzlim : Tendsto cor1717_z atTop (ùìù cor1717_lim) :=
      cor1717_tendsto_zSeq
    have hlimmem :
        cor1717_lim ‚àà conv (cor1717_xAxis ‚à™ {cor1717_p}) :=
      hclosed.mem_of_tendsto hzlim (Filter.Eventually.of_forall hzmem)
    exact cor1717_limit_not_mem_conv hlimmem

/-- The convex hull of the x-axis union `(0,1)` is not closed. -/
lemma cor1717_not_isClosed_conv_xAxis_union_point :
    ¬¨ IsClosed (conv (cor1717_xAxis ‚à™ {cor1717_p})) := by
  intro hclosed
  have hzmem : ‚àÄ k, cor1717_z k ‚àà conv (cor1717_xAxis ‚à™ {cor1717_p}) :=
    cor1717_zSeq_mem_conv
  have hzlim : Tendsto cor1717_z atTop (ùìù cor1717_lim) :=
    cor1717_tendsto_zSeq
  have hlimmem :
      cor1717_lim ‚àà conv (cor1717_xAxis ‚à™ {cor1717_p}) :=
    hclosed.mem_of_tendsto hzlim (Filter.Eventually.of_forall hzmem)
  exact cor1717_limit_not_mem_conv hlimmem

/-- An affine equivalence sending an affine line to the x-axis and a point off the line to `(0,1)`. -/
lemma exists_affineEquiv_image_line_eq_xAxis_and_map_point
    {L : AffineSubspace Real (Fin 2 ‚Üí Real)} {p : Fin 2 ‚Üí Real}
    (hL : Module.finrank Real L.direction = 1) (hp : p ‚àâ (L : Set (Fin 2 ‚Üí Real))) :
    ‚àÉ e : (Fin 2 ‚Üí Real) ‚âÉ·µÉ[Real] (Fin 2 ‚Üí Real),
      e '' (L : Set (Fin 2 ‚Üí Real)) = cor1717_xAxis ‚àß e p = cor1717_p := by
  classical
  have hLne : L ‚â† ‚ä• := by
    intro hbot
    have hdim : Module.finrank Real L.direction = 0 := by
      simp [hbot, AffineSubspace.direction_bot]
    rw [hL] at hdim
    exact (Nat.succ_ne_zero 0) hdim
  rcases (AffineSubspace.nonempty_iff_ne_bot L).2 hLne with ‚ü®x0, hx0L‚ü©
  have hdir_ne_bot : (L.direction : Submodule Real (Fin 2 ‚Üí Real)) ‚â† ‚ä• := by
    intro hbot
    have hdim : Module.finrank Real L.direction = 0 := by
      simp [hbot]
    rw [hL] at hdim
    exact (Nat.succ_ne_zero 0) hdim
  rcases (Submodule.ne_bot_iff _).1 hdir_ne_bot with ‚ü®v, hvdir, hv0‚ü©
  let w : Fin 2 ‚Üí Real := p -·µ• x0
  have hw0 : w ‚â† 0 := by
    intro hw0
    have hpL : p ‚àà (L : Set (Fin 2 ‚Üí Real)) := by
      have hp_eq : p = x0 := by
        simpa [w] using (vsub_eq_zero_iff_eq.1 hw0)
      simpa [hp_eq] using hx0L
    exact hp hpL
  have hw_not_dir : w ‚àâ L.direction := by
    intro hw
    have hpL : p ‚àà (L : Set (Fin 2 ‚Üí Real)) := by
      have hw' := (AffineSubspace.vadd_mem_iff_mem_direction (s := L) w hx0L).2 hw
      simpa [w, vsub_vadd] using hw'
    exact hp hpL
  let f : Fin 2 ‚Üí Fin 2 ‚Üí Real := fun i => if i = 0 then v else w
  have hlin : LinearIndependent Real f := by
    refine (linearIndependent_fin2 (K := Real) (V := Fin 2 ‚Üí Real) (f := f)).2 ?_
    refine ‚ü®?_, ?_‚ü©
    ¬∑ simpa [f] using hw0
    ¬∑ intro a
      by_cases ha : a = 0
      ¬∑ simpa [f, ha, eq_comm] using hv0
      ¬∑ intro h
        have hw' : w = (a‚Åª¬π : Real) ‚Ä¢ v := by
          calc
            w = (a‚Åª¬π : Real) ‚Ä¢ (a ‚Ä¢ w) := by
              simpa using (inv_smul_smul‚ÇÄ ha w).symm
            _ = (a‚Åª¬π : Real) ‚Ä¢ v := by
              simpa [f] using congrArg (fun z => (a‚Åª¬π : Real) ‚Ä¢ z) h
        have hwdir : w ‚àà L.direction := by
          simpa [hw'] using (L.direction.smul_mem (a‚Åª¬π) hvdir)
        exact (hw_not_dir hwdir).elim
  have hspan_finrank :
      Module.finrank Real (Submodule.span Real (Set.range f)) = 2 := by
    simpa using
      (finrank_span_eq_card (R := Real) (M := Fin 2 ‚Üí Real) (b := f) hlin)
  have hspan_top : Submodule.span Real (Set.range f) = ‚ä§ := by
    apply Submodule.eq_top_of_finrank_eq
    have hV : Module.finrank Real (Fin 2 ‚Üí Real) = 2 := by
      simp
    simpa [hV] using hspan_finrank
  have hsp : (‚ä§ : Submodule Real (Fin 2 ‚Üí Real)) ‚â§ Submodule.span Real (Set.range f) := by
    simp [hspan_top]
  let b : Module.Basis (Fin 2) Real (Fin 2 ‚Üí Real) := Module.Basis.mk hlin hsp
  have hv : v = b 0 := by
    simp [b, f]
  have hw : w = b 1 := by
    simp [b, f]
  let A : (Fin 2 ‚Üí Real) ‚âÉ‚Çó[Real] (Fin 2 ‚Üí Real) := b.equivFun
  have Av : A v = ![(1 : Real), 0] := by
    ext i
    fin_cases i <;> simp [A, hv, Module.Basis.equivFun_self]
  have Aw : A w = ![(0 : Real), 1] := by
    ext i
    fin_cases i <;> simp [A, hw, Module.Basis.equivFun_self]
  let e : (Fin 2 ‚Üí Real) ‚âÉ·µÉ[Real] (Fin 2 ‚Üí Real) :=
    AffineEquiv.ofLinearEquiv A x0 0
  have hdir_eq : (Real ‚àô v) = L.direction := by
    apply Submodule.eq_of_le_of_finrank_eq
    ¬∑ intro x hx
      rcases (Submodule.mem_span_singleton).1 hx with ‚ü®a, rfl‚ü©
      exact L.direction.smul_mem a hvdir
    ¬∑ have hvdim : Module.finrank Real (Real ‚àô v) = 1 := by
        simpa using (finrank_span_singleton (K := Real) (v := v) hv0)
      simpa [hL] using hvdim
  have hLimage : e '' (L : Set (Fin 2 ‚Üí Real)) = cor1717_xAxis := by
    ext x
    constructor
    ¬∑ rintro ‚ü®y, hy, rfl‚ü©
      have hy_dir : y -·µ• x0 ‚àà L.direction :=
        AffineSubspace.vsub_mem_direction hy hx0L
      have hy_dir' : y -·µ• x0 ‚àà (Real ‚àô v) := by
        simpa [hdir_eq] using hy_dir
      rcases (Submodule.mem_span_singleton).1 hy_dir' with ‚ü®a, ha‚ü©
      have hx' : e y = a ‚Ä¢ ![(1 : Real), 0] := by
        calc
          e y = A (y -·µ• x0) +·µ• (0 : Fin 2 ‚Üí Real) := by
            simp [e, AffineEquiv.ofLinearEquiv_apply]
          _ = A (a ‚Ä¢ v) +·µ• (0 : Fin 2 ‚Üí Real) := by
            simp [ha]
          _ = a ‚Ä¢ ![(1 : Real), 0] := by
            simp [A, Av, vadd_eq_add]
      simp [cor1717_xAxis, hx']
    ¬∑ intro hx
      have hx1 : x 1 = 0 := by simpa [cor1717_xAxis] using hx
      let a : Real := x 0
      have hx_eq : x = a ‚Ä¢ ![(1 : Real), 0] := by
        ext i
        fin_cases i
        ¬∑ simp [a]
        ¬∑ simp [a, hx1]
      have hmem : a ‚Ä¢ v ‚àà L.direction := by
        exact L.direction.smul_mem a hvdir
      have hxL : a ‚Ä¢ v +·µ• x0 ‚àà (L : Set (Fin 2 ‚Üí Real)) :=
        AffineSubspace.vadd_mem_of_mem_direction hmem hx0L
      refine ‚ü®a ‚Ä¢ v +·µ• x0, hxL, ?_‚ü©
      calc
        e (a ‚Ä¢ v +·µ• x0) = A (a ‚Ä¢ v) +·µ• (0 : Fin 2 ‚Üí Real) := by
          simp [e, AffineEquiv.ofLinearEquiv_apply]
        _ = a ‚Ä¢ ![(1 : Real), 0] := by
          simp [A, Av, vadd_eq_add]
        _ = x := by
          simp [hx_eq]
  have hpimage : e p = cor1717_p := by
    calc
      e p = A w +·µ• (0 : Fin 2 ‚Üí Real) := by
        simp [e, AffineEquiv.ofLinearEquiv_apply, w]
      _ = cor1717_p := by
        simp [Aw, cor1717_p, vadd_eq_add]
  exact ‚ü®e, hLimage, hpimage‚ü©

/-- Crollary 17.1.7 (Convex hull of a closed set need not be closed), particular case: if `S` is
the union of an affine line in `‚Ñù¬≤` and a point not on that line, then `conv(S)` is not closed. -/
theorem not_isClosed_conv_line_union_singleton
    {L : AffineSubspace Real (Fin 2 ‚Üí Real)} {p : Fin 2 ‚Üí Real}
    (hL : Module.finrank Real L.direction = 1) (hp : p ‚àâ (L : Set (Fin 2 ‚Üí Real))) :
    ¬¨ IsClosed (conv ((L : Set (Fin 2 ‚Üí Real)) ‚à™ {p})) := by
  intro hclosed
  rcases exists_affineEquiv_image_line_eq_xAxis_and_map_point hL hp with ‚ü®e, hLimage, hpimage‚ü©
  have hclosed_image : IsClosed (e '' conv ((L : Set (Fin 2 ‚Üí Real)) ‚à™ {p})) := by
    exact (e.toHomeomorphOfFiniteDimensional.isClosed_image).2 hclosed
  have himage_sets :
      e '' ((L : Set (Fin 2 ‚Üí Real)) ‚à™ {p}) =
        cor1717_xAxis ‚à™ {cor1717_p} := by
    ext x
    constructor
    ¬∑ rintro ‚ü®y, hy, rfl‚ü©
      rcases hy with hyL | hyp
      ¬∑ have hx : e y ‚àà cor1717_xAxis := by
          have : e y ‚àà e '' (L : Set (Fin 2 ‚Üí Real)) := ‚ü®y, hyL, rfl‚ü©
          simpa [hLimage] using this
        exact Or.inl hx
      ¬∑ have hy_eq : y = p := by simpa using hyp
        have : e y = cor1717_p := by simpa [hy_eq] using hpimage
        exact Or.inr (by simp [this])
    ¬∑ intro hx
      rcases hx with hx | hx
      ¬∑ have hx' : x ‚àà e '' (L : Set (Fin 2 ‚Üí Real)) := by
          simpa [hLimage] using hx
        rcases hx' with ‚ü®y, hyL, rfl‚ü©
        exact ‚ü®y, Or.inl hyL, rfl‚ü©
      ¬∑ have hx' : x = cor1717_p := by simpa using hx
        refine ‚ü®p, Or.inr (by simp), ?_‚ü©
        simp [hx', hpimage]
  have himage_sets' :
      e '' insert p (L : Set (Fin 2 ‚Üí Real)) = insert cor1717_p cor1717_xAxis := by
    simpa [Set.union_singleton] using himage_sets
  have himage_insert :
      e '' conv (insert p (L : Set (Fin 2 ‚Üí Real))) =
        conv (insert cor1717_p cor1717_xAxis) := by
    calc
      e '' conv (insert p (L : Set (Fin 2 ‚Üí Real))) =
          conv (e '' insert p (L : Set (Fin 2 ‚Üí Real))) := by
        simpa [conv] using
          (AffineMap.image_convexHull
            (f := (e : (Fin 2 ‚Üí Real) ‚Üí·µÉ[Real] (Fin 2 ‚Üí Real)))
            (insert p (L : Set (Fin 2 ‚Üí Real))))
      _ = conv (insert cor1717_p cor1717_xAxis) := by
        simp [himage_sets']
  have himage :
      e '' conv ((L : Set (Fin 2 ‚Üí Real)) ‚à™ {p}) =
        conv (cor1717_xAxis ‚à™ {cor1717_p}) := by
    simpa [Set.union_singleton] using himage_insert
  have hclosed' : IsClosed (conv (cor1717_xAxis ‚à™ {cor1717_p})) := by
    have hclosed_image' :
        IsClosed (e '' conv (insert p (L : Set (Fin 2 ‚Üí Real)))) := by
      simpa [Set.union_singleton] using hclosed_image
    have hclosed'' : IsClosed (conv (insert cor1717_p cor1717_xAxis)) := by
      simpa [himage_insert] using hclosed_image'
    simpa [Set.union_singleton] using hclosed''
  exact cor1717_not_isClosed_conv_xAxis_union_point hclosed'

/-- Convex weights are exactly points in the standard simplex. -/
lemma isConvexWeights_iff_mem_stdSimplex {m : Nat} {w : Fin m ‚Üí Real} :
    IsConvexWeights m w ‚Üî w ‚àà stdSimplex Real (Fin m) := by
  simp [IsConvexWeights, stdSimplex]

/-- The set of convex combinations of `m` points from `closure S`. -/
def convexCombinationSet {n : Nat} (S : Set (Fin n ‚Üí Real)) (m : Nat) : Set (Fin n ‚Üí Real) :=
  {y : Fin n ‚Üí Real |
    ‚àÉ (x : Fin m ‚Üí closure S) (w : Fin m ‚Üí Real),
      IsConvexWeights m w ‚àß
        y = convexCombination n m (fun i => (x i : Fin n ‚Üí Real)) w}

/-- The `m`-point convex-combination set is compact when `closure S` is compact. -/
lemma isCompact_convexCombinationSet_of_isCompact {n m : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS : IsCompact (closure S)) :
    IsCompact (convexCombinationSet (n := n) (S := S) m) := by
  classical
  haveI : CompactSpace (closure S) := (isCompact_iff_compactSpace.mp hS)
  let f : (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) ‚Üí Fin n ‚Üí Real :=
    fun p => convexCombination n m (fun i => (p.2 i : Fin n ‚Üí Real)) p.1
  have hf : Continuous f := by
    classical
    have hf' :
        Continuous fun p : (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) =>
          ‚àë i, (p.1 i) ‚Ä¢ (p.2 i : Fin n ‚Üí Real) := by
      refine (continuous_finset_sum (s := Finset.univ)
        (f := fun i (p : stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) =>
          (p.1 i) ‚Ä¢ (p.2 i : Fin n ‚Üí Real))) ?_
      intro i hi
      have h1 : Continuous fun p : (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) =>
          (p.1 : Fin m ‚Üí Real) i := by
        have h1' : Continuous fun p : (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) =>
            (p.1 : Fin m ‚Üí Real) :=
          continuous_subtype_val.comp continuous_fst
        simpa using (continuous_apply i).comp h1'
      have h2 : Continuous fun p : (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) =>
          (p.2 i : Fin n ‚Üí Real) := by
        have h2' : Continuous fun p : (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)) =>
            (p.2 i) := (continuous_apply i).comp continuous_snd
        exact continuous_subtype_val.comp h2'
      exact h1.smul h2
    simpa [f, convexCombination] using hf'
  have himage :
      convexCombinationSet (n := n) (S := S) m =
        f '' (Set.univ : Set (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S))) := by
    ext y
    constructor
    ¬∑ rintro ‚ü®x, w, hw, rfl‚ü©
      have hw' : w ‚àà stdSimplex Real (Fin m) := (isConvexWeights_iff_mem_stdSimplex).1 hw
      refine ‚ü®(‚ü®w, hw'‚ü©, x), by simp, rfl‚ü©
    ¬∑ rintro ‚ü®p, -, rfl‚ü©
      have hw : IsConvexWeights m (p.1 : Fin m ‚Üí Real) :=
        (isConvexWeights_iff_mem_stdSimplex).2 p.1.property
      exact ‚ü®p.2, (p.1 : Fin m ‚Üí Real), hw, rfl‚ü©
  have hcompact :
      IsCompact
        (f '' (Set.univ : Set (stdSimplex Real (Fin m) √ó (Fin m ‚Üí closure S)))) :=
    (isCompact_univ.image hf)
  simpa [himage] using hcompact

/-- Carath√©odory-style union: `conv (closure S)` is the union of `m`-point combination sets. -/
lemma conv_closure_eq_iUnion_convexCombinationSet {n : Nat} (S : Set (Fin n ‚Üí Real)) :
    conv (closure S) =
      ‚ãÉ m : Fin (n + 2), convexCombinationSet (n := n) (S := S) m := by
  classical
  ext y
  constructor
  ¬∑ intro hy
    rcases caratheodory (n := n) (S := closure S) (x := y) hy with
      ‚ü®m, hm_le, x, w, hxS, hw, hy_eq‚ü©
    have hm_lt : m < n + 2 := Nat.lt_succ_of_le hm_le
    let x' : Fin m ‚Üí closure S := fun i => ‚ü®x i, hxS i‚ü©
    have hy_mem : y ‚àà convexCombinationSet (n := n) (S := S) m := by
      refine ‚ü®x', w, hw, ?_‚ü©
      simpa [x'] using hy_eq
    refine Set.mem_iUnion.2 ?_
    exact ‚ü®‚ü®m, hm_lt‚ü©, by simpa using hy_mem‚ü©
  ¬∑ intro hy
    rcases Set.mem_iUnion.1 hy with ‚ü®m, hm‚ü©
    rcases hm with ‚ü®x, w, hw, rfl‚ü©
    have hcomb :
        IsConvexCombination n m (fun i => (x i : Fin n ‚Üí Real))
          (convexCombination n m (fun i => (x i : Fin n ‚Üí Real)) w) :=
      isConvexCombination_of_isConvexWeights n m (fun i => (x i : Fin n ‚Üí Real)) w hw
    have hxS : ‚àÄ i, (x i : Fin n ‚Üí Real) ‚àà closure S := fun i => (x i).property
    have hmem :
        convexCombination n m (fun i => (x i : Fin n ‚Üí Real)) w ‚àà
          convexHull Real (closure S) := by
      refine (mem_convexHull_iff_exists_fin_isConvexCombination n (closure S) _).2 ?_
      exact ‚ü®m, (fun i => (x i : Fin n ‚Üí Real)), hxS, hcomb‚ü©
    simpa [conv] using hmem

/-- The easy inclusion `conv (closure S) ‚äÜ closure (conv S)`. -/
lemma thm172_conv_closure_subset_closure_conv {n : Nat} {S : Set (Fin n ‚Üí Real)} :
    conv (closure S) ‚äÜ closure (conv S) := by
  have hsub : closure S ‚äÜ closure (conv S) :=
    closure_mono (by
      simpa [conv] using (subset_convexHull Real S))
  have hconv : Convex Real (closure (conv S)) := by
    have hconv' : Convex Real (conv S) := by
      simpa [conv] using (convex_convexHull Real S)
    exact hconv'.closure
  simpa [conv] using (convexHull_min hsub hconv)

/-- Boundedness yields closedness of `conv (closure S)`. -/
lemma thm172_isClosed_conv_closure_of_isBounded {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS : Bornology.IsBounded S) : IsClosed (conv (closure S)) := by
  classical
  have hcompactS : IsCompact (closure S) := hS.isCompact_closure
  have hcompact_comb :
      ‚àÄ m : Fin (n + 2), IsCompact (convexCombinationSet (n := n) (S := S) m) := by
    intro m
    exact isCompact_convexCombinationSet_of_isCompact (n := n) (S := S) (m := m) hcompactS
  have hconv_eq :
      conv (closure S) =
        ‚ãÉ m : Fin (n + 2), convexCombinationSet (n := n) (S := S) m :=
    conv_closure_eq_iUnion_convexCombinationSet (n := n) (S := S)
  have hcompact : IsCompact (conv (closure S)) := by
    have : IsCompact (‚ãÉ m : Fin (n + 2), convexCombinationSet (n := n) (S := S) m) :=
      isCompact_iUnion hcompact_comb
    simpa [hconv_eq] using this
  exact hcompact.isClosed

/-- The bounded inclusion `closure (conv S) ‚äÜ conv (closure S)`. -/
lemma thm172_closure_conv_subset_conv_closure_of_isBounded {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS : Bornology.IsBounded S) : closure (conv S) ‚äÜ conv (closure S) := by
  have hconv_mono : conv S ‚äÜ conv (closure S) := by
    simpa [conv] using (convexHull_mono (subset_closure (s := S)))
  exact closure_minimal hconv_mono (thm172_isClosed_conv_closure_of_isBounded (n := n) (S := S) hS)

/-- Theorem 17.2. If `S` is a bounded set of points in `‚Ñù‚Åø`, then
`closure (conv S) = conv (closure S)`. In particular, if `S` is closed and bounded, then
`conv S` is closed and bounded. -/
theorem closure_conv_eq_conv_closure_of_isBounded {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS : Bornology.IsBounded S) :
    closure (conv S) = conv (closure S) := by
  refine Set.Subset.antisymm ?_ ?_
  ¬∑ exact thm172_closure_conv_subset_conv_closure_of_isBounded (n := n) (S := S) hS
  ¬∑ exact thm172_conv_closure_subset_closure_conv (n := n) (S := S)

/-- Theorem 17.2 (in particular). If `S` is closed and bounded, then `conv S` is closed and
bounded. -/
theorem isClosed_and_isBounded_conv_of_isClosed_and_isBounded {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_closed : IsClosed S) (hS_bdd : Bornology.IsBounded S) :
    IsClosed (conv S) ‚àß Bornology.IsBounded (conv S) := by
  have hclosed : IsClosed (conv S) := by
    have hclosed' : IsClosed (conv (closure S)) :=
      thm172_isClosed_conv_closure_of_isBounded (n := n) (S := S) hS_bdd
    simpa [hS_closed.closure_eq] using hclosed'
  have hbdd : Bornology.IsBounded (conv S) := by
    simpa [conv] using (isBounded_convexHull (s := S)).2 hS_bdd
  exact ‚ü®hclosed, hbdd‚ü©

/-- Compactness of a closed bounded subset of `‚Ñù‚Åø`. -/
lemma cor1721_isCompact_S {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_closed : IsClosed S) (hS_bdd : Bornology.IsBounded S) : IsCompact S := by
  have hcomp : IsCompact (closure S) := hS_bdd.isCompact_closure
  simpa [hS_closed.closure_eq] using hcomp

/-- A continuous function on a nonempty compact set is bounded below. -/
lemma cor1721_exists_lowerBound_on_S {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_compact : IsCompact S) (hS_ne : S.Nonempty) {f : (Fin n ‚Üí Real) ‚Üí Real}
    (hf : ContinuousOn f S) : ‚àÉ m : Real, ‚àÄ x ‚àà S, m ‚â§ f x := by
  rcases hS_compact.exists_isMinOn hS_ne hf with ‚ü®x0, hx0S, hx0min‚ü©
  have hx0min' : ‚àÄ x ‚àà S, f x0 ‚â§ f x := by
    simpa [IsMinOn, Filter.eventually_principal] using hx0min
  refine ‚ü®f x0, ?_‚ü©
  intro x hx
  exact hx0min' x hx

/-- Properness of `convexHullFunction` from a global lower bound on `f` over `S`. -/
lemma cor1721_properConvexFunctionOn_convexHullFunction_fExt {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_ne : S.Nonempty) {f : (Fin n ‚Üí Real) ‚Üí Real} {m : Real}
    (hm : ‚àÄ x ‚àà S, m ‚â§ f x) :
    (let fExt : (Fin n ‚Üí Real) ‚Üí EReal := fun x => (f x : EReal) + indicatorFunction S x
    ProperConvexFunctionOn (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt)) := by
  classical
  intro fExt
  have hconv :
      ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt) := by
    simpa using (convexHullFunction_greatest_convex_minorant (g := fExt)).1
  have hle :
      convexHullFunction fExt ‚â§ fExt :=
    (convexHullFunction_greatest_convex_minorant (g := fExt)).2.1
  rcases hS_ne with ‚ü®x0, hx0S‚ü©
  have hmem : (x0, f x0) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt) := by
    refine (mem_epigraph_univ_iff (f := convexHullFunction fExt)).2 ?_
    have hle' := hle x0
    simpa [fExt, indicatorFunction, hx0S] using hle'
  have hne_epi :
      Set.Nonempty (epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt)) :=
    ‚ü®(x0, f x0), hmem‚ü©
  have hconst_conv :
      ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí Real)) (fun _ => (m : EReal)) :=
    (properConvexFunctionOn_const (n := n) m).1
  have hconst_le : (fun _ => (m : EReal)) ‚â§ fExt := by
    intro x
    by_cases hx : x ‚àà S
    ¬∑
      have hmx : (m : EReal) ‚â§ (f x : EReal) :=
        (EReal.coe_le_coe_iff).2 (hm x hx)
      simpa [fExt, indicatorFunction, hx] using hmx
    ¬∑
      simp [fExt, indicatorFunction, hx]
  have hconst_le_fconv :
      (fun _ => (m : EReal)) ‚â§ convexHullFunction fExt :=
    (convexHullFunction_greatest_convex_minorant (g := fExt)).2.2
      (fun _ => (m : EReal)) hconst_conv hconst_le
  have hnotbot :
      ‚àÄ x ‚àà (Set.univ : Set (Fin n ‚Üí Real)), convexHullFunction fExt x ‚â† (‚ä• : EReal) := by
    intro x _ hxbot
    have hle' := hconst_le_fconv x
    have hEq : (m : EReal) = (‚ä• : EReal) := by
      have hle'' := hle'
      simp [hxbot] at hle''
    exact (EReal.coe_ne_bot m) hEq
  exact ‚ü®hconv, hne_epi, by simpa using hnotbot‚ü©

/-- The extension `fExt` never takes the value `‚ä•`. -/
lemma cor1721_fExt_ne_bot {n : Nat} {S : Set (Fin n ‚Üí Real)}
    {f : (Fin n ‚Üí Real) ‚Üí Real} :
    (let fExt : (Fin n ‚Üí Real) ‚Üí EReal :=
      fun x => (f x : EReal) + indicatorFunction S x
    ‚àÄ x, fExt x ‚â† (‚ä• : EReal)) := by
  intro fExt x
  by_cases hx : x ‚àà S <;> simp [fExt, indicatorFunction, hx]

/-- The graph of `f` over a compact set is compact. -/
lemma cor1721_isCompact_graph {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS : IsCompact S) {f : (Fin n ‚Üí Real) ‚Üí Real} (hf : ContinuousOn f S) :
    IsCompact ((fun x => (x, f x)) '' S) := by
  have hcont : ContinuousOn (fun x : Fin n ‚Üí Real => (x, f x)) S := by
    simpa using (continuousOn_id.prodMk hf)
  exact hS.image_of_continuousOn hcont

/-- The convex hull of the graph is compact in `‚Ñù^{n+1}`. -/
lemma cor1721_isCompact_convexHull_graph {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_closed : IsClosed S) (hS_bdd : Bornology.IsBounded S) {f : (Fin n ‚Üí Real) ‚Üí Real}
    (hf : ContinuousOn f S) :
    (let F : Set ((Fin n ‚Üí Real) √ó Real) := (fun x => (x, f x)) '' S
    IsCompact (convexHull ‚Ñù F)) := by
  classical
  intro F
  have hS_compact : IsCompact S := cor1721_isCompact_S (S := S) hS_closed hS_bdd
  have hF_compact : IsCompact F := cor1721_isCompact_graph (S := S) hS_compact (f := f) hf
  let e : ((Fin n ‚Üí Real) √ó Real) ‚âÉL[Real] (Fin (n + 1) ‚Üí Real) :=
    (prodLinearEquiv_append_coord (n := n)).toContinuousLinearEquiv
  let T : Set (Fin (n + 1) ‚Üí Real) := e '' F
  have hT_compact : IsCompact T := hF_compact.image e.continuous
  have hT_bdd : Bornology.IsBounded T := hT_compact.isBounded
  have hT_closed : IsClosed T := hT_compact.isClosed
  have hconv_closed : IsClosed (conv (closure T)) :=
    thm172_isClosed_conv_closure_of_isBounded (n := n + 1) (S := T) hT_bdd
  have hconv_closed' : IsClosed (conv T) := by
    simpa [hT_closed.closure_eq] using hconv_closed
  have hconv_bdd : Bornology.IsBounded (conv T) := by
    simpa [conv] using (isBounded_convexHull (s := T)).2 hT_bdd
  have hconv_compact : IsCompact (conv T) :=
    (Metric.isCompact_iff_isClosed_bounded).2 ‚ü®hconv_closed', hconv_bdd‚ü©
  have hpre : (e.symm : _ ‚Üí _) '' T = F := by
    ext p
    constructor
    ¬∑ rintro ‚ü®y, ‚ü®x, hx, rfl‚ü©, rfl‚ü©
      simpa using hx
    ¬∑ intro hp
      refine ‚ü®e p, ?_, by simp‚ü©
      exact ‚ü®p, hp, rfl‚ü©
  have himage :
      (e.symm : _ ‚Üí _) '' (conv T) = convexHull ‚Ñù F := by
    have h :=
      (LinearMap.image_convexHull (f := e.symm.toLinearMap) (s := T))
    simpa [conv, hpre] using h
  have hcomp_image : IsCompact ((e.symm : _ ‚Üí _) '' conv T) :=
    hconv_compact.image e.symm.continuous
  simpa [himage] using hcomp_image

/-- The Minkowski sum of the vertical ray and the convex hull of the graph is closed. -/
lemma cor1721_isClosed_K_add_convexHull_graph {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_closed : IsClosed S) (hS_bdd : Bornology.IsBounded S) {f : (Fin n ‚Üí Real) ‚Üí Real}
    (hf : ContinuousOn f S) :
    (let F : Set ((Fin n ‚Üí Real) √ó Real) := (fun x => (x, f x)) '' S
    let K : Set ((Fin n ‚Üí Real) √ó Real) := {p | p.1 = 0 ‚àß 0 ‚â§ p.2}
    IsClosed (K + convexHull ‚Ñù F)) := by
  classical
  intro F K
  have hK_closed : IsClosed K := by
    have hK1 : IsClosed {p : (Fin n ‚Üí Real) √ó Real | p.1 = 0} :=
      isClosed_eq continuous_fst continuous_const
    have hK2 : IsClosed {p : (Fin n ‚Üí Real) √ó Real | 0 ‚â§ p.2} :=
      isClosed_le continuous_const continuous_snd
    have hK : K =
        {p : (Fin n ‚Üí Real) √ó Real | p.1 = 0} ‚à© {p : (Fin n ‚Üí Real) √ó Real | 0 ‚â§ p.2} := by
      ext p
      constructor
      ¬∑ intro hp
        exact ‚ü®hp.1, hp.2‚ü©
      ¬∑ intro hp
        exact ‚ü®hp.1, hp.2‚ü©
    simpa [hK] using hK1.inter hK2
  have hF_compact : IsCompact (convexHull ‚Ñù F) := by
    simpa using
      (cor1721_isCompact_convexHull_graph (S := S) hS_closed hS_bdd (f := f) hf)
  exact IsClosed.add_right_of_isCompact hK_closed hF_compact

/-- The epigraph of the convex hull function is `K + convexHull(graph)`. -/
lemma cor1721_epigraph_eq_K_add_convexHull_graph {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_closed : IsClosed S) (hS_bdd : Bornology.IsBounded S) {f : (Fin n ‚Üí Real) ‚Üí Real}
    (hf : ContinuousOn f S) :
    (let fExt : (Fin n ‚Üí Real) ‚Üí EReal := fun x => (f x : EReal) + indicatorFunction S x
    let F : Set ((Fin n ‚Üí Real) √ó Real) := (fun x => (x, f x)) '' S
    let K : Set ((Fin n ‚Üí Real) √ó Real) := {p | p.1 = 0 ‚àß 0 ‚â§ p.2}
    epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt) =
      K + convexHull ‚Ñù F) := by
  classical
  intro fExt F K
  let C : Set ((Fin n ‚Üí Real) √ó Real) := K + convexHull ‚Ñù F
  have hEpi_fExt : epigraph (Set.univ : Set (Fin n ‚Üí Real)) fExt = K + F := by
    ext p
    rcases p with ‚ü®x, Œº‚ü©
    constructor
    ¬∑ intro hp
      have hle : fExt x ‚â§ (Œº : EReal) :=
        (mem_epigraph_univ_iff (f := fExt)).1 hp
      have hx : x ‚àà S := by
        by_contra hx
        have htop : (‚ä§ : EReal) ‚â§ (Œº : EReal) := by
          have hle_top := hle
          simp [fExt, indicatorFunction, hx] at hle_top
        have hEq : (Œº : EReal) = ‚ä§ := (top_le_iff).1 htop
        exact (EReal.coe_ne_top _ hEq).elim
      have hle' : (f x : EReal) ‚â§ (Œº : EReal) := by
        simpa [fExt, indicatorFunction, hx] using hle
      have hle'' : f x ‚â§ Œº := (EReal.coe_le_coe_iff).1 hle'
      have hk : (0, Œº - f x) ‚àà K := by
        refine ‚ü®by simp, ?_‚ü©
        linarith
      have hq : (x, f x) ‚àà F := ‚ü®x, hx, rfl‚ü©
      have hsum : (0, Œº - f x) + (x, f x) = (x, Œº) := by
        ext <;> simp [sub_eq_add_neg, add_comm, add_left_comm]
      exact (Set.mem_add).2 ‚ü®(0, Œº - f x), hk, (x, f x), hq, hsum‚ü©
    ¬∑ intro hp
      rcases (Set.mem_add).1 hp with ‚ü®k, hk, q, hq, hsum‚ü©
      rcases hq with ‚ü®x', hx', rfl‚ü©
      have hsum0 := congrArg Prod.fst hsum
      have hx_eq : x' = x := by
        simpa [hk.1, add_comm, add_left_comm, add_assoc] using hsum0
      have hx : x ‚àà S := by
        simpa [hx_eq] using hx'
      have hle' : (f x : EReal) ‚â§ ((f x + k.2 : Real) : EReal) := by
        have hle'' : f x ‚â§ f x + k.2 := by
          exact le_add_of_nonneg_right hk.2
        exact (EReal.coe_le_coe_iff).2 hle''
      have hmem : fExt x ‚â§ ((f x + k.2 : Real) : EReal) := by
        simpa [fExt, indicatorFunction, hx] using hle'
      have hle : fExt x ‚â§ (Œº : EReal) := by
        have hsum1 := congrArg Prod.snd hsum
        have hsum3 : k.2 + f x = Œº := by
          simpa [hx_eq] using hsum1
        simpa [hsum3, add_comm, add_left_comm, add_assoc] using hmem
      exact (mem_epigraph_univ_iff (f := fExt)).2 hle
  have hK_conv : Convex Real K := by
    intro p hp q hq a b ha hb hsum
    rcases hp with ‚ü®hp1, hp2‚ü©
    rcases hq with ‚ü®hq1, hq2‚ü©
    refine ‚ü®?_, ?_‚ü©
    ¬∑
      have : (a ‚Ä¢ p + b ‚Ä¢ q).1 = 0 := by
        simp [hp1, hq1]
      simpa using this
    ¬∑
      have hp2' : 0 ‚â§ a * p.2 := mul_nonneg ha hp2
      have hq2' : 0 ‚â§ b * q.2 := mul_nonneg hb hq2
      have : 0 ‚â§ a * p.2 + b * q.2 := add_nonneg hp2' hq2'
      simpa [smul_eq_mul, add_comm, add_left_comm, add_assoc] using this
  have hconvHull_epi :
      convexHull ‚Ñù (epigraph (Set.univ : Set (Fin n ‚Üí Real)) fExt) = C := by
    have hconv_add :
        convexHull ‚Ñù (K + F) = convexHull ‚Ñù K + convexHull ‚Ñù F := by
      simpa using (convexHull_add (R := Real) (s := K) (t := F))
    simpa [hEpi_fExt, C, hK_conv.convexHull_eq] using hconv_add
  have hconvFun_eq :
      convexHullFunction fExt =
        fun x =>
          sInf ((fun Œº : ‚Ñù => (Œº : EReal)) '' { Œº : ‚Ñù | (x, Œº) ‚àà C }) := by
    funext x
    simp [convexHullFunction_eq_inf_section, hconvHull_epi, C]
  ext p
  rcases p with ‚ü®x, Œº‚ü©
  constructor
  ¬∑ intro hp
    have hle : convexHullFunction fExt x ‚â§ (Œº : EReal) :=
      (mem_epigraph_univ_iff (f := convexHullFunction fExt)).1 hp
    have hle' :
        sInf ((fun Œº : ‚Ñù => (Œº : EReal)) '' { Œº : ‚Ñù | (x, Œº) ‚àà C }) ‚â§ (Œº : EReal) := by
      simpa [hconvFun_eq] using hle
    let Fx : Set ((Fin n ‚Üí Real) √ó Real) := convexHull ‚Ñù F ‚à© {q | q.1 = x}
    have hFx_nonempty : Fx.Nonempty := by
      by_contra hFx
      have hSx_empty :
          { Œº : ‚Ñù | (x, Œº) ‚àà C } = ‚àÖ := by
        ext Œº'
        constructor
        ¬∑ intro hŒº'
          rcases (Set.mem_add).1 hŒº' with ‚ü®k, hk, q, hq, hsum‚ü©
          have hq1 : q.1 = x := by
            have hsum0 := congrArg Prod.fst hsum
            simpa [hk.1] using hsum0
          have hFx' : q ‚àà Fx := ‚ü®hq, hq1‚ü©
          exact (hFx ‚ü®q, hFx'‚ü©).elim
        ¬∑ intro hŒº'
          cases hŒº'
      have htop : (‚ä§ : EReal) ‚â§ (Œº : EReal) := by
        have hle_top := hle'
        simp [hSx_empty] at hle_top
      have hEq : (Œº : EReal) = ‚ä§ := (top_le_iff).1 htop
      exact (EReal.coe_ne_top _ hEq).elim
    have hFx_compact : IsCompact Fx := by
      have hF_compact : IsCompact (convexHull ‚Ñù F) := by
        simpa using
          (cor1721_isCompact_convexHull_graph (S := S) hS_closed hS_bdd (f := f) hf)
      have hclosed :
          IsClosed {q : (Fin n ‚Üí Real) √ó Real | q.1 = x} :=
        isClosed_eq continuous_fst continuous_const
      simpa [Fx] using hF_compact.inter_right hclosed
    have hcont_snd : ContinuousOn (fun q : (Fin n ‚Üí Real) √ó Real => q.2) Fx := by
      simpa using (continuous_snd.continuousOn : ContinuousOn (fun q => q.2) Fx)
    rcases hFx_compact.exists_isMinOn hFx_nonempty hcont_snd with
      ‚ü®q0, hq0Fx, hq0min‚ü©
    rcases hq0Fx with ‚ü®hq0F, hq0x‚ü©
    have hq0x' : q0.1 = x := by
      simpa using hq0x
    have hq0eq : q0 = (x, q0.2) := by
      ext <;> simp [hq0x']
    have hq0C : (x, q0.2) ‚àà C := by
      have hK0 : (0, (0 : Real)) ‚àà K := by
        simp [K]
      have hmem := Set.add_mem_add (s := K) (t := convexHull ‚Ñù F) hK0 hq0F
      have hmem' : (0, (0 : Real)) + q0 ‚àà C := by
        simpa [C] using hmem
      have hsum : (0, (0 : Real)) + q0 = (x, q0.2) := by
        rw [hq0eq]
        ext <;> simp
      exact hsum ‚ñ∏ hmem'
    have hq0min' : ‚àÄ q ‚àà Fx, q0.2 ‚â§ q.2 := by
      have hq0min' :
          ‚àÄ·∂† q in Filter.principal Fx, q0.2 ‚â§ q.2 := by
        simpa [IsMinOn, IsMinFilter] using hq0min
      simpa [Filter.eventually_principal] using hq0min'
    have hq0lb :
        ‚àÄ Œº' ‚àà { Œº : ‚Ñù | (x, Œº) ‚àà C }, q0.2 ‚â§ Œº' := by
      intro Œº' hŒº'
      rcases (Set.mem_add).1 hŒº' with ‚ü®k, hk, q, hq, hsum‚ü©
      have hq1 : q.1 = x := by
        have hsum0 := congrArg Prod.fst hsum
        simpa [hk.1] using hsum0
      have hqFx : q ‚àà Fx := ‚ü®hq, hq1‚ü©
      have hq0le : q0.2 ‚â§ q.2 := hq0min' q hqFx
      have hqle : q.2 ‚â§ Œº' := by
        have hsum1 := congrArg Prod.snd hsum
        have hsum2 : q.2 + k.2 = Œº' := by
          simpa [add_comm, add_left_comm, add_assoc] using hsum1
        linarith [hk.2, hsum2]
      exact le_trans hq0le hqle
    have hSx_eq :
        sInf ((fun Œº : ‚Ñù => (Œº : EReal)) '' { Œº : ‚Ñù | (x, Œº) ‚àà C }) =
          (q0.2 : EReal) := by
      have hle_sInf :
          sInf ((fun Œº : ‚Ñù => (Œº : EReal)) '' { Œº : ‚Ñù | (x, Œº) ‚àà C }) ‚â§ (q0.2 : EReal) :=
        sInf_le ‚ü®q0.2, hq0C, rfl‚ü©
      have hge_sInf :
          (q0.2 : EReal) ‚â§
            sInf ((fun Œº : ‚Ñù => (Œº : EReal)) '' { Œº : ‚Ñù | (x, Œº) ‚àà C }) := by
        refine le_sInf ?_
        intro z hz
        rcases hz with ‚ü®Œº', hŒº', rfl‚ü©
        exact (EReal.coe_le_coe_iff).2 (hq0lb Œº' hŒº')
      exact le_antisymm hle_sInf hge_sInf
    have hq0leŒº : q0.2 ‚â§ Œº := by
      have hle'' : (q0.2 : EReal) ‚â§ (Œº : EReal) := by
        simpa [hSx_eq] using hle'
      exact (EReal.coe_le_coe_iff).1 hle''
    have hk : (0, Œº - q0.2) ‚àà K := by
      refine ‚ü®by simp, ?_‚ü©
      linarith
    have hsum : (0, Œº - q0.2) + q0 = (x, Œº) := by
      ext <;> simp [hq0x', sub_eq_add_neg, add_comm, add_left_comm]
    exact (Set.mem_add).2 ‚ü®(0, Œº - q0.2), hk, q0, hq0F, hsum‚ü©
  ¬∑ intro hp
    have hle' :
        sInf ((fun Œº : ‚Ñù => (Œº : EReal)) '' { Œº : ‚Ñù | (x, Œº) ‚àà C }) ‚â§ (Œº : EReal) :=
      sInf_le ‚ü®Œº, hp, rfl‚ü©
    have hle : convexHullFunction fExt x ‚â§ (Œº : EReal) := by
      simpa [hconvFun_eq] using hle'
    exact (mem_epigraph_univ_iff (f := convexHullFunction fExt)).2 hle

/-- Closedness of the epigraph of the convex hull function for `fExt`. -/
lemma cor1721_isClosed_epigraph_convexHullFunction_fExt {n : Nat} {S : Set (Fin n ‚Üí Real)}
    (hS_closed : IsClosed S) (hS_bdd : Bornology.IsBounded S) {f : (Fin n ‚Üí Real) ‚Üí Real}
    (hf : ContinuousOn f S) :
    (let fExt : (Fin n ‚Üí Real) ‚Üí EReal := fun x => (f x : EReal) + indicatorFunction S x
    IsClosed (epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt))) := by
  classical
  intro fExt
  let F : Set ((Fin n ‚Üí Real) √ó Real) := (fun x => (x, f x)) '' S
  let K : Set ((Fin n ‚Üí Real) √ó Real) := {p | p.1 = 0 ‚àß 0 ‚â§ p.2}
  have hclosed :
      IsClosed (K + convexHull ‚Ñù F) := by
    simpa [F, K] using
      (cor1721_isClosed_K_add_convexHull_graph (S := S) hS_closed hS_bdd (f := f) hf)
  have hEq :
      epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt) =
        K + convexHull ‚Ñù F := by
    simpa [fExt, F, K] using
      (cor1721_epigraph_eq_K_add_convexHull_graph (S := S) hS_closed hS_bdd (f := f) hf)
  simpa [hEq] using hclosed

/-- Corollary 17.2.1. Let `S` be a nonempty closed bounded set in `‚Ñù‚Åø`. Let `f` be a continuous
real-valued function on `S`, and extend it by `f(x) = +‚àû` for `x ‚àâ S`. Then `conv f` (here:
`convexHullFunction` applied to the extension) is a closed proper convex function. -/
theorem closedConvex_and_properConvexFunctionOn_convexHullFunction_of_continuousOn_closed_bounded
    {n : Nat} {S : Set (Fin n ‚Üí Real)} (hS_ne : S.Nonempty) (hS_closed : IsClosed S)
    (hS_bdd : Bornology.IsBounded S) {f : (Fin n ‚Üí Real) ‚Üí Real} (hf : ContinuousOn f S) :
    (let fExt : (Fin n ‚Üí Real) ‚Üí EReal := fun x => (f x : EReal) + indicatorFunction S x
    ClosedConvexFunction (n := n) (convexHullFunction fExt) ‚àß
      ProperConvexFunctionOn (S := (Set.univ : Set (Fin n ‚Üí Real))) (convexHullFunction fExt)) := by
  classical
  let fExt : (Fin n ‚Üí Real) ‚Üí EReal := fun x => (f x : EReal) + indicatorFunction S x
  have hS_compact : IsCompact S := cor1721_isCompact_S (S := S) hS_closed hS_bdd
  rcases cor1721_exists_lowerBound_on_S (S := S) hS_compact hS_ne hf with ‚ü®m, hm‚ü©
  have hproper :
      ProperConvexFunctionOn (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt) := by
    simpa [fExt] using
      (cor1721_properConvexFunctionOn_convexHullFunction_fExt (S := S) hS_ne (f := f) hm)
  have hclosed_epi :
      IsClosed (epigraph (Set.univ : Set (Fin n ‚Üí Real)) (convexHullFunction fExt)) := by
    simpa [fExt] using
      (cor1721_isClosed_epigraph_convexHullFunction_fExt (S := S) hS_closed hS_bdd (f := f) hf)
  have hclosed_sub :
      ‚àÄ Œ± : Real, IsClosed {x | convexHullFunction fExt x ‚â§ (Œ± : EReal)} :=
    (lowerSemicontinuous_iff_closed_sublevel_iff_closed_epigraph
      (f := convexHullFunction fExt)).2.mpr hclosed_epi
  have hls : LowerSemicontinuous (convexHullFunction fExt) :=
    (lowerSemicontinuous_iff_closed_sublevel_iff_closed_epigraph
      (f := convexHullFunction fExt)).1.mpr hclosed_sub
  have hclosed :
      ClosedConvexFunction (convexHullFunction fExt) :=
    (properConvexFunction_closed_iff_lowerSemicontinuous
      (f := convexHullFunction fExt) hproper).2 hls
  exact ‚ü®hclosed, hproper‚ü©

/-- Definition 17.2.2 (A convex function defined as a supremum), LaTeX label `def:h`.

Let `S ‚äÜ ‚Ñù‚Åø` and let `f : S ‚Üí (‚Ñù ‚à™ {+‚àû})` (modeled here as `f : S ‚Üí EReal`). Define
`h : ‚Ñù‚Åø ‚Üí (‚Ñù ‚à™ {+‚àû})` by

`h z = sup { ‚ü™z, x‚ü´ - f x | x ‚àà S }`.

In `Fin n ‚Üí ‚Ñù`, the inner product `‚ü™z, x‚ü´` is expressed as `‚àë i, z i * x i`. -/
noncomputable def supremumInnerSub {n : Nat} (S : Set (Fin n ‚Üí Real)) (f : S ‚Üí EReal)
    (z : Fin n ‚Üí Real) :
    EReal :=
  sSup (Set.range fun x : S => ((‚àë i, z i * (x.1 i) : Real) : EReal) - f x)

end Section17
end Chap04
