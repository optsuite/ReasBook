import Mathlib
import ConvexAnalysis_Rockafellar_1970.Chapters.Chap04.section19_part3

open scoped BigOperators
open scoped Pointwise
open Topology

section Chap19
section Section19

/-- Helper for Theorem 19.1: cones generated by finite sets are polyhedral. -/
lemma helperForTheorem_19_1_cone_polyhedral_of_finite_generators
    {m : ‚Ñï} {T : Set (Fin m ‚Üí ‚Ñù)} (hT : Set.Finite T) :
    IsPolyhedralConvexSet m (cone m T) := by
  classical
  by_cases hTne : T.Nonempty
  ¬∑
    let P : Set (Fin m ‚Üí ‚Ñù) :=
      {xStar : Fin m ‚Üí ‚Ñù | ‚àÄ x ‚àà cone m T, dotProduct x xStar ‚â§ 0}
    have hP_eq :
        P = ‚ãÇ t ‚àà T, closedHalfSpaceLE m t 0 := by
      simpa [P] using
        (helperForTheorem_19_1_cone_polar_eq_iInter_halfspaces (m := m) (T := T))
    have hP_poly : IsPolyhedralConvexSet m P := by
      let Œπ : Type := {t : Fin m ‚Üí ‚Ñù // t ‚àà T}
      have hfin : Fintype Œπ := hT.fintype
      refine ‚ü®Œπ, hfin, (fun i : Œπ => i.1), (fun _ => (0 : ‚Ñù)), ?_‚ü©
      have hP_eq' :
          P = ‚ãÇ i : Œπ, closedHalfSpaceLE m i.1 0 := by
        have hrewrite :
            (‚ãÇ i : Œπ, closedHalfSpaceLE m i.1 0) =
              ‚ãÇ t ‚àà T, closedHalfSpaceLE m t 0 :=
          Set.iInter_subtype (p := fun t : Fin m ‚Üí ‚Ñù => t ‚àà T)
            (s := fun i : Œπ => closedHalfSpaceLE m i.1 0)
        calc
          P = ‚ãÇ t ‚àà T, closedHalfSpaceLE m t 0 := hP_eq
          _ = ‚ãÇ i : Œπ, closedHalfSpaceLE m i.1 0 := hrewrite.symm
      simpa [hP_eq'] using hP_eq'
    have hP_conv : Convex ‚Ñù P :=
      helperForTheorem_19_1_polyhedral_isConvex (n := m) (C := P) hP_poly
    have hP_gen : IsFinitelyGeneratedConvexSet m P :=
      (helperForTheorem_19_1_closed_finiteFaces_imp_finitelyGenerated (n := m) (C := P) hP_conv)
        (helperForTheorem_19_1_polyhedral_imp_closed_finiteFaces (n := m) (C := P) hP_poly)
    rcases hP_gen with ‚ü®S‚ÇÄ, S‚ÇÅ, hS‚ÇÄfin, hS‚ÇÅfin, hP_mixed‚ü©
    have h0mem : (0 : Fin m ‚Üí ‚Ñù) ‚àà P := by
      refine Set.mem_setOf.2 ?_
      intro x hx
      simp
    have h0mem_mixed :
        (0 : Fin m ‚Üí ‚Ñù) ‚àà mixedConvexHull (n := m) S‚ÇÄ S‚ÇÅ := by
      simpa [hP_mixed] using h0mem
    have hS‚ÇÄne : S‚ÇÄ.Nonempty := by
      by_contra hS‚ÇÄne
      have hS‚ÇÄempty : S‚ÇÄ = (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) :=
        (Set.not_nonempty_iff_eq_empty).1 hS‚ÇÄne
      have hmix_empty :
          mixedConvexHull (n := m) S‚ÇÄ S‚ÇÅ = (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) := by
        simpa [hS‚ÇÄempty] using (mixedConvexHull_empty_points (n := m) (S‚ÇÅ := S‚ÇÅ))
      have : (0 : Fin m ‚Üí ‚Ñù) ‚àà (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) := by
        simpa [hmix_empty] using h0mem_mixed
      exact (Set.notMem_empty (0 : Fin m ‚Üí ‚Ñù)) this
    have hpolar_P :
        {xStar : Fin m ‚Üí ‚Ñù | ‚àÄ x ‚àà P, dotProduct x xStar ‚â§ 0} =
          (‚ãÇ s ‚àà S‚ÇÄ, closedHalfSpaceLE m s 0) ‚à©
            (‚ãÇ d ‚àà S‚ÇÅ, closedHalfSpaceLE m d 0) := by
      have hpolar_mixed :
          {xStar : Fin m ‚Üí ‚Ñù |
              ‚àÄ x ‚àà mixedConvexHull (n := m) S‚ÇÄ S‚ÇÅ, dotProduct x xStar ‚â§ 0} =
            (‚ãÇ s ‚àà S‚ÇÄ, closedHalfSpaceLE m s 0) ‚à©
              (‚ãÇ d ‚àà S‚ÇÅ, closedHalfSpaceLE m d 0) :=
        helperForTheorem_19_1_polar_of_mixedConvexHull_eq_iInter
          (n := m) (S‚ÇÄ := S‚ÇÄ) (S‚ÇÅ := S‚ÇÅ) hS‚ÇÄne
      simpa [hP_mixed] using hpolar_mixed
    have hS‚ÇÄ_poly : IsPolyhedralConvexSet m (‚ãÇ s ‚àà S‚ÇÄ, closedHalfSpaceLE m s 0) := by
      let Œπ0 : Type := {s : Fin m ‚Üí ‚Ñù // s ‚àà S‚ÇÄ}
      have hfin0 : Fintype Œπ0 := hS‚ÇÄfin.fintype
      refine ‚ü®Œπ0, hfin0, (fun i : Œπ0 => i.1), (fun _ => (0 : ‚Ñù)), ?_‚ü©
      have hrewrite :
          (‚ãÇ i : Œπ0, closedHalfSpaceLE m i.1 0) =
            ‚ãÇ s ‚àà S‚ÇÄ, closedHalfSpaceLE m s 0 :=
        Set.iInter_subtype (p := fun s : Fin m ‚Üí ‚Ñù => s ‚àà S‚ÇÄ)
          (s := fun i : Œπ0 => closedHalfSpaceLE m i.1 0)
      simpa [hrewrite] using hrewrite.symm
    have hS‚ÇÅ_poly : IsPolyhedralConvexSet m (‚ãÇ d ‚àà S‚ÇÅ, closedHalfSpaceLE m d 0) := by
      let Œπ1 : Type := {d : Fin m ‚Üí ‚Ñù // d ‚àà S‚ÇÅ}
      have hfin1 : Fintype Œπ1 := hS‚ÇÅfin.fintype
      refine ‚ü®Œπ1, hfin1, (fun i : Œπ1 => i.1), (fun _ => (0 : ‚Ñù)), ?_‚ü©
      have hrewrite :
          (‚ãÇ i : Œπ1, closedHalfSpaceLE m i.1 0) =
            ‚ãÇ d ‚àà S‚ÇÅ, closedHalfSpaceLE m d 0 :=
        Set.iInter_subtype (p := fun d : Fin m ‚Üí ‚Ñù => d ‚àà S‚ÇÅ)
          (s := fun i : Œπ1 => closedHalfSpaceLE m i.1 0)
      simpa [hrewrite] using hrewrite.symm
    have hpolar_poly :
        IsPolyhedralConvexSet m
          ((‚ãÇ s ‚àà S‚ÇÄ, closedHalfSpaceLE m s 0) ‚à©
            (‚ãÇ d ‚àà S‚ÇÅ, closedHalfSpaceLE m d 0)) :=
      helperForTheorem_19_1_polyhedral_inter hS‚ÇÄ_poly hS‚ÇÅ_poly
    have hpolar_poly' :
        IsPolyhedralConvexSet m {xStar : Fin m ‚Üí ‚Ñù | ‚àÄ x ‚àà P, dotProduct x xStar ‚â§ 0} := by
      simpa [hpolar_P] using hpolar_poly
    have hcone : IsConvexCone m (cone m T) := by
      have hcone' : IsConvexCone m (convexConeGenerated m T) :=
        isConvexCone_convexConeGenerated (n := m) (S‚ÇÅ := T)
      simpa [cone_eq_convexConeGenerated (n := m) (S‚ÇÅ := T)] using hcone'
    have hsmul :
        ‚àÄ ‚¶Éc : ‚Ñù‚¶Ñ, 0 < c ‚Üí ‚àÄ ‚¶Éx : Fin m ‚Üí ‚Ñù‚¶Ñ, x ‚àà cone m T ‚Üí c ‚Ä¢ x ‚àà cone m T := by
      intro c hc x hx
      exact hcone.1 x hx c hc
    have hadd :
        ‚àÄ ‚¶Éx : Fin m ‚Üí ‚Ñù‚¶Ñ, x ‚àà cone m T ‚Üí
          ‚àÄ ‚¶Éy : Fin m ‚Üí ‚Ñù‚¶Ñ, y ‚àà cone m T ‚Üí x + y ‚àà cone m T := by
      intro x hx y hy
      exact isConvexCone_add_closed m (cone m T) hcone x hx y hy
    set K : ConvexCone ‚Ñù (Fin m ‚Üí ‚Ñù) :=
      { carrier := cone m T, smul_mem' := hsmul, add_mem' := hadd } with hK
    have h0ray : (0 : Fin m ‚Üí ‚Ñù) ‚àà ray m T := by
      change (0 : Fin m ‚Üí ‚Ñù) ‚àà Set.insert 0 (rayNonneg m T)
      exact (Set.mem_insert_iff).2 (Or.inl rfl)
    have h0cone : (0 : Fin m ‚Üí ‚Ñù) ‚àà cone m T := by
      have h0conv : (0 : Fin m ‚Üí ‚Ñù) ‚àà conv (ray m T) :=
        (subset_convexHull (ùïú := ‚Ñù) (s := ray m T)) h0ray
      simpa [cone, conv] using h0conv
    have hKne : (K : Set (Fin m ‚Üí ‚Ñù)).Nonempty := by
      refine ‚ü®0, ?_‚ü©
      simpa [hK] using h0cone
    have hpolarpolar :
        {xStar : Fin m ‚Üí ‚Ñù |
            ‚àÄ x ‚àà {z : Fin m ‚Üí ‚Ñù | ‚àÄ x ‚àà (K : Set (Fin m ‚Üí ‚Ñù)), dotProduct x z ‚â§ 0},
              dotProduct x xStar ‚â§ 0} =
          closure (K : Set (Fin m ‚Üí ‚Ñù)) :=
      section16_polar_polar_eq_closure_convexCone (K := K) hKne
    have hpolarpolar' :
        {xStar : Fin m ‚Üí ‚Ñù | ‚àÄ x ‚àà P, dotProduct x xStar ‚â§ 0} =
          closure (cone m T) := by
      simpa [P, hK] using hpolarpolar
    have hclosed_cone : IsClosed (cone m T) :=
      helperForTheorem_19_1_isClosed_cone_of_finite_generators (m := m) (T := T) hT
    have hpolarpolar'' :
        {xStar : Fin m ‚Üí ‚Ñù | ‚àÄ x ‚àà P, dotProduct x xStar ‚â§ 0} =
          cone m T := by
      simpa [hclosed_cone.closure_eq] using hpolarpolar'
    simpa [hpolarpolar''] using hpolar_poly'
  ¬∑
    have hTempty : T = (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) :=
      (Set.not_nonempty_iff_eq_empty).1 hTne
    subst hTempty
    have hcone : cone m (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) = ({0} : Set (Fin m ‚Üí ‚Ñù)) := by
      have hrayNonneg : rayNonneg m (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) = (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) := by
        ext x
        simp [rayNonneg]
      have hray : ray m (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) = ({0} : Set (Fin m ‚Üí ‚Ñù)) := by
        ext x
        constructor
        ¬∑ intro hx
          have hx'' :
              x ‚àà Set.insert (0 : Fin m ‚Üí ‚Ñù) (rayNonneg m (‚àÖ : Set (Fin m ‚Üí ‚Ñù))) := by
            simpa [ray] using hx
          have hx''' : x = 0 ‚à® x ‚àà rayNonneg m (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) :=
            (Set.mem_insert_iff).1 hx''
          have hx' : x = 0 ‚à® x ‚àà (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) := by
            simpa [hrayNonneg] using hx'''
          cases hx' with
          | inl hx0 => simpa [hx0]
          | inr hxempty => exact (Set.notMem_empty x hxempty).elim
        ¬∑ intro hx
          have hx0 : x = 0 := by
            simpa [Set.mem_singleton_iff] using hx
          have hx' : x = 0 ‚à® x ‚àà (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) := by
            left
            exact hx0
          have hx'' : x = 0 ‚à® x ‚àà rayNonneg m (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) := by
            simpa [hrayNonneg] using hx'
          have hxmem :
              x ‚àà Set.insert (0 : Fin m ‚Üí ‚Ñù) (rayNonneg m (‚àÖ : Set (Fin m ‚Üí ‚Ñù))) :=
            (Set.mem_insert_iff).2 hx''
          simpa [ray] using hxmem
      calc
        cone m (‚àÖ : Set (Fin m ‚Üí ‚Ñù)) = conv (ray m (‚àÖ : Set (Fin m ‚Üí ‚Ñù))) := rfl
        _ = conv ({0} : Set (Fin m ‚Üí ‚Ñù)) := by simpa [hray]
        _ = ({0} : Set (Fin m ‚Üí ‚Ñù)) := by
          simp [conv]
    simpa [hcone] using (helperForTheorem_19_1_zero_set_polyhedral (m := m))

/-- Helper for Theorem 19.1: mixed convex hull of finitely many generators is polyhedral. -/
lemma helperForTheorem_19_1_mixedConvexHull_polyhedral_of_finite_generators
    {n : ‚Ñï} {S‚ÇÄ S‚ÇÅ : Set (Fin n ‚Üí ‚Ñù)} (hS‚ÇÄ : Set.Finite S‚ÇÄ) (hS‚ÇÅ : Set.Finite S‚ÇÅ) :
    IsPolyhedralConvexSet n (mixedConvexHull (n := n) S‚ÇÄ S‚ÇÅ) := by
  classical
  have hlift :
      Set.Finite (liftingSet (n := n) S‚ÇÄ S‚ÇÅ) := by
    have hS‚ÇÄ' :
        Set.Finite
          ((fun x : Fin n ‚Üí ‚Ñù =>
              (Fin.cases (1 : ‚Ñù) x : Fin (n + 1) ‚Üí ‚Ñù)) '' S‚ÇÄ) := by
      exact
        hS‚ÇÄ.image
          (fun x : Fin n ‚Üí ‚Ñù => (Fin.cases (1 : ‚Ñù) x : Fin (n + 1) ‚Üí ‚Ñù))
    have hS‚ÇÅ' :
        Set.Finite
          ((fun x : Fin n ‚Üí ‚Ñù =>
              (Fin.cases (0 : ‚Ñù) x : Fin (n + 1) ‚Üí ‚Ñù)) '' S‚ÇÅ) := by
      exact
        hS‚ÇÅ.image
          (fun x : Fin n ‚Üí ‚Ñù => (Fin.cases (0 : ‚Ñù) x : Fin (n + 1) ‚Üí ‚Ñù))
    have hfinite :
        Set.Finite
          (((fun x : Fin n ‚Üí ‚Ñù =>
                (Fin.cases (1 : ‚Ñù) x : Fin (n + 1) ‚Üí ‚Ñù)) '' S‚ÇÄ) ‚à™
            ((fun x : Fin n ‚Üí ‚Ñù =>
                (Fin.cases (0 : ‚Ñù) x : Fin (n + 1) ‚Üí ‚Ñù)) '' S‚ÇÅ)) := by
      exact hS‚ÇÄ'.union hS‚ÇÅ'
    simpa [liftingSet] using hfinite
  have hcone :
      IsPolyhedralConvexSet (n + 1) (liftingCone (n := n) S‚ÇÄ S‚ÇÅ) := by
    have hcone' :
        IsPolyhedralConvexSet (n + 1) (cone (n + 1) (liftingSet (n := n) S‚ÇÄ S‚ÇÅ)) := by
      exact
        helperForTheorem_19_1_cone_polyhedral_of_finite_generators
          (m := n + 1) (T := liftingSet (n := n) S‚ÇÄ S‚ÇÅ) hlift
    simpa [liftingCone] using hcone'
  have hhyper : IsPolyhedralConvexSet (n + 1) (liftingHyperplane n) :=
    helperForTheorem_19_1_liftingHyperplane_polyhedral n
  have hinter :
      IsPolyhedralConvexSet (n + 1)
        (liftingCone (n := n) S‚ÇÄ S‚ÇÅ ‚à© liftingHyperplane n) :=
    helperForTheorem_19_1_polyhedral_inter hcone hhyper
  have hpre :
      IsPolyhedralConvexSet n
        {x : Fin n ‚Üí ‚Ñù |
          (Fin.cases (1 : ‚Ñù) x) ‚àà
            (liftingCone (n := n) S‚ÇÄ S‚ÇÅ ‚à© liftingHyperplane n)} :=
    helperForTheorem_19_1_lift_preimage_polyhedral (n := n)
      (K := liftingCone (n := n) S‚ÇÄ S‚ÇÅ ‚à© liftingHyperplane n) hinter
  have hEq :
      {x : Fin n ‚Üí ‚Ñù |
          (Fin.cases (1 : ‚Ñù) x) ‚àà liftingCone (n := n) S‚ÇÄ S‚ÇÅ ‚àß
          (Fin.cases (1 : ‚Ñù) x) ‚àà liftingHyperplane n} =
        mixedConvexHull (n := n) S‚ÇÄ S‚ÇÅ := by
    ext x
    constructor
    ¬∑ intro hx
      have hx' :
          (Fin.cases (1 : ‚Ñù) x) ‚àà
            (liftingCone (n := n) S‚ÇÄ S‚ÇÅ ‚à© liftingHyperplane n) := by
        exact hx
      exact
        (mem_mixedConvexHull_iff_lift_mem_liftingCone_inter_liftingHyperplane (n := n)
            (S‚ÇÄ := S‚ÇÄ) (S‚ÇÅ' := S‚ÇÅ) (x := x)).2 hx'
    ¬∑ intro hx
      have hx' :=
        (mem_mixedConvexHull_iff_lift_mem_liftingCone_inter_liftingHyperplane (n := n)
            (S‚ÇÄ := S‚ÇÄ) (S‚ÇÅ' := S‚ÇÅ) (x := x)).1 hx
      exact hx'
  simpa [hEq, Set.mem_inter] using hpre

/-- Helper for Theorem 19.1: finitely generated convex sets are polyhedral. -/
lemma helperForTheorem_19_1_finitelyGenerated_imp_polyhedral
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} (hc : Convex ‚Ñù C) :
    IsFinitelyGeneratedConvexSet n C ‚Üí IsPolyhedralConvexSet n C := by
  intro hgen
  rcases hgen with ‚ü®S‚ÇÄ, S‚ÇÅ, hS‚ÇÄfinite, hS‚ÇÅfinite, hEq‚ü©
  have hpoly :
      IsPolyhedralConvexSet n (mixedConvexHull (n := n) S‚ÇÄ S‚ÇÅ) := by
    exact
      helperForTheorem_19_1_mixedConvexHull_polyhedral_of_finite_generators
        (n := n) (S‚ÇÄ := S‚ÇÄ) (S‚ÇÅ := S‚ÇÅ) hS‚ÇÄfinite hS‚ÇÅfinite
  simpa [hEq] using hpoly

/-- Theorem 19.1: The following properties of a convex set `C` are equivalent:
(a) `C` is polyhedral; (b) `C` is closed and has only finitely many faces;
(c) `C` is finitely generated. -/
theorem polyhedral_closed_finiteFaces_finitelyGenerated_equiv
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} (hc : Convex ‚Ñù C) :
    [IsPolyhedralConvexSet n C,
        (IsClosed C ‚àß {C' : Set (Fin n ‚Üí ‚Ñù) | IsFace (ùïú := ‚Ñù) C C'}.Finite),
      IsFinitelyGeneratedConvexSet n C].TFAE := by
  classical
  refine List.tfae_of_cycle ?_ ?_
  ¬∑
    refine List.IsChain.cons_cons ?_ ?_
    ¬∑ intro hpoly
      exact helperForTheorem_19_1_polyhedral_imp_closed_finiteFaces (n := n) (C := C) hpoly
    ¬∑
      refine List.IsChain.cons_cons ?_ ?_
      ¬∑ intro hclosed
        exact
          helperForTheorem_19_1_closed_finiteFaces_imp_finitelyGenerated (n := n) (C := C) hc
            hclosed
      ¬∑ exact List.IsChain.singleton _
  ¬∑ intro hgen
    exact helperForTheorem_19_1_finitelyGenerated_imp_polyhedral (n := n) (C := C) hc hgen

/-- Helper for Corollary 19.1.1: positive multiples preserve `IsDirectionOf`. -/
lemma helperForCorollary_19_1_1_isDirectionOf_posMul
    {n : ‚Ñï} {C' : Set (Fin n ‚Üí ‚Ñù)} {d : Fin n ‚Üí ‚Ñù}
    (hd : IsDirectionOf (ùïú := ‚Ñù) C' d) {t : ‚Ñù} (ht : 0 < t) :
    IsDirectionOf (ùïú := ‚Ñù) C' (t ‚Ä¢ d) := by
  rcases hd with ‚ü®x, hdne, hC'‚ü©
  have htne : t ‚â† 0 := ne_of_gt ht
  refine ‚ü®x, ?_, ?_‚ü©
  ¬∑ intro hzero
    have hzero' := smul_eq_zero.mp hzero
    cases hzero' with
    | inl ht0 => exact htne ht0
    | inr hd0 => exact hdne hd0
  ¬∑
    apply Set.Subset.antisymm
    ¬∑ intro y hy
      have hy' : y ‚àà (fun s : ‚Ñù => x + s ‚Ä¢ d) '' Set.Ici (0 : ‚Ñù) := by
        simpa [hC'] using hy
      rcases hy' with ‚ü®u, hu, rfl‚ü©
      have hnonneg : 0 ‚â§ u / t := by
        exact div_nonneg hu (le_of_lt ht)
      refine ‚ü®u / t, hnonneg, ?_‚ü©
      calc
        x + (u / t) ‚Ä¢ (t ‚Ä¢ d)
            = x + (u * t‚Åª¬π) ‚Ä¢ (t ‚Ä¢ d) := by
                simp [div_eq_mul_inv]
        _ = x + ((u * t‚Åª¬π) * t) ‚Ä¢ d := by
              simp [smul_smul, mul_comm]
        _ = x + u ‚Ä¢ d := by
              simp [htne]
    ¬∑ intro y hy
      rcases hy with ‚ü®s, hs, rfl‚ü©
      have hs' : 0 ‚â§ s * t := mul_nonneg hs (le_of_lt ht)
      have hmem :
          x + (s * t) ‚Ä¢ d ‚àà (fun u : ‚Ñù => x + u ‚Ä¢ d) '' Set.Ici (0 : ‚Ñù) := by
        exact ‚ü®s * t, hs', rfl‚ü©
      have hcalc : x + s ‚Ä¢ (t ‚Ä¢ d) = x + (s * t) ‚Ä¢ d := by
        simp [smul_smul, mul_comm]
      have hmem' :
          x + s ‚Ä¢ (t ‚Ä¢ d) ‚àà (fun u : ‚Ñù => x + u ‚Ä¢ d) '' Set.Ici (0 : ‚Ñù) := by
        simpa [hcalc] using hmem
      simpa [hC'] using hmem'

/-- Helper for Corollary 19.1.1: positive multiples of an extreme direction are extreme
directions. -/
lemma helperForCorollary_19_1_1_extremeDirection_posMul_closed
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} {d : Fin n ‚Üí ‚Ñù}
    (hd : IsExtremeDirection (ùïú := ‚Ñù) C d) {t : ‚Ñù} (ht : 0 < t) :
    IsExtremeDirection (ùïú := ‚Ñù) C (t ‚Ä¢ d) := by
  rcases hd with ‚ü®C', hhalf, hdir‚ü©
  refine ‚ü®C', hhalf, ?_‚ü©
  exact
    helperForCorollary_19_1_1_isDirectionOf_posMul (C' := C') (d := d) hdir ht

/-- Helper for Corollary 19.1.1: extreme directions are nonzero. -/
lemma helperForCorollary_19_1_1_extremeDirection_ne_zero
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} {d : Fin n ‚Üí ‚Ñù}
    (hd : IsExtremeDirection (ùïú := ‚Ñù) C d) : d ‚â† 0 := by
  rcases hd with ‚ü®C', hhalf, hdir‚ü©
  rcases hdir with ‚ü®x, hdne, hC'‚ü©
  exact hdne

/-- Helper for Corollary 19.1.1: if any extreme direction exists, then there are infinitely many
extreme-direction vectors. -/
lemma helperForCorollary_19_1_1_infinite_extremeDirections_of_exists
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} :
    (‚àÉ d : Fin n ‚Üí ‚Ñù, IsExtremeDirection (ùïú := ‚Ñù) C d) ‚Üí
      Set.Infinite {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} := by
  classical
  intro hex
  rcases hex with ‚ü®d, hd‚ü©
  let f : ‚Ñï ‚Üí Fin n ‚Üí ‚Ñù := fun k => ((k : ‚Ñù) + 1) ‚Ä¢ d
  have hdne : d ‚â† 0 :=
    helperForCorollary_19_1_1_extremeDirection_ne_zero (C := C) hd
  have hinj : Function.Injective f := by
    intro m n hmn
    have hinj' : Function.Injective (fun t : ‚Ñù => t ‚Ä¢ d) :=
      smul_left_injective ‚Ñù (x := d) hdne
    have hmn' : ((m : ‚Ñù) + 1) ‚Ä¢ d = ((n : ‚Ñù) + 1) ‚Ä¢ d := by
      simpa [f] using hmn
    have h' : ((m : ‚Ñù) + 1) = ((n : ‚Ñù) + 1) := hinj' hmn'
    have h'' : (m : ‚Ñù) = (n : ‚Ñù) := by
      linarith
    exact (Nat.cast_inj (R := ‚Ñù)).1 h''
  have hinjOn : Set.InjOn f (Set.univ : Set ‚Ñï) :=
    Function.Injective.injOn hinj
  have hUnivInf : (Set.univ : Set ‚Ñï).Infinite := by
    simpa using (Set.infinite_univ : (Set.univ : Set ‚Ñï).Infinite)
  have hImageInf : (f '' (Set.univ : Set ‚Ñï)).Infinite :=
    Set.Infinite.image (s := (Set.univ : Set ‚Ñï)) (f := f) hinjOn hUnivInf
  have hsubset :
      f '' (Set.univ : Set ‚Ñï) ‚äÜ
        {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} := by
    intro x hx
    rcases hx with ‚ü®k, hk, rfl‚ü©
    have hk0 : (0 : ‚Ñù) ‚â§ (k : ‚Ñù) := by
      exact_mod_cast (Nat.zero_le k)
    have hkpos : 0 < ((k : ‚Ñù) + 1) := by
      linarith
    exact
      helperForCorollary_19_1_1_extremeDirection_posMul_closed
        (C := C) (d := d) hd hkpos
  exact Set.Infinite.mono hsubset hImageInf

/-- Helper for Corollary 19.1.1: finiteness of extreme-direction vectors is equivalent to the
absence of extreme directions. -/
lemma helperForCorollary_19_1_1_finite_extremeDirections_iff_not_exists
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} :
    Set.Finite {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} ‚Üî
      ¬¨ ‚àÉ d : Fin n ‚Üí ‚Ñù, IsExtremeDirection (ùïú := ‚Ñù) C d := by
  classical
  constructor
  ¬∑ intro hfinite hex
    have hinf :
        Set.Infinite {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} :=
      helperForCorollary_19_1_1_infinite_extremeDirections_of_exists (C := C) hex
    exact hinf hfinite
  ¬∑ intro hno
    have hempty :
        {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} =
          (‚àÖ : Set (Fin n ‚Üí ‚Ñù)) := by
      apply Set.eq_empty_iff_forall_notMem.mpr
      intro d hd
      exact hno ‚ü®d, hd‚ü©
    simpa [hempty] using (Set.finite_empty : Set.Finite (‚àÖ : Set (Fin n ‚Üí ‚Ñù)))

/-- Helper for Corollary 19.1.1: polyhedral sets admit finitely many extreme-direction
representatives up to positive scaling. -/
lemma helperForCorollary_19_1_1_correct_direction_statement_via_representatives
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} :
    IsPolyhedralConvexSet n C ‚Üí
      ‚àÉ S : Set (Fin n ‚Üí ‚Ñù),
        Set.Finite S ‚àß
          (‚àÄ d, IsExtremeDirection (ùïú := ‚Ñù) C d ‚Üí
            ‚àÉ d0 ‚àà S, ‚àÉ t : ‚Ñù, 0 < t ‚àß d = t ‚Ä¢ d0) ‚àß
          S ‚äÜ {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} := by
  intro hpoly
  have hfaces :
      IsClosed C ‚àß {C' : Set (Fin n ‚Üí ‚Ñù) | IsFace (ùïú := ‚Ñù) C C'}.Finite :=
    helperForTheorem_19_1_polyhedral_imp_closed_finiteFaces (n := n) (C := C) hpoly
  exact
    helperForTheorem_19_1_finiteFaces_imp_exists_finite_direction_reps
      (n := n) (C := C) hfaces.2

/-- Helper for Corollary 19.1.1: in `Fin 1 ‚Üí ‚Ñù`, every vector is a multiple of the all-ones
vector. -/
lemma helperForCorollary_19_1_1_fin1_eq_smul_one (x : Fin 1 ‚Üí ‚Ñù) :
    x = (x 0) ‚Ä¢ (fun _ : Fin 1 => (1 : ‚Ñù)) := by
  ext i
  fin_cases i
  simp

/-- Helper for Corollary 19.1.1: compute the dot product with the constant `-1` vector in
`Fin 1 ‚Üí ‚Ñù`. -/
lemma helperForCorollary_19_1_1_dotProduct_neg_one (x : Fin 1 ‚Üí ‚Ñù) :
    x ‚¨ù·µ• (fun _ : Fin 1 => (-1 : ‚Ñù)) = - x 0 := by
  simp [dotProduct]

/-- Helper for Corollary 19.1.1: the nonnegative half-space in `Fin 1 ‚Üí ‚Ñù` is polyhedral. -/
lemma helperForCorollary_19_1_1_polyhedral_halfspace_fin1 :
    IsPolyhedralConvexSet 1 (closedHalfSpaceLE 1 (fun _ => (-1 : ‚Ñù)) 0) := by
  classical
  refine ‚ü®PUnit, ?_, (fun _ : PUnit => (fun _ : Fin 1 => (-1 : ‚Ñù))), (fun _ => (0 : ‚Ñù)), ?_‚ü©
  ¬∑ infer_instance
  ¬∑ ext x
    simp [closedHalfSpaceLE]

/-- Helper for Corollary 19.1.1: the nonnegative half-space in `Fin 1 ‚Üí ‚Ñù` has direction
vector `1`. -/
lemma helperForCorollary_19_1_1_halfspace_fin1_isDirectionOf :
    IsDirectionOf (ùïú := ‚Ñù)
      (closedHalfSpaceLE 1 (fun _ => (-1 : ‚Ñù)) 0)
      (fun _ : Fin 1 => (1 : ‚Ñù)) := by
  classical
  let d : Fin 1 ‚Üí ‚Ñù := fun _ => (1 : ‚Ñù)
  refine ‚ü®0, ?_, ?_‚ü©
  ¬∑ intro hzero
    have hzero' : (1 : ‚Ñù) = 0 := by
      have h := congrArg (fun f => f 0) hzero
      simpa [d] using h
    exact one_ne_zero hzero'
  ¬∑
    ext x
    constructor
    ¬∑ intro hx
      have hx' : x ‚¨ù·µ• (fun _ : Fin 1 => (-1 : ‚Ñù)) ‚â§ 0 := by
        simpa [closedHalfSpaceLE] using hx
      have hx0 : 0 ‚â§ x 0 := by
        have hdot := helperForCorollary_19_1_1_dotProduct_neg_one x
        linarith [hx', hdot]
      refine ‚ü®x 0, hx0, ?_‚ü©
      have hxrepr : x = (x 0) ‚Ä¢ d := by
        have hxrepr' :
            x = (x 0) ‚Ä¢ (fun _ : Fin 1 => (1 : ‚Ñù)) :=
          helperForCorollary_19_1_1_fin1_eq_smul_one x
        simpa [d] using hxrepr'
      have hxrepr' : (x 0) ‚Ä¢ d = x := hxrepr.symm
      calc
        (0 : Fin 1 ‚Üí ‚Ñù) + (x 0) ‚Ä¢ d = (x 0) ‚Ä¢ d := by simp
        _ = x := hxrepr'
    ¬∑ intro hx
      rcases hx with ‚ü®t, ht, rfl‚ü©
      have ht0 : 0 ‚â§ t := by
        simpa using ht
      have ht' : -t ‚â§ 0 := by linarith [ht0]
      have hle :
          ((0 : Fin 1 ‚Üí ‚Ñù) + t ‚Ä¢ d) ‚¨ù·µ• (fun _ : Fin 1 => (-1 : ‚Ñù)) ‚â§ 0 := by
        simpa [d, dotProduct, Fin.sum_univ_succ] using ht'
      simpa [closedHalfSpaceLE] using hle

/-- Helper for Corollary 19.1.1: the nonnegative half-space in `Fin 1 ‚Üí ‚Ñù` has an extreme
direction. -/
lemma helperForCorollary_19_1_1_halfspace_fin1_extremeDirection :
    IsExtremeDirection (ùïú := ‚Ñù)
      (closedHalfSpaceLE 1 (fun _ => (-1 : ‚Ñù)) 0)
      (fun _ : Fin 1 => (1 : ‚Ñù)) := by
  let C : Set (Fin 1 ‚Üí ‚Ñù) := closedHalfSpaceLE 1 (fun _ => (-1 : ‚Ñù)) 0
  let d : Fin 1 ‚Üí ‚Ñù := fun _ => (1 : ‚Ñù)
  have hpoly : IsPolyhedralConvexSet 1 C := by
    simpa [C] using helperForCorollary_19_1_1_polyhedral_halfspace_fin1
  have hconv : Convex ‚Ñù C :=
    helperForTheorem_19_1_polyhedral_isConvex (n := 1) (C := C) hpoly
  have hface : IsFace (ùïú := ‚Ñù) C C := isFace_self (C := C) hconv
  have hdir : IsDirectionOf (ùïú := ‚Ñù) C d := by
    simpa [C, d] using helperForCorollary_19_1_1_halfspace_fin1_isDirectionOf
  have hhalf : IsHalfLineFace (ùïú := ‚Ñù) C C := by
    refine ‚ü®hface, ?_‚ü©
    refine ‚ü®d, hdir‚ü©
  exact ‚ü®C, hhalf, hdir‚ü©

/-- Helper for Corollary 19.1.1: a polyhedral half-space in `Fin 1 ‚Üí ‚Ñù` has an extreme
direction. -/
lemma helperForCorollary_19_1_1_counterexample_polyhedral_has_extremeDirection :
    ‚àÉ C : Set (Fin 1 ‚Üí ‚Ñù),
      IsPolyhedralConvexSet 1 C ‚àß
        ‚àÉ d : Fin 1 ‚Üí ‚Ñù, IsExtremeDirection (ùïú := ‚Ñù) C d := by
  let C : Set (Fin 1 ‚Üí ‚Ñù) := closedHalfSpaceLE 1 (fun _ => (-1 : ‚Ñù)) 0
  let d : Fin 1 ‚Üí ‚Ñù := fun _ => (1 : ‚Ñù)
  have hpoly : IsPolyhedralConvexSet 1 C := by
    simpa [C] using helperForCorollary_19_1_1_polyhedral_halfspace_fin1
  have hd : IsExtremeDirection (ùïú := ‚Ñù) C d := by
    simpa [C, d] using helperForCorollary_19_1_1_halfspace_fin1_extremeDirection
  refine ‚ü®C, hpoly, ?_‚ü©
  refine ‚ü®d, hd‚ü©

/-- Helper for Corollary 19.1.1: a polyhedral set can have infinitely many extreme-direction
vectors. -/
lemma helperForCorollary_19_1_1_counterexample_infinite_extremeDirections :
    ‚àÉ C : Set (Fin 1 ‚Üí ‚Ñù),
      IsPolyhedralConvexSet 1 C ‚àß
        Set.Infinite {d : Fin 1 ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} := by
  rcases helperForCorollary_19_1_1_counterexample_polyhedral_has_extremeDirection with
    ‚ü®C, hpoly, hd‚ü©
  rcases hd with ‚ü®d, hd‚ü©
  refine ‚ü®C, hpoly, ?_‚ü©
  have hex : ‚àÉ d : Fin 1 ‚Üí ‚Ñù, IsExtremeDirection (ùïú := ‚Ñù) C d := ‚ü®d, hd‚ü©
  exact
    helperForCorollary_19_1_1_infinite_extremeDirections_of_exists (C := C) hex

/-- Helper for Corollary 19.1.1: the extreme-direction set for a polyhedral half-space in
`Fin 1 ‚Üí ‚Ñù` is not finite. -/
lemma helperForCorollary_19_1_1_counterexample_not_finite_extremeDirections :
    ‚àÉ C : Set (Fin 1 ‚Üí ‚Ñù),
      IsPolyhedralConvexSet 1 C ‚àß
        ¬¨ Set.Finite {d : Fin 1 ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} := by
  rcases helperForCorollary_19_1_1_counterexample_infinite_extremeDirections with
    ‚ü®C, hpoly, hInf‚ü©
  refine ‚ü®C, hpoly, ?_‚ü©
  intro hfin
  exact hInf hfin

/-- Helper for Corollary 19.1.1: the statement fails already in dimension `1`. -/
lemma helperForCorollary_19_1_1_statement_false_fin1 :
    ¬¨ (‚àÄ C : Set (Fin 1 ‚Üí ‚Ñù),
        IsPolyhedralConvexSet 1 C ‚Üí
          Set.Finite {x : Fin 1 ‚Üí ‚Ñù | IsExtremePoint (ùïú := ‚Ñù) C x} ‚àß
            Set.Finite {d : Fin 1 ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d}) := by
  intro h
  rcases helperForCorollary_19_1_1_counterexample_not_finite_extremeDirections with
    ‚ü®C, hpoly, hnotfin‚ü©
  have h' := h C hpoly
  exact hnotfin h'.2

/-- Helper for Corollary 19.1.1: the global finite-extreme-direction-vector claim is false,
as witnessed by the dimension-`1` counterexample. -/
lemma helperForCorollary_19_1_1_statement_false_global :
    ¬¨ (‚àÄ (n : ‚Ñï) (C : Set (Fin n ‚Üí ‚Ñù)),
        IsPolyhedralConvexSet n C ‚Üí
          Set.Finite {x : Fin n ‚Üí ‚Ñù | IsExtremePoint (ùïú := ‚Ñù) C x} ‚àß
            Set.Finite {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d}) := by
  intro h
  have hfin1 :
      ‚àÄ C : Set (Fin 1 ‚Üí ‚Ñù),
        IsPolyhedralConvexSet 1 C ‚Üí
          Set.Finite {x : Fin 1 ‚Üí ‚Ñù | IsExtremePoint (ùïú := ‚Ñù) C x} ‚àß
            Set.Finite {d : Fin 1 ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d} := by
    intro C hpoly
    simpa using h 1 C hpoly
  exact helperForCorollary_19_1_1_statement_false_fin1 hfin1

/-- Helper for Corollary 19.1.1: polyhedral sets have finitely many extreme points. -/
lemma helperForCorollary_19_1_1_finite_extremePoints_of_polyhedral
    {n : ‚Ñï} {C : Set (Fin n ‚Üí ‚Ñù)} :
    IsPolyhedralConvexSet n C ‚Üí
      Set.Finite {x : Fin n ‚Üí ‚Ñù | IsExtremePoint (ùïú := ‚Ñù) C x} := by
  intro hpoly
  have hfaces :
      IsClosed C ‚àß {C' : Set (Fin n ‚Üí ‚Ñù) | IsFace (ùïú := ‚Ñù) C C'}.Finite :=
    helperForTheorem_19_1_polyhedral_imp_closed_finiteFaces (n := n) (C := C) hpoly
  have hconv : Convex ‚Ñù C :=
    helperForTheorem_19_1_polyhedral_isConvex n C hpoly
  exact
    helperForTheorem_19_1_finiteFaces_imp_finite_extremePoints
      (n := n) (C := C) hconv hfaces.2

/-- Helper for Corollary 19.1.1: corrected direction claim via finitely many
extreme-direction representatives up to positive scaling. -/
theorem polyhedralConvexSet_finite_extremePoints_extremeDirectionRepresentatives
    (n : ‚Ñï) (C : Set (Fin n ‚Üí ‚Ñù)) :
    IsPolyhedralConvexSet n C ‚Üí
      Set.Finite {x : Fin n ‚Üí ‚Ñù | IsExtremePoint (ùïú := ‚Ñù) C x} ‚àß
        (‚àÉ S : Set (Fin n ‚Üí ‚Ñù),
          Set.Finite S ‚àß
            (‚àÄ d, IsExtremeDirection (ùïú := ‚Ñù) C d ‚Üí
              ‚àÉ d0 ‚àà S, ‚àÉ t : ‚Ñù, 0 < t ‚àß d = t ‚Ä¢ d0) ‚àß
            S ‚äÜ {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d}) := by
  intro hpoly
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact
      helperForCorollary_19_1_1_finite_extremePoints_of_polyhedral
        (n := n) (C := C) hpoly
  ¬∑ exact
      helperForCorollary_19_1_1_correct_direction_statement_via_representatives
        (n := n) (C := C) hpoly

/-- Corollary 19.1.1 (formalized via rays): A polyhedral convex set has at most a finite number
of extreme points and finitely many extreme-direction representatives up to positive scaling. -/
theorem polyhedralConvexSet_finite_extremePoints_extremeDirections
    (n : ‚Ñï) (C : Set (Fin n ‚Üí ‚Ñù)) :
    IsPolyhedralConvexSet n C ‚Üí
      Set.Finite {x : Fin n ‚Üí ‚Ñù | IsExtremePoint (ùïú := ‚Ñù) C x} ‚àß
        (‚àÉ S : Set (Fin n ‚Üí ‚Ñù),
          Set.Finite S ‚àß
            (‚àÄ d, IsExtremeDirection (ùïú := ‚Ñù) C d ‚Üí
              ‚àÉ d0 ‚àà S, ‚àÉ t : ‚Ñù, 0 < t ‚àß d = t ‚Ä¢ d0) ‚àß
            S ‚äÜ {d : Fin n ‚Üí ‚Ñù | IsExtremeDirection (ùïú := ‚Ñù) C d}) := by
  exact
    polyhedralConvexSet_finite_extremePoints_extremeDirectionRepresentatives
      n C

/-- Text 19.0.8: A convex function `f : ‚Ñù^n ‚Üí (-‚àû, +‚àû]` is called polyhedral convex if its
epigraph `epi f = {(x, Œº) ‚àà ‚Ñù^{n+1} | f x ‚â§ Œº}` is a polyhedral convex set in `‚Ñù^{n+1}`. -/
def IsPolyhedralConvexFunction (n : ‚Ñï) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Prop :=
  ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f ‚àß
    IsPolyhedralConvexSet (n + 1)
      ((fun p => (prodLinearEquiv_append (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)

/-- Helper for Text 19.0.9: every value of the max-affine-plus-indicator expression
is different from `‚ä•`. -/
lemma helperForText_19_0_9_rhsRepresentation_ne_bot
    {n k m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ≤ : Fin m ‚Üí ‚Ñù} {x : Fin n ‚Üí ‚Ñù} :
    ((sSup {r : ‚Ñù |
        ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
      indicatorFunction
        (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
          (‚àë j, y j * b i j) ‚â§ Œ≤ i})
        x ‚â† (‚ä• : EReal) := by
  by_cases hx : x ‚àà ({y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
      (‚àë j, y j * b i j) ‚â§ Œ≤ i} : Set (Fin n ‚Üí ‚Ñù))
  ¬∑ simp [indicatorFunction, hx]
  ¬∑ simp [indicatorFunction, hx]

/-- Helper for Text 19.0.9: any function with the theorem's
max-affine-plus-indicator representation never takes the value `‚ä•`. -/
lemma helperForText_19_0_9_representable_pointwise_ne_bot
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hrepr :
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x)) :
    ‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal) := by
  intro x
  rcases hrepr with ‚ü®k, m, b, Œ≤, _hk_le_m, hEq‚ü©
  subst hEq
  simpa using
    (helperForText_19_0_9_rhsRepresentation_ne_bot (n := n) (k := k) (m := m)
      (b := b) (Œ≤ := Œ≤) (x := x))

/-- Helper for Text 19.0.9: the max-affine-plus-indicator schema is never the
constant `‚ä•` function. -/
lemma helperForText_19_0_9_constBot_ne_rhsRepresentation
    {n k m : ‚Ñï} (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù) :
    (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) ‚â†
      (fun x =>
        ((sSup {r : ‚Ñù |
            ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
          indicatorFunction
            (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              (‚àë j, y j * b i j) ‚â§ Œ≤ i})
            x) := by
  intro hEq
  let rhs : (Fin n ‚Üí ‚Ñù) ‚Üí EReal :=
    fun x =>
      ((sSup {r : ‚Ñù |
          ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
        indicatorFunction
          (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            (‚àë j, y j * b i j) ‚â§ Œ≤ i})
          x
  have hEqRhs : (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) = rhs := by
    simpa [rhs] using hEq
  have hRhsAtZero_ne_bot : rhs 0 ‚â† (‚ä• : EReal) := by
    simpa [rhs] using
      (helperForText_19_0_9_rhsRepresentation_ne_bot (n := n) (k := k) (m := m)
        (b := b) (Œ≤ := Œ≤) (x := 0))
  have hEqAtZero : (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) 0 = rhs 0 :=
    congrArg (fun g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal => g 0) hEqRhs
  have hRhsAtZero_eq_bot : rhs 0 = (‚ä• : EReal) := by
    simpa using hEqAtZero.symm
  exact hRhsAtZero_ne_bot hRhsAtZero_eq_bot

/-- Helper for Text 19.0.9: any function admitting the theorem's max-affine-plus-indicator
representation is not the constant bottom function. -/
lemma helperForText_19_0_9_representable_ne_constBot
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hrepr :
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x)) :
    f ‚â† (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) := by
  intro hconst
  have hPointwise : ‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal) :=
    helperForText_19_0_9_representable_pointwise_ne_bot (n := n) (f := f) hrepr
  have hAtZero : f 0 = (‚ä• : EReal) := by
    simpa using congrArg (fun g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal => g 0) hconst
  exact (hPointwise 0) hAtZero

/-- Helper for Text 19.0.9: a max-affine-plus-indicator representation yields both
pointwise non-`‚ä•` values and global non-constancy at `‚ä•`. -/
lemma helperForText_19_0_9_representation_implies_nonbot_and_ne_constBot
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hrepr :
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x)) :
    (‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal)) ‚àß
      f ‚â† (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) := by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact helperForText_19_0_9_representable_pointwise_ne_bot (n := n) (f := f) hrepr
  ¬∑ exact helperForText_19_0_9_representable_ne_constBot (n := n) (f := f) hrepr

/-- Helper for Text 19.0.9: the constant function `x ‚Ü¶ ‚ä•` satisfies
`IsPolyhedralConvexFunction` in the present formalization. -/
lemma helperForText_19_0_9_constBot_isPolyhedralConvexFunction
    (n : ‚Ñï) :
    IsPolyhedralConvexFunction n (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) := by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ have hEpiUniv :
      epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) =
        Set.univ := by
      ext p
      constructor
      ¬∑ intro hp
        trivial
      ¬∑ intro hp
        refine ‚ü®?_, ?_‚ü©
        ¬∑ trivial
        ¬∑ simp
    simpa [ConvexFunctionOn, hEpiUniv] using
      (convex_univ : Convex ‚Ñù (Set.univ : Set ((Fin n ‚Üí ‚Ñù) √ó ‚Ñù)))
  ¬∑ classical
    let Œπ : Type := PEmpty
    let b : Œπ ‚Üí Fin (n + 1) ‚Üí ‚Ñù := fun i => nomatch i
    let Œ≤ : Œπ ‚Üí ‚Ñù := fun i => nomatch i
    have hPolyUniv : IsPolyhedralConvexSet (n + 1) (Set.univ : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
      refine ‚ü®Œπ, inferInstance, b, Œ≤, ?_‚ü©
      ext x
      simp [closedHalfSpaceLE, b, Œ≤]
    have hEpiUniv :
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) =
          Set.univ := by
      ext p
      constructor
      ¬∑ intro hp
        trivial
      ¬∑ intro hp
        refine ‚ü®?_, ?_‚ü©
        ¬∑ trivial
        ¬∑ simp
    have hImageUnivCoord :
        ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal))) =
          (Set.univ : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
      rw [hEpiUniv, Set.image_univ]
      exact Set.range_eq_univ.mpr (prodLinearEquiv_append_coord (n := n)).surjective
    have hpolyCoord :
        IsPolyhedralConvexSet (n + 1)
          ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal))) := by
      simpa [hImageUnivCoord] using hPolyUniv
    simpa [prodLinearEquiv_append_coord] using hpolyCoord

/-- Helper for Text 19.0.9: the constant function `x ‚Ü¶ ‚ä•` cannot be represented by the
max-affine-plus-indicator normal form from the theorem statement. -/
lemma helperForText_19_0_9_constBot_not_representable
    (n : ‚Ñï) :
    ¬¨ ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x) := by
  intro hrepr
  have hPointwise :
      ‚àÄ x : Fin n ‚Üí ‚Ñù,
        (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) x ‚â† (‚ä• : EReal) :=
    helperForText_19_0_9_representable_pointwise_ne_bot
      (n := n) (f := (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal))) hrepr
  exact (hPointwise 0) rfl

/-- Helper for Text 19.0.9: the constant function `x ‚Ü¶ ‚ä•` provides both sides of
the counterexample data used to refute the biconditional schema. -/
lemma helperForText_19_0_9_constBot_counterexample_data
    (n : ‚Ñï) :
    IsPolyhedralConvexFunction n (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) ‚àß
      ¬¨ ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
          k ‚â§ m ‚àß
            (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) =
              (fun x =>
                ((sSup {r : ‚Ñù |
                    ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                      r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                  indicatorFunction
                    (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                      (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                    x) := by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact helperForText_19_0_9_constBot_isPolyhedralConvexFunction n
  ¬∑ exact helperForText_19_0_9_constBot_not_representable n

/-- Helper for Text 19.0.9: if the biconditional schema is assumed at a fixed
polyhedral-convex function `f`, then `f` must be pointwise non-`‚ä•`. -/
lemma helperForText_19_0_9_schema_at_polyhedral_function_implies_pointwise_ne_bot
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hSchemaAtF :
      IsPolyhedralConvexFunction n f ‚Üî
        ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
          k ‚â§ m ‚àß
            f =
              (fun x =>
                ((sSup {r : ‚Ñù |
                    ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                      r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                  indicatorFunction
                    (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                      (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                    x))
    (hPoly : IsPolyhedralConvexFunction n f) :
    ‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal) := by
  have hrepr :
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x) :=
    hSchemaAtF.mp hPoly
  exact helperForText_19_0_9_representable_pointwise_ne_bot (n := n) (f := f) hrepr

/-- Helper for Text 19.0.9: the constant-`‚ä•` instance of the biconditional schema
forces a contradiction with pointwise non-`‚ä•`. -/
lemma helperForText_19_0_9_constBot_schema_implies_false
    (n : ‚Ñï)
    (hSchemaAtConstBot :
      IsPolyhedralConvexFunction n (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) ‚Üî
        ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
          k ‚â§ m ‚àß
            (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) =
              (fun x =>
                ((sSup {r : ‚Ñù |
                    ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                      r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                  indicatorFunction
                    (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                      (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                    x)) :
    False := by
  have hPolyConstBot :
      IsPolyhedralConvexFunction n (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) :=
    helperForText_19_0_9_constBot_isPolyhedralConvexFunction n
  have hPointwiseNonBotConstBot :
      ‚àÄ x : Fin n ‚Üí ‚Ñù,
        (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) x ‚â† (‚ä• : EReal) :=
    helperForText_19_0_9_schema_at_polyhedral_function_implies_pointwise_ne_bot
      (n := n) (f := (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)))
      hSchemaAtConstBot hPolyConstBot
  exact (hPointwiseNonBotConstBot 0) rfl

/-- Helper for Text 19.0.9: instantiating the theorem schema at the constant-`‚ä•`
function yields a contradiction in the current `EReal` formalization. -/
lemma helperForText_19_0_9_constBot_breaks_biconditional
    (n : ‚Ñï) :
    ¬¨
      (IsPolyhedralConvexFunction n (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) ‚Üî
        ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
          k ‚â§ m ‚àß
            (fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)) =
              (fun x =>
                ((sSup {r : ‚Ñù |
                    ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                      r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                  indicatorFunction
                    (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                      (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                    x)) := by
  intro hiff
  exact helperForText_19_0_9_constBot_schema_implies_false n hiff

/-- Helper for Text 19.0.9: in each fixed dimension `n`, the constant-`‚ä•`
function is an explicit witness where the biconditional schema fails. -/
lemma helperForText_19_0_9_exists_function_counterexample_at_dimension
    (n : ‚Ñï) :
    ‚àÉ f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal,
      ¬¨
        (IsPolyhedralConvexFunction n f ‚Üî
          ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
            k ‚â§ m ‚àß
              f =
                (fun x =>
                  ((sSup {r : ‚Ñù |
                      ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                        r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                    indicatorFunction
                      (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                        (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                      x)) := by
  refine ‚ü®(fun _ : Fin n ‚Üí ‚Ñù => (‚ä• : EReal)), ?_‚ü©
  exact helperForText_19_0_9_constBot_breaks_biconditional n

/-- Helper for Text 19.0.9: the target biconditional schema cannot hold for all
functions `f : ‚Ñù^n ‚Üí EReal`, since it fails at the constant-`‚ä•` function. -/
lemma helperForText_19_0_9_not_forall_function_schema
    (n : ‚Ñï) :
    ¬¨
      (‚àÄ f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal,
        IsPolyhedralConvexFunction n f ‚Üî
          ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
            k ‚â§ m ‚àß
              f =
                (fun x =>
                  ((sSup {r : ‚Ñù |
                      ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                        r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                    indicatorFunction
                      (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                        (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                      x)) := by
  intro hAll
  rcases helperForText_19_0_9_exists_function_counterexample_at_dimension n with ‚ü®f, hf‚ü©
  exact hf (hAll f)

/-- Helper for Text 19.0.9: a concrete `(n, f)` witness shows the target schema
fails at the constant-`‚ä•` function. -/
lemma helperForText_19_0_9_exists_counterexample_to_schema :
    ‚àÉ n : ‚Ñï, ‚àÉ f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal,
      ¬¨
        (IsPolyhedralConvexFunction n f ‚Üî
          ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
            k ‚â§ m ‚àß
              f =
                (fun x =>
                  ((sSup {r : ‚Ñù |
                      ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                        r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                    indicatorFunction
                      (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                        (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                      x)) := by
  refine ‚ü®0, ?_‚ü©
  refine ‚ü®(fun _ : Fin 0 ‚Üí ‚Ñù => (‚ä• : EReal)), ?_‚ü©
  exact helperForText_19_0_9_constBot_breaks_biconditional 0

/-- Helper for Text 19.0.9: if the biconditional schema held for all dimensions and
functions, it would contradict the explicit counterexample. -/
lemma helperForText_19_0_9_global_schema_implies_false
    (hGlobal :
      ‚àÄ n : ‚Ñï, ‚àÄ f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal,
        IsPolyhedralConvexFunction n f ‚Üî
          ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
            k ‚â§ m ‚àß
              f =
                (fun x =>
                  ((sSup {r : ‚Ñù |
                      ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                        r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                    indicatorFunction
                      (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                        (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                      x)) :
    False := by
  rcases helperForText_19_0_9_exists_counterexample_to_schema with ‚ü®n, f, hNotSchema‚ü©
  exact hNotSchema (hGlobal n f)

/-- Helper for Text 19.0.9: a theorem-schema claiming the biconditional for all dimensions
and functions is refuted by the constant-`‚ä•` counterexample. -/
lemma helperForText_19_0_9_no_global_theorem_schema :
    ¬¨
      (‚àÄ n : ‚Ñï, ‚àÄ f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal,
        IsPolyhedralConvexFunction n f ‚Üî
          ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
            k ‚â§ m ‚àß
              f =
                (fun x =>
                  ((sSup {r : ‚Ñù |
                      ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                        r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                    indicatorFunction
                      (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                        (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                      x)) := by
  intro hGlobal
  exact helperForText_19_0_9_global_schema_implies_false hGlobal

/-- Helper for Text 19.0.9: the finite family of affine-epigraph inequalities
with normals `(b_i, -1)` defines a polyhedral set in `‚Ñù^(n+1)`. -/
lemma helperForText_19_0_9_affineConstraintSet_polyhedral
    {n k m : ‚Ñï} (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù) :
    IsPolyhedralConvexSet (n + 1)
      {z : Fin (n + 1) ‚Üí ‚Ñù |
        ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
          dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} := by
  classical
  let bAff : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
    fun i => if hik : (i : ‚Ñï) < k then Fin.cases (-1 : ‚Ñù) (b i) else 0
  let Œ≤Aff : Fin m ‚Üí ‚Ñù :=
    fun i => if hik : (i : ‚Ñï) < k then Œ≤ i else 0
  refine ‚ü®Fin m, inferInstance, bAff, Œ≤Aff, ?_‚ü©
  ext z
  constructor
  ¬∑ intro hz
    refine Set.mem_iInter.2 ?_
    intro i
    by_cases hik : (i : ‚Ñï) < k
    ¬∑ have hineq : dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i := hz i hik
      simpa [bAff, Œ≤Aff, hik, closedHalfSpaceLE] using hineq
    ¬∑ have htriv : dotProduct z (0 : Fin (n + 1) ‚Üí ‚Ñù) ‚â§ (0 : ‚Ñù) := by
        simp
      simp [bAff, Œ≤Aff, hik, closedHalfSpaceLE] at htriv ‚ä¢
  ¬∑ intro hz i hik
    have hzi : z ‚àà closedHalfSpaceLE (n + 1) (bAff i) (Œ≤Aff i) :=
      Set.mem_iInter.1 hz i
    simpa [bAff, Œ≤Aff, hik, closedHalfSpaceLE] using hzi

/-- Helper for Text 19.0.9: the finite family of domain inequalities
with normals `(b_i, 0)` defines a polyhedral set in `‚Ñù^(n+1)`. -/
lemma helperForText_19_0_9_liftedIndicatorConstraintSet_polyhedral
    {n k m : ‚Ñï} (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù) :
    IsPolyhedralConvexSet (n + 1)
      {z : Fin (n + 1) ‚Üí ‚Ñù |
        ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
          dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i} := by
  classical
  let bDom : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
    fun i => if hki : k ‚â§ (i : ‚Ñï) then Fin.cases (0 : ‚Ñù) (b i) else 0
  let Œ≤Dom : Fin m ‚Üí ‚Ñù :=
    fun i => if hki : k ‚â§ (i : ‚Ñï) then Œ≤ i else 0
  refine ‚ü®Fin m, inferInstance, bDom, Œ≤Dom, ?_‚ü©
  ext z
  constructor
  ¬∑ intro hz
    refine Set.mem_iInter.2 ?_
    intro i
    by_cases hki : k ‚â§ (i : ‚Ñï)
    ¬∑ have hineq : dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i := hz i hki
      simpa [bDom, Œ≤Dom, hki, closedHalfSpaceLE] using hineq
    ¬∑ have htriv : dotProduct z (0 : Fin (n + 1) ‚Üí ‚Ñù) ‚â§ (0 : ‚Ñù) := by
        simp
      simp [bDom, Œ≤Dom, hki, closedHalfSpaceLE] at htriv ‚ä¢
  ¬∑ intro hz i hki
    have hzi : z ‚àà closedHalfSpaceLE (n + 1) (bDom i) (Œ≤Dom i) :=
      Set.mem_iInter.1 hz i
    simpa [bDom, Œ≤Dom, hki, closedHalfSpaceLE] using hzi

/-- Helper for Text 19.0.9: intersecting the affine-epigraph and lifted-domain
constraint families yields a polyhedral set in `‚Ñù^(n+1)`. -/
lemma helperForText_19_0_9_liftedConstraintIntersection_polyhedral
    {n k m : ‚Ñï} (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù) :
    IsPolyhedralConvexSet (n + 1)
      ({z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
            dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i}) := by
  exact
    helperForTheorem_19_1_polyhedral_inter
      (helperForText_19_0_9_affineConstraintSet_polyhedral (n := n) (k := k) (m := m)
        b Œ≤)
      (helperForText_19_0_9_liftedIndicatorConstraintSet_polyhedral
        (n := n) (k := k) (m := m) b Œ≤)

/-- Helper for Text 19.0.9: if the transformed epigraph image is empty, then `f`
admits the max-affine-plus-indicator representation (the `f = ‚ä§` branch). -/
lemma helperForText_19_0_9_empty_transformedEpigraph_implies_representation
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hEmpty :
      ((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) = ‚àÖ) :
    ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
      k ‚â§ m ‚àß
        f =
          fun x =>
            ((sSup {r : ‚Ñù |
                ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
              indicatorFunction
                (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                  (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                x := by
  have hfTop : ‚àÄ x : Fin n ‚Üí ‚Ñù, f x = (‚ä§ : EReal) := by
    intro x
    by_contra hNotTop
    have hExistsMu : ‚àÉ Œº : ‚Ñù, f x ‚â§ (Œº : EReal) := by
      by_cases hBot : f x = (‚ä• : EReal)
      ¬∑ refine ‚ü®0, ?_‚ü©
        simp [hBot]
      ¬∑ refine ‚ü®(f x).toReal, ?_‚ü©
        have hcoe : (((f x).toReal : ‚Ñù) : EReal) = f x := by
          simpa using (EReal.coe_toReal hNotTop hBot)
        simp [hcoe]
    rcases hExistsMu with ‚ü®Œº, hle‚ü©
    have hmemEpi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
      exact (mem_epigraph_univ_iff (f := f)).2 hle
    have hmemImage :
        (prodLinearEquiv_append (n := n)) (x, Œº) ‚àà
          ((fun p => prodLinearEquiv_append (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
      exact ‚ü®(x, Œº), hmemEpi, rfl‚ü©
    have hnotMem :
        (prodLinearEquiv_append (n := n)) (x, Œº) ‚àâ
          ((fun p => prodLinearEquiv_append (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
      simp [hEmpty]
    exact hnotMem hmemImage
  have hfConstTop : f = (fun _ : Fin n ‚Üí ‚Ñù => (‚ä§ : EReal)) := by
    funext x
    exact hfTop x
  refine ‚ü®0, 1, (fun _ _ => (0 : ‚Ñù)), (fun _ => (-1 : ‚Ñù)), Nat.zero_le 1, ?_‚ü©
  calc
    f = (fun _ : Fin n ‚Üí ‚Ñù => (‚ä§ : EReal)) := hfConstTop
    _ =
      (fun x =>
        ((sSup {r : ‚Ñù |
            ‚àÉ i : Fin 1, (i : ‚Ñï) < 0 ‚àß r = (‚àë j, x j * (0 : ‚Ñù)) - (-1 : ‚Ñù)} : ‚Ñù) : EReal) +
          indicatorFunction
            (C := {y : Fin n ‚Üí ‚Ñù | ‚àÄ i : Fin 1, 0 ‚â§ (i : ‚Ñï) ‚Üí
              (‚àë j, y j * (0 : ‚Ñù)) ‚â§ (-1 : ‚Ñù)})
            x) := by
          funext x
          simp [indicatorFunction]

/-- Helper for Text 19.0.9: in the forward direction, the empty transformed-epigraph
branch is discharged by the dedicated `f = ‚ä§` representation lemma. -/
lemma helperForText_19_0_9_polyhedral_nonbot_implies_representation_of_empty_transformedEpigraph
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (_hpolyNonbot :
      IsPolyhedralConvexFunction n f ‚àß
        (‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal)))
    (hEmpty :
      ((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) = ‚àÖ) :
    ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
      k ‚â§ m ‚àß
        f =
          fun x =>
            ((sSup {r : ‚Ñù |
                ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
              indicatorFunction
                (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                  (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                x := by
  exact helperForText_19_0_9_empty_transformedEpigraph_implies_representation
    (n := n) (f := f) hEmpty

/-- Helper for Text 19.0.9: any represented function satisfies the theorem's
pointwise non-`‚ä•` side condition. -/
lemma helperForText_19_0_9_representation_implies_pointwise_nonbot_sideCondition
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hrepr :
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x)) :
    ‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal) := by
  exact helperForText_19_0_9_representable_pointwise_ne_bot
    (n := n) (f := f) hrepr

/-- Helper for Text 19.0.9: membership in a transformed-image subset of Euclidean
space can be transported to function coordinates via `WithLp.toLp`. -/
lemma helperForText_19_0_9_mem_transformedImage_coordEuclid_transport
    {n : ‚Ñï} {S : Set (EuclideanSpace ‚Ñù (Fin (n + 1)))} {z : Fin (n + 1) ‚Üí ‚Ñù} :
    (WithLp.toLp 2 z ‚àà S) ‚Üî z ‚àà (WithLp.toLp 2) ‚Åª¬π' S := by
  rfl

/-- Helper for Text 19.0.9: unpacking `prodLinearEquiv_append_coord` equals unpacking
`prodLinearEquiv_append` after the coordinate-to-Euclidean coercion. -/
lemma helperForText_19_0_9_prodLinearEquivAppendCoord_symm_eq
    {n : ‚Ñï} (z : Fin (n + 1) ‚Üí ‚Ñù) :
    (prodLinearEquiv_append_coord (n := n)).symm z =
      (prodLinearEquiv_append (n := n)).symm (WithLp.toLp 2 z) := by
  rfl

/-- Helper for Text 19.0.9: the packed-coordinate embedding recovers each base
coordinate at `Fin.castSucc`. -/
lemma helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
    {n : ‚Ñï} (x0 : Fin n ‚Üí ‚Ñù) (Œº0 : ‚Ñù) (j0 : Fin n) :
    x0 j0 = (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (Fin.castSucc j0) := by
  change x0 j0 = (prodLinearEquiv_append (n := n) (x0, Œº0)).ofLp (Fin.castSucc j0)
  change x0 j0 =
    ((appendAffineEquiv n 1).linear
      (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0))).ofLp (Fin.castSucc j0)
  have happ := congrArg
    (fun v => ((EuclideanSpace.equiv (ùïú := Real) (Œπ := Fin (n + 1))) v) (Fin.castSucc j0))
    (appendAffineEquiv_apply n 1 (WithLp.toLp 2 x0) (WithLp.toLp 2 (Function.const (Fin 1) Œº0)))
  have hlin :
      (appendAffineEquiv n 1) (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0)) =
        (appendAffineEquiv n 1).linear
          (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0)) := by
    simpa using congrArg
      (fun f => f (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0)))
      (appendAffineEquiv_eq_linear_toAffineEquiv n 1)
  have happ' :
      ((appendAffineEquiv n 1).linear
        (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0))).ofLp (Fin.castSucc j0) =
        Fin.append x0 (Function.const (Fin 1) Œº0) (Fin.castSucc j0) := by
    simpa [hlin] using happ
  have happend : Fin.append x0 (Function.const (Fin 1) Œº0) (Fin.castSucc j0) = x0 j0 := by
    exact Fin.append_left (u := x0) (v := Function.const (Fin 1) Œº0) j0
  exact (happ'.trans happend).symm

/-- Helper for Text 19.0.9: the last packed coordinate equals the appended scalar. -/
lemma helperForText_19_0_9_prodLinearEquivAppendCoord_last
    {n : ‚Ñï} (x0 : Fin n ‚Üí ‚Ñù) (Œº0 : ‚Ñù) :
    Œº0 = (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (Fin.last n) := by
  change Œº0 = (prodLinearEquiv_append (n := n) (x0, Œº0)).ofLp (Fin.last n)
  change Œº0 =
    ((appendAffineEquiv n 1).linear
      (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0))).ofLp (Fin.last n)
  have happ := congrArg
    (fun v => ((EuclideanSpace.equiv (ùïú := Real) (Œπ := Fin (n + 1))) v) (Fin.last n))
    (appendAffineEquiv_apply n 1 (WithLp.toLp 2 x0) (WithLp.toLp 2 (Function.const (Fin 1) Œº0)))
  have hlin :
      (appendAffineEquiv n 1) (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0)) =
        (appendAffineEquiv n 1).linear
          (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0)) := by
    simpa using congrArg
      (fun f => f (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0)))
      (appendAffineEquiv_eq_linear_toAffineEquiv n 1)
  have happ' :
      ((appendAffineEquiv n 1).linear
        (WithLp.toLp 2 x0, WithLp.toLp 2 (Function.const (Fin 1) Œº0))).ofLp (Fin.last n) =
        Fin.append x0 (Function.const (Fin 1) Œº0) (Fin.last n) := by
    simpa [hlin] using happ
  have happend : Fin.append x0 (Function.const (Fin 1) Œº0) (Fin.last n) = Œº0 := by
    have hlast : Fin.natAdd n (0 : Fin 1) = Fin.last n := by
      simpa [Nat.add_zero] using (Fin.natAdd_last (n := n) (m := 0))
    rw [‚Üê hlast]
    simp [Fin.append]
  exact (happ'.trans happend).symm

/-- Helper for Text 19.0.9: dot product in packed coordinates splits as base
dot product plus product of the appended scalar coordinates. -/
lemma helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
    {n : ‚Ñï} (p q : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù) :
    dotProduct
      (prodLinearEquiv_append_coord (n := n) p)
      (prodLinearEquiv_append_coord (n := n) q) =
      dotProduct p.1 q.1 + p.2 * q.2 := by
  rcases p with ‚ü®x, Œº‚ü©
  rcases q with ‚ü®y, ŒΩ‚ü©
  have hx_cast :
      ‚àÄ j : Fin n,
        (prodLinearEquiv_append_coord (n := n) (x, Œº)) (Fin.castSucc j) = x j := by
    intro j
    exact
      (helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
        (n := n) (x0 := x) (Œº0 := Œº) (j0 := j)).symm
  have hy_cast :
      ‚àÄ j : Fin n,
        (prodLinearEquiv_append_coord (n := n) (y, ŒΩ)) (Fin.castSucc j) = y j := by
    intro j
    exact
      (helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
        (n := n) (x0 := y) (Œº0 := ŒΩ) (j0 := j)).symm
  have hx_last :
      (prodLinearEquiv_append_coord (n := n) (x, Œº)) (Fin.last n) = Œº := by
    exact
      (helperForText_19_0_9_prodLinearEquivAppendCoord_last
        (n := n) (x0 := x) (Œº0 := Œº)).symm
  have hy_last :
      (prodLinearEquiv_append_coord (n := n) (y, ŒΩ)) (Fin.last n) = ŒΩ := by
    exact
      (helperForText_19_0_9_prodLinearEquivAppendCoord_last
        (n := n) (x0 := y) (Œº0 := ŒΩ)).symm
  calc
    dotProduct
      (prodLinearEquiv_append_coord (n := n) (x, Œº))
      (prodLinearEquiv_append_coord (n := n) (y, ŒΩ))
        =
          (‚àë j : Fin n,
            (prodLinearEquiv_append_coord (n := n) (x, Œº)) (Fin.castSucc j) *
              (prodLinearEquiv_append_coord (n := n) (y, ŒΩ)) (Fin.castSucc j)) +
            (prodLinearEquiv_append_coord (n := n) (x, Œº)) (Fin.last n) *
              (prodLinearEquiv_append_coord (n := n) (y, ŒΩ)) (Fin.last n) := by
          simp [dotProduct, Fin.sum_univ_castSucc]
    _ = (‚àë j : Fin n, x j * y j) + Œº * ŒΩ := by
          simp [hx_cast, hy_cast, hx_last, hy_last]
    _ = dotProduct x y + Œº * ŒΩ := by
          simp [dotProduct]

/-- Helper for Text 19.0.9: dot products against packed normals `(b_i, -1)` decode to
the affine expression `dotProduct (b_i) x - Œº` at pulled-back coordinates. -/
lemma helperForText_19_0_9_dotPacked_point
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m)
    (y : Fin (n + 1) ‚Üí ‚Ñù) :
    dotProduct y (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) =
      dotProduct (b i) ((prodLinearEquiv_append_coord (n := n)).symm y).1 -
        ((prodLinearEquiv_append_coord (n := n)).symm y).2 := by
  let q : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù := (prodLinearEquiv_append_coord (n := n)).symm y
  have hy : prodLinearEquiv_append_coord (n := n) q = y := by
    simp [q]
  calc
    dotProduct y (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù)))
        = dotProduct (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) y := by
            simp [dotProduct_comm]
    _ = dotProduct
          (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù)))
          (prodLinearEquiv_append_coord (n := n) q) := by
            simp [hy]
    _ = dotProduct (b i) q.1 + (-1 : ‚Ñù) * q.2 := by
          simpa using
            helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
              (n := n) (p := (b i, (-1 : ‚Ñù))) (q := q)
    _ = dotProduct (b i) q.1 - q.2 := by
          ring
    _ = dotProduct (b i) ((prodLinearEquiv_append_coord (n := n)).symm y).1 -
          ((prodLinearEquiv_append_coord (n := n)).symm y).2 := by
            simp [q]

/-- Helper for Text 19.0.9: dot products against packed normals `(b_i, 0)` decode to
`dotProduct (b_i) x` at pulled-back coordinates. -/
lemma helperForText_19_0_9_dotPacked_direction
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m)
    (y : Fin (n + 1) ‚Üí ‚Ñù) :
    dotProduct y (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) =
      dotProduct (b i) ((prodLinearEquiv_append_coord (n := n)).symm y).1 := by
  let q : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù := (prodLinearEquiv_append_coord (n := n)).symm y
  have hy : prodLinearEquiv_append_coord (n := n) q = y := by
    simp [q]
  calc
    dotProduct y (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù)))
        = dotProduct (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) y := by
            simp [dotProduct_comm]
    _ = dotProduct
          (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù)))
          (prodLinearEquiv_append_coord (n := n) q) := by
            simp [hy]
    _ = dotProduct (b i) q.1 + (0 : ‚Ñù) * q.2 := by
          simpa using
            helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
              (n := n) (p := (b i, (0 : ‚Ñù))) (q := q)
    _ = dotProduct (b i) q.1 := by
          ring
    _ = dotProduct (b i) ((prodLinearEquiv_append_coord (n := n)).symm y).1 := by
          simp [q]

/-- Helper for Text 19.0.9: the transformed-epigraph image is upward closed in the
last coordinate at fixed base point. -/
lemma helperForText_19_0_9_transformedEpigraphImage_upwardClosed_lastCoord
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {x : Fin n ‚Üí ‚Ñù} {Œº t : ‚Ñù}
    (hy :
      prodLinearEquiv_append (n := n) (x, Œº) ‚àà
        ((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f))
    (ht : 0 ‚â§ t) :
    prodLinearEquiv_append (n := n) (x, Œº + t) ‚àà
      ((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
  rcases hy with ‚ü®p, hpEpi, hpMap‚ü©
  have hpEq : p = (x, Œº) :=
    (prodLinearEquiv_append (n := n)).injective hpMap
  rcases p with ‚ü®x0, Œº0‚ü©
  cases hpEq
  have hleŒº : f x ‚â§ ((Œº : ‚Ñù) : EReal) :=
    (mem_epigraph_univ_iff (f := f)).1 hpEpi
  have hŒº_le_Œºt : ((Œº : ‚Ñù) : EReal) ‚â§ (((Œº + t : ‚Ñù) : ‚Ñù) : EReal) := by
    exact_mod_cast (show Œº ‚â§ Œº + t from by linarith [ht])
  have hleŒºt : f x ‚â§ (((Œº + t : ‚Ñù) : ‚Ñù) : EReal) :=
    le_trans hleŒº hŒº_le_Œºt
  have hEpi' : (x, Œº + t) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f :=
    (mem_epigraph_univ_iff (f := f)).2 hleŒºt
  exact ‚ü®(x, Œº + t), hEpi', rfl‚ü©

/-- Helper for Text 19.0.9: nonemptiness of the transformed-epigraph image yields a
base point and scalar with finite-epigraph inequality data. -/
lemma helperForText_19_0_9_nonempty_transformedEpigraphImage_unpack
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hNonempty :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty) :
    ‚àÉ x : Fin n ‚Üí ‚Ñù, ‚àÉ Œº : ‚Ñù, f x ‚â§ (Œº : EReal) := by
  rcases hNonempty with ‚ü®y, hy‚ü©
  rcases hy with ‚ü®p, hpEpi, hpMap‚ü©
  rcases p with ‚ü®x, Œº‚ü©
  refine ‚ü®x, Œº, ?_‚ü©
  exact (mem_epigraph_univ_iff (f := f)).1 hpEpi

/-- Helper for Text 19.0.9: transformed-epigraph image membership at a packed point
is equivalent to ordinary epigraph membership at the unpacked point. -/
lemma helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù} :
    (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
      ((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) ‚Üî
      (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
  constructor
  ¬∑ intro hmem
    rcases hmem with ‚ü®p, hpEpi, hpImage‚ü©
    have hp : p = (x, Œº) :=
      (prodLinearEquiv_append (n := n)).injective hpImage
    simpa [hp] using hpEpi
  ¬∑ intro hmem
    exact ‚ü®(x, Œº), hmem, rfl‚ü©

/-- Helper for Text 19.0.9: polyhedrality of the transformed epigraph image yields a
finite raw halfspace presentation. -/
lemma helperForText_19_0_9_nonempty_polyhedral_transformedImage_extract_rawHalfspaces
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hpoly : IsPolyhedralConvexFunction n f) :
    ‚àÉ (m : ‚Ñï) (a : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù) (Œ± : Fin m ‚Üí ‚Ñù),
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i) := by
  exact
    (isPolyhedralConvexSet_iff_exists_finite_halfspaces
      (n := n + 1)
      (C :=
        (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)))).1
      hpoly.2

/-- Helper for Text 19.0.9: in the `k = 0` branch, feasibility of the domain-inequality
family yields a witness that the split-halfspace set is nonempty. -/
lemma helperForText_19_0_9_kZero_splitHalfspaces_allow_negativeLastCoord
    {n m : ‚Ñï} (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù)
    (hfeas : ‚àÉ x0 : Fin n ‚Üí ‚Ñù, ‚àÄ i : Fin m, (‚àë j, x0 j * b i j) ‚â§ Œ≤ i) :
    let g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal :=
      fun x =>
        ((sSup {r : ‚Ñù |
            ‚àÉ i : Fin m, (i : ‚Ñï) < 0 ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
          indicatorFunction
            (C := {y | ‚àÄ i : Fin m, 0 ‚â§ (i : ‚Ñï) ‚Üí
              (‚àë j, y j * b i j) ‚â§ Œ≤ i})
            x
    let _Simg : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
      ((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g)
    let Ssplit : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
      ({z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, (i : ‚Ñï) < 0 ‚Üí
            dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, 0 ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i})
    ‚àÉ y0 : Fin (n + 1) ‚Üí ‚Ñù, y0 ‚àà Ssplit := by
  rcases hfeas with ‚ü®x0, hx0feas‚ü©
  let Ssplit : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
    ({z : Fin (n + 1) ‚Üí ‚Ñù |
        ‚àÄ i : Fin m, (i : ‚Ñï) < 0 ‚Üí
          dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
      {z : Fin (n + 1) ‚Üí ‚Ñù |
        ‚àÄ i : Fin m, 0 ‚â§ (i : ‚Ñï) ‚Üí
          dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i})
  change ‚àÉ y0 : Fin (n + 1) ‚Üí ‚Ñù, y0 ‚àà Ssplit
  let y0 : Fin (n + 1) ‚Üí ‚Ñù := Fin.cases (0 : ‚Ñù) x0
  refine ‚ü®y0, ?_‚ü©
  refine And.intro ?_ ?_
  ¬∑ intro i hi
    exact (Nat.not_lt_zero (i : ‚Ñï) hi).elim
  ¬∑ intro i hi
    have hdot : dotProduct y0 (Fin.cases (0 : ‚Ñù) (b i)) = dotProduct x0 (b i) := by
      simp [dotProduct, y0, Fin.sum_univ_succ]
    have hfeasDot : dotProduct x0 (b i) ‚â§ Œ≤ i := by
      simpa [dotProduct] using hx0feas i
    simpa [hdot] using hfeasDot

/-- Helper for Text 19.0.9: equality of transformed-epigraph images determines the
underlying `EReal`-valued function uniquely. -/
lemma helperForText_19_0_9_transformedImage_eq_implies_function_eq
    {n : ‚Ñï} {f g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hImageEq :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) =
        (((fun p => prodLinearEquiv_append (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g))) :
    f = g := by
  funext x
  have hUpperCutsEq :
      ‚àÄ Œº : ‚Ñù, f x ‚â§ (Œº : EReal) ‚Üî g x ‚â§ (Œº : EReal) := by
    intro Œº
    constructor
    ¬∑ intro hfx
      have hmemF :
          (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) := by
        exact
          (helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := f) (x := x) (Œº := Œº)).2
            ((mem_epigraph_univ_iff (f := f)).2 hfx)
      have hmemG :
          (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g)) := by
        simpa [hImageEq] using hmemF
      exact
        (mem_epigraph_univ_iff (f := g)).1
          ((helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := g) (x := x) (Œº := Œº)).1 hmemG)
    ¬∑ intro hgx
      have hmemG :
          (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g)) := by
        exact
          (helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := g) (x := x) (Œº := Œº)).2
            ((mem_epigraph_univ_iff (f := g)).2 hgx)
      have hmemF :
          (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) := by
        simpa [hImageEq] using hmemG
      exact
        (mem_epigraph_univ_iff (f := f)).1
          ((helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := f) (x := x) (Œº := Œº)).1 hmemF)
  apply le_antisymm
  ¬∑ exact
      (EReal.le_of_forall_lt_iff_le).1
        (by
          intro Œº hŒº
          exact (hUpperCutsEq Œº).2 (le_of_lt hŒº))
  ¬∑ exact
      (EReal.le_of_forall_lt_iff_le).1
        (by
          intro Œº hŒº
          exact (hUpperCutsEq Œº).1 (le_of_lt hŒº))

/-- Helper for Text 19.0.9: equality of packed-coordinate transformed-epigraph
images determines the underlying `EReal`-valued function uniquely. -/
lemma helperForText_19_0_9_transformedImageCoord_eq_implies_function_eq
    {n : ‚Ñï} {f g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hImageEq :
      (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù))) :
    f = g := by
  funext x
  have hUpperCutsEq :
      ‚àÄ Œº : ‚Ñù, f x ‚â§ (Œº : EReal) ‚Üî g x ‚â§ (Œº : EReal) := by
    intro Œº
    constructor
    ¬∑ intro hfx
      have hmemF :
          (prodLinearEquiv_append_coord (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
        simpa [prodLinearEquiv_append_coord] using
          (helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := f) (x := x) (Œº := Œº)).2
            ((mem_epigraph_univ_iff (f := f)).2 hfx)
      have hmemG :
          (prodLinearEquiv_append_coord (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
        simpa [hImageEq] using hmemF
      have hmemGEuclid :
          (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g)) := by
        simpa [prodLinearEquiv_append_coord] using hmemG
      exact
        (mem_epigraph_univ_iff (f := g)).1
          ((helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := g) (x := x) (Œº := Œº)).1 hmemGEuclid)
    ¬∑ intro hgx
      have hmemG :
          (prodLinearEquiv_append_coord (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
        simpa [prodLinearEquiv_append_coord] using
          (helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := g) (x := x) (Œº := Œº)).2
            ((mem_epigraph_univ_iff (f := g)).2 hgx)
      have hmemF :
          (prodLinearEquiv_append_coord (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
        simpa [hImageEq] using hmemG
      have hmemFEuclid :
          (prodLinearEquiv_append (n := n) (x, Œº)) ‚àà
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) := by
        simpa [prodLinearEquiv_append_coord] using hmemF
      exact
        (mem_epigraph_univ_iff (f := f)).1
          ((helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
            (n := n) (f := f) (x := x) (Œº := Œº)).1 hmemFEuclid)
  apply le_antisymm
  ¬∑ exact
      (EReal.le_of_forall_lt_iff_le).1
        (by
          intro Œº hŒº
          exact (hUpperCutsEq Œº).2 (le_of_lt hŒº))
  ¬∑ exact
      (EReal.le_of_forall_lt_iff_le).1
        (by
          intro Œº hŒº
          exact (hUpperCutsEq Œº).1 (le_of_lt hŒº))

/-- Helper for Text 19.0.9: the lower-bound guard on the unpacked scalar coordinate
is a polyhedral halfspace in packed coordinates. -/
lemma helperForText_19_0_9_lastCoordGuard_polyhedral
    {n : ‚Ñï} :
    IsPolyhedralConvexSet (n + 1)
      {z : Fin (n + 1) ‚Üí ‚Ñù |
        0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2} := by
  classical
  let b : Fin 1 ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
    fun _ =>
      prodLinearEquiv_append_coord (n := n)
        ((fun _ : Fin n => (0 : ‚Ñù)), (-1 : ‚Ñù))
  let Œ≤ : Fin 1 ‚Üí ‚Ñù := fun _ => 0
  refine ‚ü®Fin 1, inferInstance, b, Œ≤, ?_‚ü©
  ext z
  constructor
  ¬∑ intro hz
    refine Set.mem_iInter.2 ?_
    intro i
    have hdot :
        dotProduct z (b i) =
          -((prodLinearEquiv_append_coord (n := n)).symm z).2 := by
      have hdotRaw :=
        helperForText_19_0_9_dotPacked_point
          (n := n) (m := 1)
          (b := fun _ : Fin 1 => (fun _ : Fin n => (0 : ‚Ñù)))
          i z
      simpa [b, dotProduct] using hdotRaw
    have hle : dotProduct z (b i) ‚â§ Œ≤ i := by
      have hneg : -((prodLinearEquiv_append_coord (n := n)).symm z).2 ‚â§ 0 :=
        neg_nonpos.mpr hz
      simpa [Œ≤, hdot] using hneg
    simpa [closedHalfSpaceLE, b, Œ≤] using hle
  ¬∑ intro hz
    have hz0 : z ‚àà closedHalfSpaceLE (n + 1) (b 0) (Œ≤ 0) :=
      Set.mem_iInter.1 hz 0
    have hdot :
        dotProduct z (b 0) =
          -((prodLinearEquiv_append_coord (n := n)).symm z).2 := by
      have hdotRaw :=
        helperForText_19_0_9_dotPacked_point
          (n := n) (m := 1)
          (b := fun _ : Fin 1 => (fun _ : Fin n => (0 : ‚Ñù)))
          0 z
      simpa [b, dotProduct] using hdotRaw
    have hle : -((prodLinearEquiv_append_coord (n := n)).symm z).2 ‚â§ 0 := by
      simpa [closedHalfSpaceLE, b, Œ≤, hdot] using hz0
    exact neg_nonpos.mp hle

/-- Helper for Text 19.0.9: the guarded packed-normal constraint form is polyhedral. -/
lemma helperForText_19_0_9_guardedSplitConstraintSet_polyhedral
    {n k m : ‚Ñï} (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù) :
    IsPolyhedralConvexSet (n + 1)
      (({z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
        (if k = 0 then
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
        else Set.univ)) := by
  have hactive :
      IsPolyhedralConvexSet (n + 1)
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} := by
    classical
    let Œπ : Type := {i : Fin m // (i : ‚Ñï) < k}
    let a : Œπ ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
      fun i => prodLinearEquiv_append_coord (n := n) (b i.1, (-1 : ‚Ñù))
    let Œ± : Œπ ‚Üí ‚Ñù := fun i => Œ≤ i.1
    refine ‚ü®Œπ, inferInstance, a, Œ±, ?_‚ü©
    ext z
    constructor
    ¬∑ intro hz
      refine Set.mem_iInter.2 ?_
      intro i
      have hz_i : dotProduct z
          (prodLinearEquiv_append_coord (n := n) (b i.1, (-1 : ‚Ñù))) ‚â§ Œ≤ i.1 :=
        hz i.1 i.2
      simpa [closedHalfSpaceLE, a, Œ±] using hz_i
    ¬∑ intro hz i hi
      have hz_i : z ‚àà closedHalfSpaceLE (n + 1) (a ‚ü®i, hi‚ü©) (Œ± ‚ü®i, hi‚ü©) :=
        Set.mem_iInter.1 hz ‚ü®i, hi‚ü©
      simpa [closedHalfSpaceLE, a, Œ±] using hz_i
  have hdomain :
      IsPolyhedralConvexSet (n + 1)
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i} := by
    classical
    let Œπ : Type := {i : Fin m // k ‚â§ (i : ‚Ñï)}
    let a : Œπ ‚Üí Fin (n + 1) ‚Üí ‚Ñù :=
      fun i => prodLinearEquiv_append_coord (n := n) (b i.1, (0 : ‚Ñù))
    let Œ± : Œπ ‚Üí ‚Ñù := fun i => Œ≤ i.1
    refine ‚ü®Œπ, inferInstance, a, Œ±, ?_‚ü©
    ext z
    constructor
    ¬∑ intro hz
      refine Set.mem_iInter.2 ?_
      intro i
      have hz_i : dotProduct z
          (prodLinearEquiv_append_coord (n := n) (b i.1, (0 : ‚Ñù))) ‚â§ Œ≤ i.1 :=
        hz i.1 i.2
      simpa [closedHalfSpaceLE, a, Œ±] using hz_i
    ¬∑ intro hz i hi
      have hz_i : z ‚àà closedHalfSpaceLE (n + 1) (a ‚ü®i, hi‚ü©) (Œ± ‚ü®i, hi‚ü©) :=
        Set.mem_iInter.1 hz ‚ü®i, hi‚ü©
      simpa [closedHalfSpaceLE, a, Œ±] using hz_i
  have hsplit :
      IsPolyhedralConvexSet (n + 1)
        ({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) :=
    helperForTheorem_19_1_polyhedral_inter hactive hdomain
  by_cases hk0 : k = 0
  ¬∑ have hguard :
      IsPolyhedralConvexSet (n + 1)
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2} :=
      helperForText_19_0_9_lastCoordGuard_polyhedral (n := n)
    have hinter :
        IsPolyhedralConvexSet (n + 1)
          (({z : Fin (n + 1) ‚Üí ‚Ñù |
              ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
                dotProduct z
                  (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                dotProduct z
                  (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}) :=
      helperForTheorem_19_1_polyhedral_inter hsplit hguard
    simpa [hk0] using hinter
  ¬∑ simpa [hk0, Set.inter_univ] using hsplit

/-- Helper for Text 19.0.9: packed normals with last coordinate `-1` decode to
the split affine expression after unpacking coordinates. -/
lemma helperForText_19_0_9_dotPacked_point_finCases_normalForm
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m)
    (y : Fin (n + 1) ‚Üí ‚Ñù) :
    dotProduct y (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) =
      dotProduct (b i) ((prodLinearEquiv_append_coord (n := n)).symm y).1 -
        ((prodLinearEquiv_append_coord (n := n)).symm y).2 := by
  simpa using helperForText_19_0_9_dotPacked_point (n := n) (m := m) (b := b) i y

/-- Helper for Text 19.0.9: packed-direction normals with last coordinate `0` decode
to the base-coordinate dot product after unpacking. -/
lemma helperForText_19_0_9_dotPacked_direction_finCases_normalForm
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m)
    (y : Fin (n + 1) ‚Üí ‚Ñù) :
    dotProduct y (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) =
      dotProduct (b i) ((prodLinearEquiv_append_coord (n := n)).symm y).1 := by
  simpa using helperForText_19_0_9_dotPacked_direction (n := n) (m := m) (b := b) i y

/-- Helper for Text 19.0.9: evaluating the packed normal `(b_i, -1)` at base
coordinates recovers the coefficient function `b_i`. -/
lemma helperForText_19_0_9_packedNormal_point_eq_finCases
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m) (j : Fin n) :
    (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) (Fin.castSucc j) = b i j := by
  exact
    (helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
      (n := n) (x0 := b i) (Œº0 := (-1 : ‚Ñù)) (j0 := j)).symm

/-- Helper for Text 19.0.9: evaluating the packed normal `(b_i, 0)` at base
coordinates recovers the coefficient function `b_i`. -/
lemma helperForText_19_0_9_packedNormal_direction_eq_finCases
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m) (j : Fin n) :
    (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) (Fin.castSucc j) = b i j := by
  exact
    (helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
      (n := n) (x0 := b i) (Œº0 := (0 : ‚Ñù)) (j0 := j)).symm

/-- Helper for Text 19.0.9: an epigraph upper bound on the represented value at `x`
forces `x` to satisfy all domain-side inequalities. -/
lemma helperForText_19_0_9_representation_le_implies_domain_membership
    {n k m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ≤ : Fin m ‚Üí ‚Ñù}
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hgŒº :
      ((sSup {r : ‚Ñù |
          ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
        indicatorFunction
          (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            (‚àë j, y j * b i j) ‚â§ Œ≤ i})
          x ‚â§ (Œº : EReal)) :
    x ‚àà ({y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí (‚àë j, y j * b i j) ‚â§ Œ≤ i} : Set (Fin n ‚Üí ‚Ñù)) := by
  by_contra hxC
  have htop : (‚ä§ : EReal) ‚â§ (Œº : EReal) := by
    simp [indicatorFunction, hxC] at hgŒº
  exact (not_top_le_coe Œº) htop

/-- Helper for Text 19.0.9: the same represented upper bound yields an upper bound on
the corresponding affine supremum term. -/
lemma helperForText_19_0_9_representation_le_implies_sup_bound
    {n k m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ≤ : Fin m ‚Üí ‚Ñù}
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hgŒº :
      ((sSup {r : ‚Ñù |
          ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
        indicatorFunction
          (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            (‚àë j, y j * b i j) ‚â§ Œ≤ i})
          x ‚â§ (Œº : EReal)) :
    sSup {r : ‚Ñù | ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} ‚â§ Œº := by
  have hxC :
      x ‚àà ({y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí (‚àë j, y j * b i j) ‚â§ Œ≤ i} : Set (Fin n ‚Üí ‚Ñù)) :=
    helperForText_19_0_9_representation_le_implies_domain_membership
      (n := n) (k := k) (m := m) (b := b) (Œ≤ := Œ≤) (x := x) (Œº := Œº) hgŒº
  have hsSup_leE :
      ((sSup {r : ‚Ñù | ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) ‚â§
        (Œº : EReal) := by
    simpa [indicatorFunction, hxC] using hgŒº
  exact_mod_cast hsSup_leE

/-- Helper for Text 19.0.9: each active affine piece (`i < k`) is bounded above by
`Œº` whenever the represented value at `x` is bounded by `Œº`. -/
lemma helperForText_19_0_9_representation_le_implies_active_affine_bound
    {n k m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ≤ : Fin m ‚Üí ‚Ñù}
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hgŒº :
      ((sSup {r : ‚Ñù |
          ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
        indicatorFunction
          (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            (‚àë j, y j * b i j) ‚â§ Œ≤ i})
          x ‚â§ (Œº : EReal))
    (i : Fin m) (hi : (i : ‚Ñï) < k) :
    (‚àë j, x j * b i j) - Œ≤ i ‚â§ Œº := by
  let A : Set ‚Ñù :=
    {r : ‚Ñù | ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i}
  have hsSup_le : sSup A ‚â§ Œº := by
    simpa [A] using
      helperForText_19_0_9_representation_le_implies_sup_bound
        (n := n) (k := k) (m := m) (b := b) (Œ≤ := Œ≤) (x := x) (Œº := Œº) hgŒº
  have hA_sub : A ‚äÜ Set.range (fun i : Fin m => (‚àë j, x j * b i j) - Œ≤ i) := by
    intro r hr
    rcases hr with ‚ü®i', _hi', rfl‚ü©
    exact ‚ü®i', rfl‚ü©
  have hA_finite : Set.Finite A :=
    (Set.finite_range (fun i : Fin m => (‚àë j, x j * b i j) - Œ≤ i)).subset hA_sub
  have hA_bdd : BddAbove A := hA_finite.bddAbove
  have hi_memA : (‚àë j, x j * b i j) - Œ≤ i ‚àà A := by
    exact ‚ü®i, hi, rfl‚ü©
  exact le_trans (le_csSup hA_bdd hi_memA) hsSup_le

/-- Helper for Text 19.0.9: dot products against the `Fin.cases` split normals
expand into the zero-coordinate term plus the `succ`-indexed base sum. -/
lemma helperForText_19_0_9_dotFinCasesNormals_unpacked_normalForm
    {n m : ‚Ñï} {b : Fin m ‚Üí Fin n ‚Üí ‚Ñù} (i : Fin m)
    (z : Fin (n + 1) ‚Üí ‚Ñù) :
    dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) =
      z 0 * (-1 : ‚Ñù) + ‚àë j : Fin n, z j.succ * b i j ‚àß
    dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) =
      ‚àë j : Fin n, z j.succ * b i j := by
  constructor
  ¬∑
    calc
      dotProduct z (Fin.cases (-1 : ‚Ñù) (b i))
          = ‚àë t : Fin (n + 1), z t * Fin.cases (-1 : ‚Ñù) (b i) t := by
              simp [dotProduct]
      _ = z 0 * (-1 : ‚Ñù) + ‚àë j : Fin n, z j.succ * Fin.cases (-1 : ‚Ñù) (b i) j.succ := by
            simp [Fin.sum_univ_succ]
      _ = z 0 * (-1 : ‚Ñù) + ‚àë j : Fin n, z j.succ * b i j := by
            simp [Fin.cases_succ]
  ¬∑
    calc
      dotProduct z (Fin.cases (0 : ‚Ñù) (b i))
          = ‚àë t : Fin (n + 1), z t * Fin.cases (0 : ‚Ñù) (b i) t := by
              simp [dotProduct]
      _ = z 0 * (0 : ‚Ñù) + ‚àë j : Fin n, z j.succ * Fin.cases (0 : ‚Ñù) (b i) j.succ := by
            simp [Fin.sum_univ_succ]
      _ = ‚àë j : Fin n, z j.succ * b i j := by
            simp [Fin.cases_succ]

/-- Helper for Text 19.0.9: for `n = 1`, `k = m = 1`, and zero coefficients,
the packed point corresponding to `(x, Œº) = (-1, 0)` belongs to the transformed
epigraph image of the represented function. -/
lemma helperForText_19_0_9_counterexample_mem_transformedImage
    :
    let g : (Fin 1 ‚Üí ‚Ñù) ‚Üí EReal :=
      fun x =>
        ((sSup {r : ‚Ñù |
            ‚àÉ i : Fin 1, (i : ‚Ñï) < 1 ‚àß r = (‚àë j, x j * (0 : ‚Ñù)) - (0 : ‚Ñù)} : ‚Ñù) : EReal) +
          indicatorFunction
            (C := {y : Fin 1 ‚Üí ‚Ñù | ‚àÄ i : Fin 1, 1 ‚â§ (i : ‚Ñï) ‚Üí
              (‚àë j, y j * (0 : ‚Ñù)) ‚â§ (0 : ‚Ñù)})
            x
    let z0 : Fin 2 ‚Üí ‚Ñù :=
      prodLinearEquiv_append (n := 1) ((fun _ : Fin 1 => (-1 : ‚Ñù)), (0 : ‚Ñù))
    z0 ‚àà (((fun p => prodLinearEquiv_append (n := 1) p) ''
      epigraph (Set.univ : Set (Fin 1 ‚Üí ‚Ñù)) g) : Set (Fin 2 ‚Üí ‚Ñù)) := by
  intro g z0
  have hmemEpi :
      ((fun _ : Fin 1 => (-1 : ‚Ñù)), (0 : ‚Ñù)) ‚àà
        epigraph (Set.univ : Set (Fin 1 ‚Üí ‚Ñù)) g := by
    exact (mem_epigraph_univ_iff (f := g)).2 (by simp [g, indicatorFunction])
  refine ‚ü®((fun _ : Fin 1 => (-1 : ‚Ñù)), (0 : ‚Ñù)), ?_, rfl‚ü©
  exact hmemEpi

/-- Helper for Text 19.0.9: under the same concrete data, the point above violates
the split `Fin.cases` affine-constraint family. -/
lemma helperForText_19_0_9_counterexample_not_mem_finCases_split
    :
    let z0 : Fin 2 ‚Üí ‚Ñù :=
      prodLinearEquiv_append (n := 1) ((fun _ : Fin 1 => (-1 : ‚Ñù)), (0 : ‚Ñù))
    z0 ‚àâ
      ({z : Fin 2 ‚Üí ‚Ñù |
          ‚àÄ i : Fin 1, (i : ‚Ñï) < 1 ‚Üí
            dotProduct z (Fin.cases (-1 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù))) ‚â§ (0 : ‚Ñù)} ‚à©
        {z : Fin 2 ‚Üí ‚Ñù |
          ‚àÄ i : Fin 1, 1 ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z (Fin.cases (0 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù))) ‚â§ (0 : ‚Ñù)}) := by
  intro z0 hz
  have hlt : (((0 : Fin 1) : Fin 1) : ‚Ñï) < 1 := by simp
  have hineq :
      dotProduct z0 (Fin.cases (-1 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù))) ‚â§ (0 : ‚Ñù) :=
    hz.1 0 hlt
  have hdot :
      dotProduct z0 (Fin.cases (-1 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù))) = (1 : ‚Ñù) := by
    have h0 : z0 0 = (-1 : ‚Ñù) := by
      simpa [z0, prodLinearEquiv_append_coord] using
        (helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
          (n := 1) (x0 := fun _ : Fin 1 => (-1 : ‚Ñù)) (Œº0 := (0 : ‚Ñù)) (j0 := (0 : Fin 1))).symm
    calc
      dotProduct z0 (Fin.cases (-1 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù)))
          = z0 0 * (-1 : ‚Ñù) + ‚àë j : Fin 1, z0 j.succ * (0 : ‚Ñù) := by
              simpa using
                (helperForText_19_0_9_dotFinCasesNormals_unpacked_normalForm
                  (n := 1) (m := 1) (b := fun _ : Fin 1 => (fun _ : Fin 1 => (0 : ‚Ñù)))
                  (i := (0 : Fin 1)) z0).1
      _ = (1 : ‚Ñù) := by simp [h0]
  linarith [hineq, hdot]

/-- Helper for Text 19.0.9: the concrete one-dimensional witness separates the
transformed epigraph image from the split `Fin.cases` constraints. -/
lemma helperForText_19_0_9_counterexample_transformedImage_ne_finCases_split
    :
    let g : (Fin 1 ‚Üí ‚Ñù) ‚Üí EReal :=
      fun x =>
        ((sSup {r : ‚Ñù |
            ‚àÉ i : Fin 1, (i : ‚Ñï) < 1 ‚àß r = (‚àë j, x j * (0 : ‚Ñù)) - (0 : ‚Ñù)} : ‚Ñù) : EReal) +
          indicatorFunction
            (C := {y : Fin 1 ‚Üí ‚Ñù | ‚àÄ i : Fin 1, 1 ‚â§ (i : ‚Ñï) ‚Üí
              (‚àë j, y j * (0 : ‚Ñù)) ‚â§ (0 : ‚Ñù)})
            x
    let Simg : Set (Fin 2 ‚Üí ‚Ñù) :=
      ((fun p => prodLinearEquiv_append (n := 1) p) ''
        epigraph (Set.univ : Set (Fin 1 ‚Üí ‚Ñù)) g)
    let Ssplit : Set (Fin 2 ‚Üí ‚Ñù) :=
      ({z : Fin 2 ‚Üí ‚Ñù |
          ‚àÄ i : Fin 1, (i : ‚Ñï) < 1 ‚Üí
            dotProduct z (Fin.cases (-1 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù))) ‚â§ (0 : ‚Ñù)} ‚à©
        {z : Fin 2 ‚Üí ‚Ñù |
          ‚àÄ i : Fin 1, 1 ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z (Fin.cases (0 : ‚Ñù) (fun _ : Fin 1 => (0 : ‚Ñù))) ‚â§ (0 : ‚Ñù)})
    Simg ‚â† Ssplit := by
  intro g Simg Ssplit hEq
  let z0 : Fin 2 ‚Üí ‚Ñù :=
    prodLinearEquiv_append (n := 1) ((fun _ : Fin 1 => (-1 : ‚Ñù)), (0 : ‚Ñù))
  have hzSimg : z0 ‚àà Simg := by
    simpa [Simg, z0, g] using helperForText_19_0_9_counterexample_mem_transformedImage
  have hzSsplit : z0 ‚àà Ssplit := by
    simpa [hEq] using hzSimg
  have hzNotSsplit : z0 ‚àâ Ssplit := by
    simpa [Ssplit, z0] using helperForText_19_0_9_counterexample_not_mem_finCases_split
  exact hzNotSsplit hzSsplit

/-- Helper for Text 19.0.9: a max-affine-plus-indicator representation has transformed
epigraph image equal to packed-normal constraints with the `k = 0` last-coordinate guard. -/
lemma helperForText_19_0_9_representation_transformedImage_eq_constraints_with_lastCoord_guard
    {n k m : ‚Ñï} (hk : k ‚â§ m) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù) :
    let g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal :=
      fun x =>
        ((sSup {r : ‚Ñù |
            ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
          indicatorFunction
            (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              (‚àë j, y j * b i j) ‚â§ Œ≤ i})
            x
    let Simg : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
      ((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g)
    let Ssplit : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
      ({z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i})
    let Sguard : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
      {z : Fin (n + 1) ‚Üí ‚Ñù |
        0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
    Simg = Ssplit ‚à© (if k = 0 then Sguard else Set.univ) := by
  intro g Simg Ssplit Sguard
  ext z
  constructor
  ¬∑ intro hzImg
    let xŒº : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù := (prodLinearEquiv_append_coord (n := n)).symm z
    let x : Fin n ‚Üí ‚Ñù := xŒº.1
    let Œº : ‚Ñù := xŒº.2
    let C : Set (Fin n ‚Üí ‚Ñù) :=
      {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí (‚àë j, y j * b i j) ‚â§ Œ≤ i}
    have hzPackedCoord :
        prodLinearEquiv_append_coord (n := n) (x, Œº) = z := by
      change
        prodLinearEquiv_append_coord (n := n)
            ((prodLinearEquiv_append_coord (n := n)).symm z) = z
      simp
    have hzImgCoord :
        z ‚àà
          ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) := by
      simpa [Simg, prodLinearEquiv_append_coord] using hzImg
    have hzImgPackedCoord :
        prodLinearEquiv_append_coord (n := n) (x, Œº) ‚àà
          ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) := by
      simpa [hzPackedCoord] using hzImgCoord
    have hxŒºEpi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g := by
      rcases hzImgPackedCoord with ‚ü®p, hpEpi, hpMap‚ü©
      have hp : p = (x, Œº) :=
        (prodLinearEquiv_append_coord (n := n)).injective hpMap
      simpa [hp] using hpEpi
    have hgŒº : g x ‚â§ (Œº : EReal) :=
      (mem_epigraph_univ_iff (f := g)).1 hxŒºEpi
    have hxC : x ‚àà C := by
      exact
        helperForText_19_0_9_representation_le_implies_domain_membership
          (n := n) (k := k) (m := m) (b := b) (Œ≤ := Œ≤) (x := x) (Œº := Œº)
          (by simpa [g, C] using hgŒº)
    have hzActive :
        ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i := by
      intro i hi
      have hAffine :
          (‚àë j, x j * b i j) - Œ≤ i ‚â§ Œº := by
        exact
          helperForText_19_0_9_representation_le_implies_active_affine_bound
            (n := n) (k := k) (m := m) (b := b) (Œ≤ := Œ≤) (x := x) (Œº := Œº)
            (by simpa [g, C] using hgŒº) i hi
      have hdot :
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) =
            (‚àë j, x j * b i j) - Œº := by
        calc
          dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù)))
              = dotProduct (b i) x - Œº := by
                  simpa [x, Œº] using
                    (helperForText_19_0_9_dotPacked_point
                      (n := n) (m := m) (b := b) i z)
          _ = dotProduct x (b i) - Œº := by rw [dotProduct_comm]
          _ = (‚àë j, x j * b i j) - Œº := by simp [dotProduct]
      linarith [hAffine, hdot]
    have hzDomain :
        ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i := by
      intro i hi
      have hDomainIneq : (‚àë j, x j * b i j) ‚â§ Œ≤ i := hxC i hi
      have hdot :
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) =
            (‚àë j, x j * b i j) := by
        calc
          dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù)))
              = dotProduct (b i) x := by
                  simpa [x] using
                    (helperForText_19_0_9_dotPacked_direction
                      (n := n) (m := m) (b := b) i z)
          _ = dotProduct x (b i) := by rw [dotProduct_comm]
          _ = (‚àë j, x j * b i j) := by simp [dotProduct]
      simpa [hdot] using hDomainIneq
    have hzSplit : z ‚àà Ssplit := by
      exact ‚ü®hzActive, hzDomain‚ü©
    have hzGuard :
        z ‚àà (if k = 0 then Sguard else Set.univ) := by
      by_cases hk0 : k = 0
      ¬∑ have hsSupLe :
          sSup {r : ‚Ñù |
              ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                r = (‚àë j, x j * b i j) - Œ≤ i} ‚â§ Œº := by
          exact
            helperForText_19_0_9_representation_le_implies_sup_bound
              (n := n) (k := k) (m := m) (b := b) (Œ≤ := Œ≤) (x := x) (Œº := Œº)
              (by simpa [g, C] using hgŒº)
        have hŒº_nonneg : 0 ‚â§ Œº := by
          have hsSupZero :
              sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} = 0 := by
            simp [hk0]
          simpa [hsSupZero] using hsSupLe
        have hzSguard : z ‚àà Sguard := by
          simpa [Sguard, x, Œº, xŒº] using hŒº_nonneg
        simpa [hk0] using hzSguard
      ¬∑ simp [hk0]
    exact ‚ü®hzSplit, hzGuard‚ü©
  ¬∑ intro hz
    have hzSplit : z ‚àà Ssplit := hz.1
    have hzGuard : z ‚àà (if k = 0 then Sguard else Set.univ) := hz.2
    let xŒº : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù := (prodLinearEquiv_append_coord (n := n)).symm z
    let x : Fin n ‚Üí ‚Ñù := xŒº.1
    let Œº : ‚Ñù := xŒº.2
    let C : Set (Fin n ‚Üí ‚Ñù) :=
      {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí (‚àë j, y j * b i j) ‚â§ Œ≤ i}
    let A : Set ‚Ñù :=
      {r : ‚Ñù | ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i}
    have hzActive :
        ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i :=
      hzSplit.1
    have hzDomain :
        ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i :=
      hzSplit.2
    have hxC : x ‚àà C := by
      intro i hi
      have hPacked :
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i :=
        hzDomain i hi
      have hdot :
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) =
            (‚àë j, x j * b i j) := by
        calc
          dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù)))
              = dotProduct (b i) x := by
                  simpa [x] using
                    (helperForText_19_0_9_dotPacked_direction
                      (n := n) (m := m) (b := b) i z)
          _ = dotProduct x (b i) := by rw [dotProduct_comm]
          _ = (‚àë j, x j * b i j) := by simp [dotProduct]
      simpa [hdot] using hPacked
    have hŒº_nonneg_if_k0 : k = 0 ‚Üí 0 ‚â§ Œº := by
      intro hk0
      have hzSguard : z ‚àà Sguard := by
        simpa [hk0] using hzGuard
      simpa [Sguard, Œº, xŒº] using hzSguard
    have hA_upper : ‚àÄ r ‚àà A, r ‚â§ Œº := by
      intro r hr
      rcases hr with ‚ü®i, hi, rfl‚ü©
      have hPacked :
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i :=
        hzActive i hi
      have hdot :
          dotProduct z
            (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) =
            (‚àë j, x j * b i j) - Œº := by
        calc
          dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù)))
              = dotProduct (b i) x - Œº := by
                  simpa [x, Œº] using
                    (helperForText_19_0_9_dotPacked_point
                      (n := n) (m := m) (b := b) i z)
          _ = dotProduct x (b i) - Œº := by rw [dotProduct_comm]
          _ = (‚àë j, x j * b i j) - Œº := by simp [dotProduct]
      linarith [hPacked, hdot]
    have hsSup_le : sSup A ‚â§ Œº := by
      by_cases hk0 : k = 0
      ¬∑ have hŒº_nonneg : 0 ‚â§ Œº := hŒº_nonneg_if_k0 hk0
        have hAempty : A = ‚àÖ := by
          ext r
          constructor
          ¬∑ intro hr
            rcases hr with ‚ü®i, hi, _‚ü©
            have hi0 : (i : ‚Ñï) < 0 := by simp [hk0] at hi ‚ä¢
            exact (Nat.not_lt_zero (i : ‚Ñï)) hi0
          ¬∑ intro hr
            exact False.elim (Set.notMem_empty r hr)
        have hsSupZero : sSup A = 0 := by
          simp [hAempty]
        simpa [hsSupZero] using hŒº_nonneg
      ¬∑ have hkpos : 0 < k := Nat.pos_of_ne_zero hk0
        have hmpos : 0 < m := lt_of_lt_of_le hkpos hk
        let i0 : Fin m := ‚ü®0, hmpos‚ü©
        have hi0 : (i0 : ‚Ñï) < k := by
          simpa [i0] using hkpos
        have hA_nonempty : A.Nonempty := by
          refine ‚ü®(‚àë j, x j * b i0 j) - Œ≤ i0, ?_‚ü©
          exact ‚ü®i0, hi0, rfl‚ü©
        exact csSup_le hA_nonempty hA_upper
    have hsSup_le_EReal : ((sSup A : ‚Ñù) : EReal) ‚â§ (Œº : EReal) := by
      exact_mod_cast hsSup_le
    have hIndicator_zero : indicatorFunction (C := C) x = (0 : EReal) := by
      simp [indicatorFunction, hxC]
    have hgŒº : g x ‚â§ (Œº : EReal) := by
      simpa [g, A, C, hIndicator_zero] using hsSup_le_EReal
    have hxŒºEpi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g :=
      (mem_epigraph_univ_iff (f := g)).2 hgŒº
    have hzPackedCoord :
        prodLinearEquiv_append_coord (n := n) (x, Œº) = z := by
      change
        prodLinearEquiv_append_coord (n := n)
            ((prodLinearEquiv_append_coord (n := n)).symm z) = z
      simp
    have hzImageCoord :
        prodLinearEquiv_append_coord (n := n) (x, Œº) ‚àà
          ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) := by
      exact ‚ü®(x, Œº), hxŒºEpi, rfl‚ü©
    have hzImgCoord :
        z ‚àà
          ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) := by
      simpa [hzPackedCoord] using hzImageCoord
    simpa [Simg, prodLinearEquiv_append_coord] using hzImgCoord

/-- Helper for Text 19.0.9: polyhedrality of the transformed-epigraph image implies
convexity of the represented function on `univ`. -/
lemma helperForText_19_0_9_convexFunctionOn_of_polyhedralTransformedEpigraph
    {n : ‚Ñï} {g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hpoly :
      IsPolyhedralConvexSet (n + 1)
        (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù))) :
    ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g := by
  let e := prodLinearEquiv_append_coord (n := n)
  have hpolyCoord :
      IsPolyhedralConvexSet (n + 1)
        ((fun p => e p) '' epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) := by
    simpa [e, prodLinearEquiv_append_coord] using hpoly
  have hconvImage :
      Convex ‚Ñù ((fun p => e p) '' epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) :=
    helperForTheorem_19_1_polyhedral_isConvex
      (n := n + 1)
      (C := ((fun p => e p) '' epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g))
      hpolyCoord
  have hconvPreimage :
      Convex ‚Ñù (((fun p => e p) ‚Åª¬π'
        (((fun p => e p) '' epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g)))) := by
    simpa using hconvImage.linear_preimage e.toLinearMap
  have hpreimageEq :
      ((fun p => e p) ‚Åª¬π' (((fun p => e p) '' epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g))) =
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g :=
    Set.preimage_image_eq _ e.injective
  simpa [ConvexFunctionOn, e, hpreimageEq] using hconvPreimage

/-- Helper for Text 19.0.9: in a nonempty raw halfspace presentation of the transformed
epigraph image, each raw normal has nonpositive last coordinate. -/
lemma helperForText_19_0_9_rawHalfspaces_lastCoord_nonpos
    {n m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hRaw :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i))
    (hNonempty :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty) :
    ‚àÄ i : Fin m, a i (Fin.last n) ‚â§ 0 := by
  have hRawCoord :
      (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i) := by
    simpa [prodLinearEquiv_append_coord] using hRaw
  have hNonemptyCoord :
      (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty := by
    simpa [prodLinearEquiv_append_coord] using hNonempty
  rcases
    helperForText_19_0_9_nonempty_transformedEpigraphImage_unpack
      (n := n) (f := f) hNonempty with
    ‚ü®x0, Œº0, hx0Œº0‚ü©
  have hz0 :
      prodLinearEquiv_append_coord (n := n) (x0, Œº0) ‚àà
        (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
    refine ‚ü®(x0, Œº0), ?_, rfl‚ü©
    exact (mem_epigraph_univ_iff (f := f)).2 hx0Œº0
  intro i
  by_contra hnonpos
  have hcpos : 0 < a i (Fin.last n) := lt_of_not_ge hnonpos
  let c : ‚Ñù := a i (Fin.last n)
  let d : ‚Ñù := dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i)
  have hz0Inter :
      prodLinearEquiv_append_coord (n := n) (x0, Œº0) ‚àà
        ‚ãÇ j : Fin m, closedHalfSpaceLE (n + 1) (a j) (Œ± j) := by
    simpa [hRawCoord] using hz0
  have hz0Ineq :
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i) ‚â§ Œ± i := by
    have hz0i :
        prodLinearEquiv_append_coord (n := n) (x0, Œº0) ‚àà
          closedHalfSpaceLE (n + 1) (a i) (Œ± i) :=
      Set.mem_iInter.1 hz0Inter i
    simpa [closedHalfSpaceLE] using hz0i
  have hnum_nonneg : 0 ‚â§ Œ± i - d := by
    have hd_le : d ‚â§ Œ± i := by
      simpa [d] using hz0Ineq
    linarith
  let t : ‚Ñù := (Œ± i - d) / c + 1
  have hcpos_c : 0 < c := by
    simpa [c] using hcpos
  have ht_nonneg : 0 ‚â§ t := by
    have hdiv_nonneg : 0 ‚â§ (Œ± i - d) / c := by
      exact div_nonneg hnum_nonneg (le_of_lt hcpos_c)
    have ht_eq : t = (Œ± i - d) / c + 1 := rfl
    linarith [hdiv_nonneg, ht_eq]
  have hz_t_append :
      prodLinearEquiv_append (n := n) (x0, Œº0 + t) ‚àà
        ((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) :=
    helperForText_19_0_9_transformedEpigraphImage_upwardClosed_lastCoord
      (n := n) (f := f) (x := x0) (Œº := Œº0) (t := t)
      (by simpa [prodLinearEquiv_append_coord] using hz0) ht_nonneg
  have hz_t :
      prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t) ‚àà
        ((fun p => prodLinearEquiv_append_coord (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
    simpa [prodLinearEquiv_append_coord] using hz_t_append
  have hz_tInter :
      prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t) ‚àà
        ‚ãÇ j : Fin m, closedHalfSpaceLE (n + 1) (a j) (Œ± j) := by
    simpa [hRawCoord] using hz_t
  have hz_tIneq :
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t)) (a i) ‚â§ Œ± i := by
    have hz_ti :
        prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t) ‚àà
          closedHalfSpaceLE (n + 1) (a i) (Œ± i) :=
      Set.mem_iInter.1 hz_tInter i
    simpa [closedHalfSpaceLE] using hz_ti
  let q : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù := (prodLinearEquiv_append_coord (n := n)).symm (a i)
  have hdot_t_coord :
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t)) (a i) =
        dotProduct x0 q.1 + (Œº0 + t) * q.2 := by
    calc
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t)) (a i)
          = dotProduct
              (prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t))
              (prodLinearEquiv_append_coord (n := n) q) := by
              simp [q]
      _ = dotProduct x0 q.1 + (Œº0 + t) * q.2 := by
            simpa [q] using
              helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
                (n := n) (p := (x0, Œº0 + t)) (q := q)
  have hdot_0_coord :
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i) =
        dotProduct x0 q.1 + Œº0 * q.2 := by
    calc
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i)
          = dotProduct
              (prodLinearEquiv_append_coord (n := n) (x0, Œº0))
              (prodLinearEquiv_append_coord (n := n) q) := by
              simp [q]
      _ = dotProduct x0 q.1 + Œº0 * q.2 := by
            simpa [q] using
              helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
                (n := n) (p := (x0, Œº0)) (q := q)
  have hd_eq : d = dotProduct x0 q.1 + Œº0 * q.2 := by
    simpa [d, prodLinearEquiv_append_coord] using hdot_0_coord
  have hq2_eq_c : q.2 = c := by
    have hqlast :
        q.2 = (prodLinearEquiv_append_coord (n := n) q) (Fin.last n) := by
      simpa using
        helperForText_19_0_9_prodLinearEquivAppendCoord_last
          (n := n) (x0 := q.1) (Œº0 := q.2)
    have hqa :
        (prodLinearEquiv_append_coord (n := n) q) (Fin.last n) = a i (Fin.last n) := by
      have hqa_all :
          prodLinearEquiv_append_coord (n := n) q = a i := by
        simp [q]
      exact congrArg (fun v : Fin (n + 1) ‚Üí ‚Ñù => v (Fin.last n)) hqa_all
    calc
      q.2 = (prodLinearEquiv_append_coord (n := n) q) (Fin.last n) := hqlast
      _ = a i (Fin.last n) := hqa
      _ = c := by rfl
  have hdot_t :
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t)) (a i) = d + t * c := by
    calc
      dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0 + t)) (a i)
          = dotProduct x0 q.1 + (Œº0 + t) * q.2 := by
              exact hdot_t_coord
      _ = (dotProduct x0 q.1 + Œº0 * q.2) + t * q.2 := by ring
      _ = d + t * q.2 := by rw [hd_eq]
      _ = d + t * c := by rw [hq2_eq_c]
  have hbound : d + t * c ‚â§ Œ± i := by
    simpa [hdot_t] using hz_tIneq
  have hc_ne : c ‚â† 0 := ne_of_gt hcpos_c
  have ht_mul : t * c = (Œ± i - d) + c := by
    calc
      t * c = (((Œ± i - d) / c + 1) * c) := by
        simp [t]
      _ = (Œ± i - d) + c := by
        field_simp [hc_ne]
  have hstrict : Œ± i < d + t * c := by
    have hEq : d + t * c = Œ± i + c := by
      calc
        d + t * c = d + ((Œ± i - d) + c) := by rw [ht_mul]
        _ = Œ± i + c := by ring
    linarith [hEq, hcpos_c]
  linarith [hbound, hstrict]

/-- Helper for Text 19.0.9: from a nonempty transformed epigraph image and the repaired
polyhedral/non-`‚ä•` hypotheses, reconstruct a max-affine-plus-indicator representation. -/
lemma helperForText_19_0_9_nonempty_nonbot_forces_negative_lastCoeff_constraint
    {n m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hRaw :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i))
    (hNonempty :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty)
    (hnonbot : ‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal)) :
    ‚àÉ i : Fin m, a i (Fin.last n) < 0 := by
  by_contra hNoNeg
  have hLastCoeffNonpos :
      ‚àÄ i : Fin m, a i (Fin.last n) ‚â§ 0 :=
    helperForText_19_0_9_rawHalfspaces_lastCoord_nonpos
      (n := n) (m := m) (f := f) (a := a) (Œ± := Œ±) hRaw hNonempty
  have hLastCoeffZero :
      ‚àÄ i : Fin m, a i (Fin.last n) = 0 := by
    intro i
    have hnotlt : ¬¨ a i (Fin.last n) < 0 := by
      intro hi
      exact hNoNeg ‚ü®i, hi‚ü©
    exact le_antisymm (hLastCoeffNonpos i) (le_of_not_gt hnotlt)
  rcases
    helperForText_19_0_9_nonempty_transformedEpigraphImage_unpack
      (n := n) (f := f) hNonempty with
    ‚ü®x0, Œº0, hx0Œº0‚ü©
  have hRawCoord :
      (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i) := by
    simpa [prodLinearEquiv_append_coord] using hRaw
  have hz0Coord :
      prodLinearEquiv_append_coord (n := n) (x0, Œº0) ‚àà
        (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
    refine ‚ü®(x0, Œº0), ?_, rfl‚ü©
    exact (mem_epigraph_univ_iff (f := f)).2 hx0Œº0
  have hz0Inter :
      prodLinearEquiv_append_coord (n := n) (x0, Œº0) ‚àà
        ‚ãÇ i : Fin m, closedHalfSpaceLE (n + 1) (a i) (Œ± i) := by
    simpa [hRawCoord] using hz0Coord
  have hAllMu : ‚àÄ Œº : ‚Ñù, f x0 ‚â§ (Œº : EReal) := by
    intro Œº
    have hzŒºInter :
        prodLinearEquiv_append_coord (n := n) (x0, Œº) ‚àà
          ‚ãÇ i : Fin m, closedHalfSpaceLE (n + 1) (a i) (Œ± i) := by
      refine Set.mem_iInter.2 ?_
      intro i
      have hz0i :
          prodLinearEquiv_append_coord (n := n) (x0, Œº0) ‚àà
            closedHalfSpaceLE (n + 1) (a i) (Œ± i) :=
        Set.mem_iInter.1 hz0Inter i
      have hz0ineq :
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i) ‚â§ Œ± i := by
        simpa [closedHalfSpaceLE] using hz0i
      let q : (Fin n ‚Üí ‚Ñù) √ó ‚Ñù := (prodLinearEquiv_append_coord (n := n)).symm (a i)
      have hdotŒº :
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº)) (a i) =
            dotProduct x0 q.1 + Œº * q.2 := by
        calc
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº)) (a i)
              = dotProduct
                  (prodLinearEquiv_append_coord (n := n) (x0, Œº))
                  (prodLinearEquiv_append_coord (n := n) q) := by
                  simp [q]
          _ = dotProduct x0 q.1 + Œº * q.2 := by
                simpa [q] using
                  helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
                    (n := n) (p := (x0, Œº)) (q := q)
      have hdotŒº0 :
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i) =
            dotProduct x0 q.1 + Œº0 * q.2 := by
        calc
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i)
              = dotProduct
                  (prodLinearEquiv_append_coord (n := n) (x0, Œº0))
                  (prodLinearEquiv_append_coord (n := n) q) := by
                  simp [q]
          _ = dotProduct x0 q.1 + Œº0 * q.2 := by
                simpa [q] using
                  helperForText_19_0_9_dotProduct_prodLinearEquivAppendCoord
                    (n := n) (p := (x0, Œº0)) (q := q)
      have hq2_eq0 : q.2 = 0 := by
        have hqlast :
            q.2 = (prodLinearEquiv_append_coord (n := n) q) (Fin.last n) := by
          simpa using
            helperForText_19_0_9_prodLinearEquivAppendCoord_last
              (n := n) (x0 := q.1) (Œº0 := q.2)
        have hqa :
            (prodLinearEquiv_append_coord (n := n) q) (Fin.last n) = a i (Fin.last n) := by
          have hqa_all :
              prodLinearEquiv_append_coord (n := n) q = a i := by
            simp [q]
          exact congrArg (fun v : Fin (n + 1) ‚Üí ‚Ñù => v (Fin.last n)) hqa_all
        calc
          q.2 = (prodLinearEquiv_append_coord (n := n) q) (Fin.last n) := hqlast
          _ = a i (Fin.last n) := hqa
          _ = 0 := hLastCoeffZero i
      have hdot_eq :
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº)) (a i) =
            dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i) := by
        calc
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº)) (a i)
              = dotProduct x0 q.1 + Œº * q.2 := hdotŒº
          _ = dotProduct x0 q.1 := by simp [hq2_eq0]
          _ = dotProduct x0 q.1 + Œº0 * q.2 := by simp [hq2_eq0]
          _ = dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº0)) (a i) := by
              simpa using hdotŒº0.symm
      have hzŒºineq :
          dotProduct (prodLinearEquiv_append_coord (n := n) (x0, Œº)) (a i) ‚â§ Œ± i := by
        simpa [hdot_eq] using hz0ineq
      simpa [closedHalfSpaceLE] using hzŒºineq
    have hzŒºCoord :
        prodLinearEquiv_append_coord (n := n) (x0, Œº) ‚àà
          (((fun p => prodLinearEquiv_append_coord (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
      simpa [hRawCoord] using hzŒºInter
    have hxŒºEpi : (x0, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f :=
      (helperForText_19_0_9_mem_transformedEpigraphImage_iff_mem_epigraph_univ
        (n := n) (f := f) (x := x0) (Œº := Œº)).1 (by
          simpa [prodLinearEquiv_append_coord] using hzŒºCoord)
    exact (mem_epigraph_univ_iff (f := f)).1 hxŒºEpi
  have hfx0Bot : f x0 = (‚ä• : EReal) := by
    by_contra hNotBot
    by_cases hTop : f x0 = (‚ä§ : EReal)
    ¬∑ have hleTop : (‚ä§ : EReal) ‚â§ (0 : EReal) := by
        simpa [hTop] using hAllMu 0
      exact (not_le_of_gt (EReal.coe_lt_top (0 : ‚Ñù))) hleTop
    ¬∑ have hcoe : (((f x0).toReal : ‚Ñù) : EReal) = f x0 := by
        simpa using (EReal.coe_toReal hTop hNotBot)
      have hleToReal :
          (((f x0).toReal : ‚Ñù) : EReal) ‚â§ (((f x0).toReal - 1 : ‚Ñù) : EReal) := by
        calc
          (((f x0).toReal : ‚Ñù) : EReal) = f x0 := hcoe
          _ ‚â§ (((f x0).toReal - 1 : ‚Ñù) : EReal) := hAllMu ((f x0).toReal - 1)
      have hleToRealReal : (f x0).toReal ‚â§ (f x0).toReal - 1 := by
        exact_mod_cast hleToReal
      linarith
  exact (hnonbot x0) hfx0Bot

/-- Helper for Text 19.0.9: under a nonpositive last-coordinate hypothesis,
each raw normal is classified as either strictly negative or exactly zero on the
last coordinate. -/
lemma helperForText_19_0_9_lastCoord_nonpos_partition_neg_or_zero
    {n m : ‚Ñï} {a : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù}
    (hLastCoeffNonpos : ‚àÄ i : Fin m, a i (Fin.last n) ‚â§ 0) :
    ‚àÄ i : Fin m, a i (Fin.last n) < 0 ‚à® a i (Fin.last n) = 0 := by
  intro i
  exact lt_or_eq_of_le (hLastCoeffNonpos i)

/-- Helper for Text 19.0.9: if one raw halfspace has strictly negative last
coefficient, then the subtype of negative-index constraints is nonempty, so its
finite cardinal is nonzero. -/
lemma helperForText_19_0_9_negativeIndex_nonempty_implies_k_ne_zero_for_blockData
    {n m : ‚Ñï} {a : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù}
    (hHasNegativeLastCoeff : ‚àÉ i : Fin m, a i (Fin.last n) < 0) :
    let Ineg : Type := {i : Fin m // a i (Fin.last n) < 0}
    let k : ‚Ñï := Fintype.card Ineg
    k ‚â† 0 := by
  intro Ineg k
  rcases hHasNegativeLastCoeff with ‚ü®i0, hi0‚ü©
  have hIneg_nonempty : Nonempty Ineg := ‚ü®‚ü®i0, hi0‚ü©‚ü©
  have hk_pos : 0 < Fintype.card Ineg :=
    (Fintype.card_pos_iff).2 hIneg_nonempty
  exact Nat.ne_of_gt hk_pos

/-- Helper for Text 19.0.9: convert a nonempty transformed-epigraph raw halfspace
presentation with nonpositive/negative last-coordinate data into finite split
packed constraints in the exact guarded normal form. -/
lemma helperForText_19_0_9_rawHalfspaces_to_finBlockPackedRepresentationData
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {m : ‚Ñï} {a : Fin m ‚Üí Fin (n + 1) ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hRawPresentation :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i))
    (hLastCoeffNonpos : ‚àÄ i : Fin m, a i (Fin.last n) ‚â§ 0)
    (hHasNegativeLastCoeff : ‚àÉ i : Fin m, a i (Fin.last n) < 0) :
    ‚àÉ (k m' : ‚Ñï) (b : Fin m' ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m' ‚Üí ‚Ñù),
      0 < k ‚àß k ‚â§ m' ‚àß
        (((fun p => prodLinearEquiv_append (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
          (({z : Fin (n + 1) ‚Üí ‚Ñù |
              ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
                dotProduct z
                  (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
                dotProduct z
                  (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
            (if k = 0 then
              {z : Fin (n + 1) ‚Üí ‚Ñù |
                0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
            else Set.univ)) := by
  classical
  let Ineg : Type := {i : Fin m // a i (Fin.last n) < 0}
  let Izero : Type := {i : Fin m // a i (Fin.last n) = 0}
  let k : ‚Ñï := Fintype.card Ineg
  let l : ‚Ñï := Fintype.card Izero
  let m' : ‚Ñï := k + l
  let eNeg : Fin k ‚âÉ Ineg := (Fintype.equivFin Ineg).symm
  let eZero : Fin l ‚âÉ Izero := (Fintype.equivFin Izero).symm
  let b : Fin m' ‚Üí Fin n ‚Üí ‚Ñù :=
    Fin.addCases
      (fun i j =>
        let ii : Ineg := eNeg i
        a ii.1 (Fin.castSucc j) / (-(a ii.1 (Fin.last n))))
      (fun i j =>
        let ii : Izero := eZero i
        a ii.1 (Fin.castSucc j))
  let Œ≤ : Fin m' ‚Üí ‚Ñù :=
    Fin.addCases
      (fun i =>
        let ii : Ineg := eNeg i
        Œ± ii.1 / (-(a ii.1 (Fin.last n))))
      (fun i =>
        let ii : Izero := eZero i
        Œ± ii.1)
  have hk_ne_zero : k ‚â† 0 :=
    helperForText_19_0_9_negativeIndex_nonempty_implies_k_ne_zero_for_blockData
      (n := n) (m := m) (a := a) hHasNegativeLastCoeff
  have hk_pos : 0 < k := Nat.pos_of_ne_zero hk_ne_zero
  have hk_le_m' : k ‚â§ m' := by
    dsimp [m']
    exact Nat.le_add_right k l
  have hRawEqSplitCore :
      (‚ãÇ i : Fin m, closedHalfSpaceLE (n + 1) (a i) (Œ± i)) =
        ({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) := by
    ext z
    have hActive_iff :
        ‚àÄ j : Fin k,
          (dotProduct z
              (prodLinearEquiv_append_coord (n := n)
                (b (Fin.castAdd l j), (-1 : ‚Ñù))) ‚â§
            Œ≤ (Fin.castAdd l j))
            ‚Üî dotProduct z (a (eNeg j).1) ‚â§ Œ± (eNeg j).1 := by
      intro j
      let ii : Ineg := eNeg j
      let t : ‚Ñù := -(a ii.1 (Fin.last n))
      have ht_pos : 0 < t := by
        dsimp [t]
        linarith [ii.2]
      have hŒ≤ : Œ≤ (Fin.castAdd l j) = Œ± ii.1 / t := by
        simp [Œ≤, ii, t]
      have hnormal :
          prodLinearEquiv_append_coord (n := n)
              (b (Fin.castAdd l j), (-1 : ‚Ñù)) =
            (1 / t) ‚Ä¢ a ii.1 := by
        ext u
        refine Fin.lastCases ?_ ?_ u
        ¬∑ have hlastL :
              (prodLinearEquiv_append_coord (n := n)
                  (b (Fin.castAdd l j), (-1 : ‚Ñù))) (Fin.last n) = (-1 : ‚Ñù) := by
            have hlastPacked :=
              helperForText_19_0_9_prodLinearEquivAppendCoord_last
                (n := n) (x0 := b (Fin.castAdd l j)) (Œº0 := (-1 : ‚Ñù))
            simpa using hlastPacked.symm
          have ht_ne : t ‚â† 0 := ne_of_gt ht_pos
          calc
            (prodLinearEquiv_append_coord (n := n)
                (b (Fin.castAdd l j), (-1 : ‚Ñù))) (Fin.last n)
                = (-1 : ‚Ñù) := hlastL
            _ = (1 / t) * a ii.1 (Fin.last n) := by
                  have hlast : a ii.1 (Fin.last n) = -t := by
                    simp [t]
                  rw [hlast]
                  field_simp [ht_ne]
            _ = ((1 / t) ‚Ä¢ a ii.1) (Fin.last n) := by
                  simp [Pi.smul_apply]
        ¬∑ intro u0
          have hcastL :
              (prodLinearEquiv_append_coord (n := n)
                  (b (Fin.castAdd l j), (-1 : ‚Ñù))) (Fin.castSucc u0) =
                b (Fin.castAdd l j) u0 := by
            have hcastPacked :=
              helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
                (n := n) (x0 := b (Fin.castAdd l j)) (Œº0 := (-1 : ‚Ñù)) (j0 := u0)
            simpa using hcastPacked.symm
          have hbcast :
              b (Fin.castAdd l j) u0 =
                a ii.1 (Fin.castSucc u0) / (-(a ii.1 (Fin.last n))) := by
            simp [b, ii]
          calc
            (prodLinearEquiv_append_coord (n := n)
                (b (Fin.castAdd l j), (-1 : ‚Ñù))) (Fin.castSucc u0)
                = b (Fin.castAdd l j) u0 := hcastL
            _ = a ii.1 (Fin.castSucc u0) / (-(a ii.1 (Fin.last n))) := hbcast
            _ = (1 / t) * a ii.1 (Fin.castSucc u0) := by
                  rw [show -(a ii.1 (Fin.last n)) = t by simp [t]]
                  ring
            _ = ((1 / t) ‚Ä¢ a ii.1) (Fin.castSucc u0) := by
                  simp [Pi.smul_apply]
      have hdot :
          dotProduct z
              (prodLinearEquiv_append_coord (n := n)
                (b (Fin.castAdd l j), (-1 : ‚Ñù))) =
            dotProduct z (a ii.1) / t := by
        calc
          dotProduct z
              (prodLinearEquiv_append_coord (n := n)
                (b (Fin.castAdd l j), (-1 : ‚Ñù)))
              = dotProduct z ((1 / t) ‚Ä¢ a ii.1) := by rw [hnormal]
          _ = (1 / t) * dotProduct z (a ii.1) := by
                rw [dotProduct_smul, smul_eq_mul]
          _ = dotProduct z (a ii.1) / t := by ring
      constructor
      ¬∑ intro hsplit
        have hdiv : dotProduct z (a ii.1) / t ‚â§ Œ± ii.1 / t := by
          simpa [hŒ≤, hdot] using hsplit
        have hmul : dotProduct z (a ii.1) ‚â§ (Œ± ii.1 / t) * t :=
          (div_le_iff‚ÇÄ ht_pos).1 hdiv
        have ht_ne : t ‚â† 0 := ne_of_gt ht_pos
        have hrt : (Œ± ii.1 / t) * t = Œ± ii.1 := by
          field_simp [ht_ne]
        simpa [hrt] using hmul
      ¬∑ intro hraw
        have hdiv : dotProduct z (a ii.1) / t ‚â§ Œ± ii.1 / t :=
          div_le_div_of_nonneg_right hraw (le_of_lt ht_pos)
        simpa [hŒ≤, hdot] using hdiv
    have hDomain_iff :
        ‚àÄ j : Fin l,
          (dotProduct z
              (prodLinearEquiv_append_coord (n := n)
                (b (Fin.natAdd k j), (0 : ‚Ñù))) ‚â§
            Œ≤ (Fin.natAdd k j))
            ‚Üî dotProduct z (a (eZero j).1) ‚â§ Œ± (eZero j).1 := by
      intro j
      let ii : Izero := eZero j
      have hŒ≤ : Œ≤ (Fin.natAdd k j) = Œ± ii.1 := by
        simp [Œ≤, ii]
      have hnormal :
          prodLinearEquiv_append_coord (n := n)
              (b (Fin.natAdd k j), (0 : ‚Ñù)) =
            a ii.1 := by
        ext u
        refine Fin.lastCases ?_ ?_ u
        ¬∑ have hlastL :
              (prodLinearEquiv_append_coord (n := n)
                  (b (Fin.natAdd k j), (0 : ‚Ñù))) (Fin.last n) = (0 : ‚Ñù) := by
            have hlastPacked :=
              helperForText_19_0_9_prodLinearEquivAppendCoord_last
                (n := n) (x0 := b (Fin.natAdd k j)) (Œº0 := (0 : ‚Ñù))
            simpa using hlastPacked.symm
          calc
            (prodLinearEquiv_append_coord (n := n)
                (b (Fin.natAdd k j), (0 : ‚Ñù))) (Fin.last n)
                = (0 : ‚Ñù) := hlastL
            _ = a ii.1 (Fin.last n) := by simpa [ii] using (eZero j).2.symm
        ¬∑ intro u0
          have hcastL :
              (prodLinearEquiv_append_coord (n := n)
                  (b (Fin.natAdd k j), (0 : ‚Ñù))) (Fin.castSucc u0) =
                b (Fin.natAdd k j) u0 := by
            have hcastPacked :=
              helperForText_19_0_9_prodLinearEquivAppendCoord_castSucc
                (n := n) (x0 := b (Fin.natAdd k j)) (Œº0 := (0 : ‚Ñù)) (j0 := u0)
            simpa using hcastPacked.symm
          have hbcast :
              b (Fin.natAdd k j) u0 = a ii.1 (Fin.castSucc u0) := by
            simp [b, ii]
          calc
            (prodLinearEquiv_append_coord (n := n)
                (b (Fin.natAdd k j), (0 : ‚Ñù))) (Fin.castSucc u0)
                = b (Fin.natAdd k j) u0 := hcastL
            _ = a ii.1 (Fin.castSucc u0) := hbcast
      constructor
      ¬∑ intro hsplit
        have hraw : dotProduct z (a ii.1) ‚â§ Œ± ii.1 := by
          simpa [hnormal, hŒ≤] using hsplit
        exact hraw
      ¬∑ intro hraw
        simpa [hnormal, hŒ≤] using hraw
    constructor
    ¬∑ intro hzRaw
      have hzAll : ‚àÄ i : Fin m, dotProduct z (a i) ‚â§ Œ± i := by
        intro i
        have hzi : z ‚àà closedHalfSpaceLE (n + 1) (a i) (Œ± i) :=
          Set.mem_iInter.1 hzRaw i
        simpa [closedHalfSpaceLE] using hzi
      have hzActiveCast :
          ‚àÄ j : Fin k,
            dotProduct z
              (prodLinearEquiv_append_coord (n := n)
                (b (Fin.castAdd l j), (-1 : ‚Ñù))) ‚â§ Œ≤ (Fin.castAdd l j) := by
        intro j
        exact (hActive_iff j).2 (hzAll (eNeg j).1)
      have hzDomainNat :
          ‚àÄ j : Fin l,
            dotProduct z
              (prodLinearEquiv_append_coord (n := n)
                (b (Fin.natAdd k j), (0 : ‚Ñù))) ‚â§ Œ≤ (Fin.natAdd k j) := by
        intro j
        exact (hDomain_iff j).2 (hzAll (eZero j).1)
      refine ‚ü®?_, ?_‚ü©
      ¬∑ intro i hi
        let j : Fin k := ‚ü®(i : ‚Ñï), hi‚ü©
        have hji : (Fin.castAdd l j : Fin m') = i := by
          ext
          simp [j]
        simpa [hji] using hzActiveCast j
      ¬∑ intro i hi
        have him : (i : ‚Ñï) < k + l := by
          change (i : ‚Ñï) < m'
          exact i.is_lt
        have hjlt : (i : ‚Ñï) - k < l := by
          omega
        let j : Fin l := ‚ü®(i : ‚Ñï) - k, hjlt‚ü©
        have hji : (Fin.natAdd k j : Fin m') = i := by
          ext
          simp [j]
          omega
        simpa [hji] using hzDomainNat j
    ¬∑ intro hzSplit
      rcases hzSplit with ‚ü®hzActive, hzDomain‚ü©
      refine Set.mem_iInter.2 ?_
      intro i
      have hpart : a i (Fin.last n) < 0 ‚à® a i (Fin.last n) = 0 :=
        (helperForText_19_0_9_lastCoord_nonpos_partition_neg_or_zero
          (n := n) (m := m) (a := a) hLastCoeffNonpos) i
      have hineq : dotProduct z (a i) ‚â§ Œ± i := by
        cases hpart with
        | inl hneg =>
            let ii : Ineg := ‚ü®i, hneg‚ü©
            let j : Fin k := eNeg.symm ii
            have hlt : ((Fin.castAdd l j : Fin m') : ‚Ñï) < k := by
              exact j.is_lt
            have hzj :
                dotProduct z
                    (prodLinearEquiv_append_coord (n := n)
                      (b (Fin.castAdd l j), (-1 : ‚Ñù))) ‚â§
                  Œ≤ (Fin.castAdd l j) :=
              hzActive (Fin.castAdd l j) hlt
            have hrawj : dotProduct z (a (eNeg j).1) ‚â§ Œ± (eNeg j).1 :=
              (hActive_iff j).1 hzj
            have hej : eNeg j = ii := by
              dsimp [j]
              exact Equiv.apply_symm_apply eNeg ii
            simpa [ii, hej] using hrawj
        | inr hzero =>
            let ii : Izero := ‚ü®i, hzero‚ü©
            let j : Fin l := eZero.symm ii
            have hge : k ‚â§ ((Fin.natAdd k j : Fin m') : ‚Ñï) := by
              exact Nat.le_add_right k (j : ‚Ñï)
            have hzj :
                dotProduct z
                    (prodLinearEquiv_append_coord (n := n)
                      (b (Fin.natAdd k j), (0 : ‚Ñù))) ‚â§
                  Œ≤ (Fin.natAdd k j) :=
              hzDomain (Fin.natAdd k j) hge
            have hrawj : dotProduct z (a (eZero j).1) ‚â§ Œ± (eZero j).1 :=
              (hDomain_iff j).1 hzj
            have hej : eZero j = ii := by
              dsimp [j]
              exact Equiv.apply_symm_apply eZero ii
            simpa [ii, hej] using hrawj
      simpa [closedHalfSpaceLE] using hineq
  have hGuardUniv :
      (if k = 0 then
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
      else Set.univ) = Set.univ := by
    have hk0 : k ‚â† 0 := hk_ne_zero
    simp [hk0]
  refine ‚ü®k, m', b, Œ≤, hk_pos, hk_le_m', ?_‚ü©
  calc
    (((fun p => prodLinearEquiv_append (n := n) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù))
        = (‚ãÇ i : Fin m, closedHalfSpaceLE (n + 1) (a i) (Œ± i)) := by
            simpa using hRawPresentation
    _ =
      ({z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) :=
      hRawEqSplitCore
    _ =
      (({z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
        {z : Fin (n + 1) ‚Üí ‚Ñù |
          ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
            dotProduct z
              (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
        (if k = 0 then
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
        else Set.univ)) := by
          simp [hGuardUniv, Set.inter_univ]

/-- Helper for Text 19.0.9: once finite split packed-constraint data is available
for the transformed epigraph image, transport through the representation-image
identity and conclude equality of functions. -/
lemma helperForText_19_0_9_nonempty_forward_branch_finish_from_finBlockData
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {k m' : ‚Ñï} {b : Fin m' ‚Üí Fin n ‚Üí ‚Ñù} {Œ≤ : Fin m' ‚Üí ‚Ñù}
    (hk_le_m' : k ‚â§ m')
    (hSimgEqGuarded :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        (({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
          (if k = 0 then
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
          else Set.univ))) :
    ‚àÉ (k' m'' : ‚Ñï) (b' : Fin m'' ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤' : Fin m'' ‚Üí ‚Ñù),
      k' ‚â§ m'' ‚àß
        f =
          fun x =>
            ((sSup {r : ‚Ñù |
                ‚àÉ i : Fin m'', (i : ‚Ñï) < k' ‚àß r = (‚àë j, x j * b' i j) - Œ≤' i} : ‚Ñù) : EReal) +
              indicatorFunction
                (C := {y | ‚àÄ i : Fin m'', k' ‚â§ (i : ‚Ñï) ‚Üí
                  (‚àë j, y j * b' i j) ‚â§ Œ≤' i})
                x := by
  let g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal :=
    fun x =>
      ((sSup {r : ‚Ñù |
          ‚àÉ i : Fin m', (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
        indicatorFunction
          (C := {y | ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
            (‚àë j, y j * b i j) ‚â§ Œ≤ i})
          x
  have hSimgG :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        (({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
          (if k = 0 then
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
          else Set.univ)) := by
    simpa [g] using
      (helperForText_19_0_9_representation_transformedImage_eq_constraints_with_lastCoord_guard
        (n := n) (k := k) (m := m') (hk := hk_le_m') (b := b) (Œ≤ := Œ≤))
  have hSimgEq :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
    calc
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù))
          =
        (({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m', k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
          (if k = 0 then
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
          else Set.univ)) := hSimgEqGuarded
      _ =
        (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := hSimgG.symm
  have hfg : f = g :=
    helperForText_19_0_9_transformedImageCoord_eq_implies_function_eq
      (n := n) (f := f) (g := g) hSimgEq
  refine ‚ü®k, m', b, Œ≤, hk_le_m', ?_‚ü©
  simpa [g] using hfg

/-- Helper for Text 19.0.9: from a nonempty transformed epigraph image and the repaired
polyhedral/non-`‚ä•` hypotheses, reconstruct a max-affine-plus-indicator representation. -/
lemma helperForText_19_0_9_polyhedral_nonbot_implies_representation_of_nonempty_transformedEpigraph
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hpolyNonbot :
      IsPolyhedralConvexFunction n f ‚àß
        (‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal)))
    (hNonempty :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty) :
    ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
      k ‚â§ m ‚àß
        f =
          fun x =>
            ((sSup {r : ‚Ñù |
                ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
              indicatorFunction
                (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                  (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                x := by
  rcases hpolyNonbot with ‚ü®hpoly, hnonbot‚ü©
  rcases
    helperForText_19_0_9_nonempty_transformedEpigraphImage_unpack
      (n := n) (f := f) hNonempty with
    ‚ü®x0, Œº0, hx0Œº0‚ü©
  rcases
    helperForText_19_0_9_nonempty_polyhedral_transformedImage_extract_rawHalfspaces
      (n := n) (f := f) hpoly with
    ‚ü®m, a, Œ±, hRawHalfspaces‚ü©
  have hpolyData : IsPolyhedralConvexFunction n f := hpoly
  have hnonbotData : ‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal) := hnonbot
  have hWitnessFinite : f x0 ‚â§ (Œº0 : EReal) := hx0Œº0
  have hRawPresentation :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        ‚ãÇ i, closedHalfSpaceLE (n + 1) (a i) (Œ± i) := hRawHalfspaces
  have hNonemptyData :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) : Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty :=
    hNonempty
  have hLastCoeffNonpos :
      ‚àÄ i : Fin m, a i (Fin.last n) ‚â§ 0 :=
    helperForText_19_0_9_rawHalfspaces_lastCoord_nonpos
      (n := n) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hRawPresentation hNonemptyData
  have hHasNegativeLastCoeff :
      ‚àÉ i : Fin m, a i (Fin.last n) < 0 :=
    helperForText_19_0_9_nonempty_nonbot_forces_negative_lastCoeff_constraint
      (n := n) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hRawPresentation hNonemptyData hnonbotData
  let Ineg : Type := {i : Fin m // a i (Fin.last n) < 0}
  let Izero : Type := {i : Fin m // a i (Fin.last n) = 0}
  let k : ‚Ñï := Fintype.card Ineg
  let l : ‚Ñï := Fintype.card Izero
  let m' : ‚Ñï := k + l
  have hk_ne_zero : k ‚â† 0 :=
    helperForText_19_0_9_negativeIndex_nonempty_implies_k_ne_zero_for_blockData
      (n := n) (m := m) (a := a) hHasNegativeLastCoeff
  have hk_pos : 0 < k := Nat.pos_of_ne_zero hk_ne_zero
  have hk_le_m' : k ‚â§ m' := by
    dsimp [m']
    exact Nat.le_add_right k l
  have hPartitionNegOrZero :
      ‚àÄ i : Fin m, a i (Fin.last n) < 0 ‚à® a i (Fin.last n) = 0 :=
    helperForText_19_0_9_lastCoord_nonpos_partition_neg_or_zero
      (n := n) (m := m) (a := a) hLastCoeffNonpos
  have hRepresentationSkeletonReady :
      0 < k ‚àß k ‚â§ m' ‚àß
        (‚àÄ i : Fin m, a i (Fin.last n) < 0 ‚à® a i (Fin.last n) = 0) := by
    exact ‚ü®hk_pos, hk_le_m', hPartitionNegOrZero‚ü©
  have hpolyDataKeep : IsPolyhedralConvexFunction n f := hpolyData
  have hWitnessFiniteKeep : f x0 ‚â§ (Œº0 : EReal) := hWitnessFinite
  have hRepresentationSkeletonReadyKeep :
      0 < k ‚àß k ‚â§ m' ‚àß
        (‚àÄ i : Fin m, a i (Fin.last n) < 0 ‚à® a i (Fin.last n) = 0) :=
    hRepresentationSkeletonReady
  rcases
    helperForText_19_0_9_rawHalfspaces_to_finBlockPackedRepresentationData
      (n := n) (f := f) (m := m) (a := a) (Œ± := Œ±)
      hRawPresentation hLastCoeffNonpos hHasNegativeLastCoeff with
    ‚ü®k', m'', b', Œ≤', _hk'_pos, hk'_le_m'', hSimgEqGuarded‚ü©
  exact
    helperForText_19_0_9_nonempty_forward_branch_finish_from_finBlockData
      (n := n) (f := f) (k := k') (m' := m'') (b := b') (Œ≤ := Œ≤')
      hk'_le_m'' hSimgEqGuarded

/-- Helper for Text 19.0.9: any max-affine-plus-indicator representation induces
`IsPolyhedralConvexFunction` via transformed-epigraph polyhedrality. -/
lemma helperForText_19_0_9_representation_implies_polyhedralConvexFunction_via_transformedImage
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hrepr :
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            (fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß
                    r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x)) :
    IsPolyhedralConvexFunction n f := by
  rcases hrepr with ‚ü®k, m, b, Œ≤, hk, hEq‚ü©
  subst hEq
  let g : (Fin n ‚Üí ‚Ñù) ‚Üí EReal :=
    fun x =>
      ((sSup {r : ‚Ñù |
          ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
        indicatorFunction
          (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
            (‚àë j, y j * b i j) ‚â§ Œ≤ i})
          x
  have hpointwise_nonbot : ‚àÄ x : Fin n ‚Üí ‚Ñù, g x ‚â† (‚ä• : EReal) := by
    intro x
    simpa [g] using
      (helperForText_19_0_9_rhsRepresentation_ne_bot
        (n := n) (k := k) (m := m) (b := b) (Œ≤ := Œ≤) (x := x))
  have hpolyLifted :
      IsPolyhedralConvexSet (n + 1)
        ({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i}) :=
    helperForText_19_0_9_liftedConstraintIntersection_polyhedral
      (n := n) (k := k) (m := m) b Œ≤
  have hconvLifted :
      Convex ‚Ñù
        ({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i}) :=
    helperForTheorem_19_1_polyhedral_isConvex
      (n := n + 1)
      (C :=
        {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i})
      hpolyLifted
  have hnonbotG : ‚àÄ x : Fin n ‚Üí ‚Ñù, g x ‚â† (‚ä• : EReal) := hpointwise_nonbot
  have hkData : k ‚â§ m := hk
  have hconvLiftedData :
      Convex ‚Ñù
        ({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z (Fin.cases (-1 : ‚Ñù) (b i)) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z (Fin.cases (0 : ‚Ñù) (b i)) ‚â§ Œ≤ i}) :=
    hconvLifted
  have hImageEqGuarded :
      (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) =
        (({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
          (if k = 0 then
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
          else Set.univ)) :=
    helperForText_19_0_9_representation_transformedImage_eq_constraints_with_lastCoord_guard
      (n := n) (k := k) (m := m) hk b Œ≤
  have hpolyGuarded :
      IsPolyhedralConvexSet (n + 1)
        (({z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, (i : ‚Ñï) < k ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (-1 : ‚Ñù))) ‚â§ Œ≤ i} ‚à©
          {z : Fin (n + 1) ‚Üí ‚Ñù |
            ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
              dotProduct z
                (prodLinearEquiv_append_coord (n := n) (b i, (0 : ‚Ñù))) ‚â§ Œ≤ i}) ‚à©
          (if k = 0 then
            {z : Fin (n + 1) ‚Üí ‚Ñù |
              0 ‚â§ ((prodLinearEquiv_append_coord (n := n)).symm z).2}
          else Set.univ)) :=
    helperForText_19_0_9_guardedSplitConstraintSet_polyhedral
      (n := n) (k := k) (m := m) b Œ≤
  have hpolyImage :
      IsPolyhedralConvexSet (n + 1)
        (((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g) : Set (Fin (n + 1) ‚Üí ‚Ñù)) := by
    simpa [hImageEqGuarded] using hpolyGuarded
  have hconvG : ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) g :=
    helperForText_19_0_9_convexFunctionOn_of_polyhedralTransformedEpigraph
      (n := n) (g := g) hpolyImage
  exact ‚ü®hconvG, hpolyImage‚ü©

/-- Text 19.0.9: A convex function `f` on `‚Ñù^n` is polyhedral convex iff it can be expressed as
`f = h + Œ¥(¬∑ | C)`, where `h(x)` is the maximum of finitely many affine functions
`‚ü®x, b_i‚ü© - Œ≤_i`, and `C` is the intersection of finitely many closed half-spaces
`‚ü®x, b_i‚ü© ‚â§ Œ≤_i`. In this `EReal` formalization, the codomain condition
`f : ‚Ñù^n ‚Üí (-‚àû, +‚àû]` is encoded by the pointwise non-`‚ä•` hypothesis. -/
theorem polyhedral_convex_function_iff_max_affine_plus_indicator
    (n : ‚Ñï) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) :
    (IsPolyhedralConvexFunction n f ‚àß
      (‚àÄ x : Fin n ‚Üí ‚Ñù, f x ‚â† (‚ä• : EReal))) ‚Üî
      ‚àÉ (k m : ‚Ñï) (b : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ≤ : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          f =
            fun x =>
              ((sSup {r : ‚Ñù |
                  ‚àÉ i : Fin m, (i : ‚Ñï) < k ‚àß r = (‚àë j, x j * b i j) - Œ≤ i} : ‚Ñù) : EReal) +
                indicatorFunction
                  (C := {y | ‚àÄ i : Fin m, k ‚â§ (i : ‚Ñï) ‚Üí
                    (‚àë j, y j * b i j) ‚â§ Œ≤ i})
                  x := by
  constructor
  ¬∑ intro hpolyNonbot
    by_cases hEmpty :
        ((fun p => prodLinearEquiv_append (n := n) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) = ‚àÖ
    ¬∑ exact
        helperForText_19_0_9_polyhedral_nonbot_implies_representation_of_empty_transformedEpigraph
          (n := n) (f := f) hpolyNonbot hEmpty
    ¬∑ exact
        let S : Set (Fin (n + 1) ‚Üí ‚Ñù) :=
          ((fun p => prodLinearEquiv_append (n := n) p) ''
            epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)
        let hNonempty : S.Nonempty := by
              by_contra hNotNonempty
              have hSempty : S = ‚àÖ := Set.not_nonempty_iff_eq_empty.1 hNotNonempty
              have hSempty' :
                  ((fun p => prodLinearEquiv_append (n := n) p) ''
                    epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) = ‚àÖ := by
                simpa [S] using hSempty
              exact hEmpty hSempty'
        have hImageNonempty :
            (((fun p => prodLinearEquiv_append (n := n) p) ''
              epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) :
                Set (Fin (n + 1) ‚Üí ‚Ñù)).Nonempty := by
          simpa [S] using hNonempty
        helperForText_19_0_9_polyhedral_nonbot_implies_representation_of_nonempty_transformedEpigraph
          (n := n) (f := f) hpolyNonbot hImageNonempty
  ¬∑ intro hrepr
    refine ‚ü®?_, ?_‚ü©
    ¬∑ exact
        helperForText_19_0_9_representation_implies_polyhedralConvexFunction_via_transformedImage
          (n := n) (f := f) hrepr
    ¬∑ exact
        helperForText_19_0_9_representation_implies_pointwise_nonbot_sideCondition
          (n := n) (f := f) hrepr

/-- Text 19.0.10: A convex function `f` is finitely generated if there exist vectors
`a‚ÇÅ, ‚Ä¶, a_m` and scalars `Œ±_i` such that for every `x`, `f x` is the infimum of
`‚àë i, Œª i * Œ± i` over coefficients `Œª_i` with `‚àë i, Œª i ‚Ä¢ a_i = x`,
`‚àë_{i < k} Œª_i = 1`, and `Œª_i ‚â• 0` for all `i = 1, ‚Ä¶, m`. -/
def IsFinitelyGeneratedConvexFunction (n : ‚Ñï) (f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal) : Prop :=
  ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f ‚àß
    ‚àÉ (k m : ‚Ñï) (a : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ± : Fin m ‚Üí ‚Ñù),
      k ‚â§ m ‚àß
        ‚àÄ x,
          f x =
            sInf {r : EReal |
              ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
                (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
                (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                  (fun i => lam i)) = 1 ‚àß
                (‚àÄ i, 0 ‚â§ lam i) ‚àß
                r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)}

/-- Helper for Text 19.0.10: the coefficient constraints appearing in the finitely generated
representation can be read as one bundled conjunction. -/
lemma helperForText_19_0_10_constraintBundle_wellTyped
    {n k m : ‚Ñï} {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {x : Fin n ‚Üí ‚Ñù} {lam : Fin m ‚Üí ‚Ñù}
    (hlin : ‚àÄ j, (‚àë i, lam i * a i j) = x j)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i) :
    (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1 ‚àß
      (‚àÄ i, 0 ‚â§ lam i) := by
  exact ‚ü®hlin, hnorm, hnonneg‚ü©

/-- Helper for Text 19.0.10: the linear objective naturally provides an `EReal` value via
coercion from `‚Ñù`. -/
lemma helperForText_19_0_10_objective_cast_toEReal
    {m : ‚Ñï} {lam Œ± : Fin m ‚Üí ‚Ñù} {r : EReal}
    (hr : r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)) :
    ‚àÉ q : ‚Ñù, r = (q : EReal) := by
  refine ‚ü®‚àë i, lam i * Œ± i, ?_‚ü©
  simp [hr]

/-- Helper for Text 19.0.10: any feasible coefficient family contributes its linear objective
value as an element of the representation infimum set. -/
lemma helperForText_19_0_10_objective_mem_representationSet
    {n k m : ‚Ñï} {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    {x : Fin n ‚Üí ‚Ñù} {lam : Fin m ‚Üí ‚Ñù}
    (hlin : ‚àÄ j, (‚àë i, lam i * a i j) = x j)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i) :
    (((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚àà
      {r : EReal |
        ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
          (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
          (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
            (fun i => lam i)) = 1 ‚àß
          (‚àÄ i, 0 ‚â§ lam i) ‚àß
          r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)}) := by
  exact ‚ü®lam, hlin, hnorm, hnonneg, rfl‚ü©

/-- Helper for Text 19.0.10: unpacking the definition immediately yields convexity on `univ`,
so this definition introduces no extra proof obligation beyond its fields. -/
lemma helperForText_19_0_10_noProofObligation
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} :
    IsFinitelyGeneratedConvexFunction n f ‚Üí
      ConvexFunctionOn (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
  intro hf
  exact hf.1

/-- Helper for Corollary 19.1.2: unpack the global finite-generation data from the definition. -/
lemma helperForCorollary_19_1_2_unpack_finitelyGeneratedData
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} :
    IsFinitelyGeneratedConvexFunction n f ‚Üí
      ‚àÉ (k m : ‚Ñï) (a : Fin m ‚Üí Fin n ‚Üí ‚Ñù) (Œ± : Fin m ‚Üí ‚Ñù),
        k ‚â§ m ‚àß
          ‚àÄ x,
            f x =
              sInf {r : EReal |
                ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
                  (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
                  (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                    (fun i => lam i)) = 1 ‚àß
                  (‚àÄ i, 0 ‚â§ lam i) ‚àß
                  r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)} := by
  intro hf
  exact hf.2

/-- Helper for Corollary 19.1.2: strict epigraph inequality at `(x, Œº)` yields feasible
Text 19.0.10 coefficients whose objective value is strictly below `Œº`. -/
lemma helperForCorollary_19_1_2_exists_feasibleCoeffs_lt_mu
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hfx_lt : f x < (Œº : EReal)) :
    ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
      (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1 ‚àß
      (‚àÄ i, 0 ‚â§ lam i) ‚àß
      ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) < (Œº : EReal) := by
  let Sx : Set EReal :=
    {r : EReal |
      ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
        (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
        (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
          (fun i => lam i)) = 1 ‚àß
        (‚àÄ i, 0 ‚â§ lam i) ‚àß
        r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)}
  have hsInf_lt : sInf Sx < (Œº : EReal) := by
    simpa [Sx, hrepr x] using hfx_lt
  by_contra hNo
  have hmu_lower : (Œº : EReal) ‚â§ sInf Sx := by
    refine le_sInf ?_
    intro r hrSx
    rcases hrSx with ‚ü®lam, hlin, hnorm, hnonneg, hrObj‚ü©
    have hr_not_lt : ¬¨ r < (Œº : EReal) := by
      intro hrlt
      have hWitness :
          ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
            (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
            (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
              (fun i => lam i)) = 1 ‚àß
            (‚àÄ i, 0 ‚â§ lam i) ‚àß
            ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) < (Œº : EReal) := by
        refine ‚ü®lam, hlin, hnorm, hnonneg, ?_‚ü©
        simpa [hrObj] using hrlt
      exact hNo hWitness
    exact le_of_not_gt hr_not_lt
  exact (not_lt_of_ge hmu_lower hsInf_lt).elim

/-- Helper for Corollary 19.1.2: any feasible Text 19.0.10 coefficients whose objective value
is bounded above by `Œº` certify epigraph membership at `(x, Œº)`. -/
lemma helperForCorollary_19_1_2_mem_epigraph_univ_of_feasible_obj_le
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    {lam : Fin m ‚Üí ‚Ñù}
    (hlin : ‚àÄ j, (‚àë i, lam i * a i j) = x j)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i)
    (hobj_le : (‚àë i, lam i * Œ± i : ‚Ñù) ‚â§ Œº) :
    (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
  let Sx : Set EReal :=
    {r : EReal |
      ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
        (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
        (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
          (fun i => lam i)) = 1 ‚àß
        (‚àÄ i, 0 ‚â§ lam i) ‚àß
        r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)}
  have hsInf_le_obj : sInf Sx ‚â§ ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) := by
    exact sInf_le ‚ü®lam, hlin, hnorm, hnonneg, rfl‚ü©
  have hfx_le_obj : f x ‚â§ ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) := by
    simpa [Sx, hrepr x] using hsInf_le_obj
  have hobj_leE : ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal) := by
    exact_mod_cast hobj_le
  have hfx_le_mu : f x ‚â§ (Œº : EReal) := le_trans hfx_le_obj hobj_leE
  exact (mem_epigraph_univ_iff (f := f)).2 hfx_le_mu

/-- Helper for Corollary 19.1.2: any feasible Text 19.0.10 coefficients whose objective value
is strictly below `Œº` certify epigraph membership at `(x, Œº)`. -/
lemma helperForCorollary_19_1_2_mem_epigraph_univ_of_feasible_obj_lt
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    {lam : Fin m ‚Üí ‚Ñù}
    (hlin : ‚àÄ j, (‚àë i, lam i * a i j) = x j)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i)
    (hobj_lt : ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) < (Œº : EReal)) :
    (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
  have hobj_leE : ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal) := le_of_lt hobj_lt
  have hobj_le : (‚àë i, lam i * Œ± i : ‚Ñù) ‚â§ Œº := by
    exact_mod_cast hobj_leE
  exact
    helperForCorollary_19_1_2_mem_epigraph_univ_of_feasible_obj_le
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) (lam := lam)
      hlin hnorm hnonneg hobj_le

/-- Helper for Corollary 19.1.2: membership of `(x, Œº)` in the transformed epigraph image is
equivalent to ordinary epigraph membership at `(x, Œº)` via the append-coordinate linear equivalence. -/
lemma helperForCorollary_19_1_2_mem_transformedEpigraphImage_iff_mem_epigraph_univ
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù} :
    (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
      ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) ‚Üî
      (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
  constructor
  ¬∑ intro hmem
    rcases hmem with ‚ü®p, hpEpi, hpImage‚ü©
    have hp : p = (x, Œº) :=
      (prodLinearEquiv_append_coord (n := n)).injective hpImage
    simpa [hp] using hpEpi
  ¬∑ intro hmem
    exact ‚ü®(x, Œº), hmem, rfl‚ü©

/-- Helper for Corollary 19.1.2: transformed-epigraph image membership directly yields
ordinary epigraph membership at `(x, Œº)`. -/
lemma helperForCorollary_19_1_2_mem_epigraph_univ_of_mem_transformedEpigraphImage
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hmem :
      (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) :
    (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f := by
  exact
    (helperForCorollary_19_1_2_mem_transformedEpigraphImage_iff_mem_epigraph_univ
      (n := n) (f := f) (x := x) (Œº := Œº)).1 hmem

/-- Helper for Corollary 19.1.2: transformed-epigraph image membership implies the defining
epigraph inequality `f x ‚â§ Œº` after coercion to `EReal`. -/
lemma helperForCorollary_19_1_2_fx_leEReal_of_mem_transformedEpigraphImage
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal} {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hmem :
      (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
        ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
          epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f)) :
    f x ‚â§ (Œº : EReal) := by
  have hmemEpi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f :=
    helperForCorollary_19_1_2_mem_epigraph_univ_of_mem_transformedEpigraphImage
      (n := n) (f := f) (x := x) (Œº := Œº) hmem
  exact (mem_epigraph_univ_iff (f := f)).1 hmemEpi

/-- Helper for Corollary 19.1.2: packing coefficient-representation data into finite
generation of the transformed epigraph. -/
lemma helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_decodedFeasible
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hdecode :
      ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
        (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
        (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
          (fun i => lam i)) = 1 ‚àß
        (‚àÄ i, 0 ‚â§ lam i) ‚àß
        ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal)) :
    (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
      ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
  rcases hdecode with ‚ü®lam, hlin, hnorm, hnonneg, hobj_le‚ü©
  have hobj_le_real : (‚àë i, lam i * Œ± i : ‚Ñù) ‚â§ Œº := by
    exact_mod_cast hobj_le
  have hqepi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f :=
    helperForCorollary_19_1_2_mem_epigraph_univ_of_feasible_obj_le
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) (lam := lam)
      hlin hnorm hnonneg hobj_le_real
  exact
    (helperForCorollary_19_1_2_mem_transformedEpigraphImage_iff_mem_epigraph_univ
      (n := n) (f := f) (x := x) (Œº := Œº)).2 hqepi

/-- Helper for Corollary 19.1.2: non-strict direct feasible objective data yields
membership in the transformed epigraph image. -/
lemma helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_directFeasible_le
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    {lam : Fin m ‚Üí ‚Ñù}
    (hlin : ‚àÄ j, (‚àë i, lam i * a i j) = x j)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i)
    (hobj_le : ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal)) :
    (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
      ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
  have hdecode :
      ‚àÉ (lam' : Fin m ‚Üí ‚Ñù),
        (‚àÄ j, (‚àë i, lam' i * a i j) = x j) ‚àß
        (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
          (fun i => lam' i)) = 1 ‚àß
        (‚àÄ i, 0 ‚â§ lam' i) ‚àß
        ((‚àë i, lam' i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal) := by
    exact ‚ü®lam, hlin, hnorm, hnonneg, hobj_le‚ü©
  exact
    helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_decodedFeasible
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) hdecode

/-- Helper for Corollary 19.1.2: strict objective feasibility data directly yields
membership in the transformed epigraph image. -/
lemma helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_directFeasible_lt
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    {lam : Fin m ‚Üí ‚Ñù}
    (hlin : ‚àÄ j, (‚àë i, lam i * a i j) = x j)
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1)
    (hnonneg : ‚àÄ i, 0 ‚â§ lam i)
    (hobj_lt : ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) < (Œº : EReal)) :
    (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
      ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
  have hqepi : (x, Œº) ‚àà epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f :=
    helperForCorollary_19_1_2_mem_epigraph_univ_of_feasible_obj_lt
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) (lam := lam)
      hlin hnorm hnonneg hobj_lt
  exact
    (helperForCorollary_19_1_2_mem_transformedEpigraphImage_iff_mem_epigraph_univ
      (n := n) (f := f) (x := x) (Œº := Œº)).2 hqepi

/-- Helper for Corollary 19.1.2: strict epigraph inequality gives feasible coefficients
with a non-strict objective upper bound. -/
lemma helperForCorollary_19_1_2_exists_feasibleCoeffs_le_mu_of_strictIneq
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hfx_lt : f x < (Œº : EReal)) :
    ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
      (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1 ‚àß
      (‚àÄ i, 0 ‚â§ lam i) ‚àß
      ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal) := by
  rcases
      helperForCorollary_19_1_2_exists_feasibleCoeffs_lt_mu
        (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
        hrepr (x := x) (Œº := Œº) hfx_lt with
    ‚ü®lam, hlin, hnorm, hnonneg, hobj_lt‚ü©
  exact ‚ü®lam, hlin, hnorm, hnonneg, le_of_lt hobj_lt‚ü©

/-- Helper for Corollary 19.1.2: strict epigraph inequality yields transformed-epigraph
membership by extracting feasible coefficients and weakening `<` to `‚â§`. -/
lemma helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_strictIneq
    {n k m : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    {a : Fin m ‚Üí Fin n ‚Üí ‚Ñù} {Œ± : Fin m ‚Üí ‚Ñù}
    (hrepr :
      ‚àÄ x,
        f x =
          sInf {r : EReal |
            ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
              (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
              (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
                (fun i => lam i)) = 1 ‚àß
              (‚àÄ i, 0 ‚â§ lam i) ‚àß
              r = ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal)})
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hfx_lt : f x < (Œº : EReal)) :
    (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
      ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
  have hdecode :
      ‚àÉ (lam : Fin m ‚Üí ‚Ñù),
        (‚àÄ j, (‚àë i, lam i * a i j) = x j) ‚àß
        (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
          (fun i => lam i)) = 1 ‚àß
        (‚àÄ i, 0 ‚â§ lam i) ‚àß
        ((‚àë i, lam i * Œ± i : ‚Ñù) : EReal) ‚â§ (Œº : EReal) :=
    helperForCorollary_19_1_2_exists_feasibleCoeffs_le_mu_of_strictIneq
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) hfx_lt
  exact
    helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_decodedFeasible
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) hdecode

/-- Helper for Corollary 19.1.2: unpacking finite-generation data and applying the strict
inequality decode step yields transformed-epigraph membership. -/
lemma helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_finitelyGenerated_strictIneq
    {n : ‚Ñï} {f : (Fin n ‚Üí ‚Ñù) ‚Üí EReal}
    (hfg : IsFinitelyGeneratedConvexFunction n f)
    {x : Fin n ‚Üí ‚Ñù} {Œº : ‚Ñù}
    (hfx_lt : f x < (Œº : EReal)) :
    (prodLinearEquiv_append_coord (n := n)) (x, Œº) ‚àà
      ((fun p => (prodLinearEquiv_append_coord (n := n)) p) ''
        epigraph (Set.univ : Set (Fin n ‚Üí ‚Ñù)) f) := by
  rcases
      helperForCorollary_19_1_2_unpack_finitelyGeneratedData
        (n := n) (f := f) hfg with
    ‚ü®k, m, a, Œ±, hk, hrepr‚ü©
  exact
    helperForCorollary_19_1_2_mem_transformedEpigraphImage_of_strictIneq
      (n := n) (k := k) (m := m) (f := f) (a := a) (Œ± := Œ±)
      hrepr (x := x) (Œº := Œº) hfx_lt

/-- Helper for Corollary 19.1.2: dropping a nonnegative vertical term from an objective
decomposition preserves an upper bound, both in `‚Ñù` and after coercion to `EReal`. -/
lemma helperForCorollary_19_1_2_objective_dropVertical_le
    {qCore tVert Œº : ‚Ñù}
    (hdecomp : qCore + tVert ‚â§ Œº)
    (htVert_nonneg : 0 ‚â§ tVert) :
    qCore ‚â§ Œº ‚àß ((qCore : EReal) ‚â§ (Œº : EReal)) := by
  have hreal : qCore ‚â§ Œº := by linarith
  refine ‚ü®hreal, ?_‚ü©
  exact_mod_cast hreal

/-- Helper for Corollary 19.1.2: summing over indices `< k` in `Fin (k + m)` is the same
as summing over `Fin k` via `Fin.castAdd`. -/
lemma helperForCorollary_19_1_2_sum_filter_lt_eq_sum_castAdd
    {k m : ‚Ñï} (g : Fin (k + m) ‚Üí ‚Ñù) :
    Finset.sum (Finset.univ.filter (fun i : Fin (k + m) => (i : ‚Ñï) < k)) (fun i => g i) =
      ‚àë i : Fin k, g (Fin.castAdd m i) := by
  let h : Fin (k + m) ‚Üí ‚Ñù := fun i => if (i : ‚Ñï) < k then g i else 0
  have hfilter :
      Finset.sum (Finset.univ.filter (fun i : Fin (k + m) => (i : ‚Ñï) < k)) (fun i => g i) =
        ‚àë i : Fin (k + m), h i := by
    simp [h, Finset.sum_filter]
  have hsplit :
      (‚àë i : Fin (k + m), h i) =
        (‚àë i : Fin k, h (Fin.castAdd m i)) + (‚àë j : Fin m, h (Fin.natAdd k j)) := by
    simpa using (Fin.sum_univ_add (f := h))
  have hright_zero : (‚àë j : Fin m, h (Fin.natAdd k j)) = 0 := by
    refine Finset.sum_eq_zero ?_
    intro j hj
    have hnot : ¬¨ ((Fin.natAdd k j : Fin (k + m)) : ‚Ñï) < k := by
      exact Nat.not_lt.mpr (Nat.le_add_right k (j : ‚Ñï))
    simp [h]
  have hleft : (‚àë i : Fin k, h (Fin.castAdd m i)) = ‚àë i : Fin k, g (Fin.castAdd m i) := by
    refine Finset.sum_congr rfl ?_
    intro i hi
    simp [h]
  calc
    Finset.sum (Finset.univ.filter (fun i : Fin (k + m) => (i : ‚Ñï) < k)) (fun i => g i)
        = ‚àë i : Fin (k + m), h i := hfilter
    _ = (‚àë i : Fin k, h (Fin.castAdd m i)) + (‚àë j : Fin m, h (Fin.natAdd k j)) := hsplit
    _ = (‚àë i : Fin k, h (Fin.castAdd m i)) := by rw [hright_zero, add_zero]
    _ = ‚àë i : Fin k, g (Fin.castAdd m i) := hleft

/-- Helper for Corollary 19.1.2: transport the `< k` filtered sum on `Fin m`
to the left block of `Fin (k + (m - k))` via the canonical cast induced by `k ‚â§ m`. -/
lemma helperForCorollary_19_1_2_sum_filter_lt_eq_sum_leftBlock_cast
    {k m : ‚Ñï} (hk : k ‚â§ m) (lam : Fin m ‚Üí ‚Ñù) :
    (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k)) (fun i => lam i)) =
      ‚àë i : Fin k, lam ((Fin.cast (Nat.add_sub_of_le hk)) (Fin.castAdd (m - k) i)) := by
  let hkm : k + (m - k) = m := Nat.add_sub_of_le hk
  let castKM : Fin (k + (m - k)) ‚Üí Fin m := Fin.cast hkm
  have hleft_from_cast :
      (‚àë i : Fin k, lam (castKM (Fin.castAdd (m - k) i))) =
        (Finset.sum (Finset.univ.filter (fun i : Fin (k + (m - k)) => (i : ‚Ñï) < k))
          (fun i => lam (castKM i))) := by
    rw [helperForCorollary_19_1_2_sum_filter_lt_eq_sum_castAdd
      (k := k) (m := m - k) (g := fun i => lam (castKM i))]
  let e : Fin (k + (m - k)) ‚âÉ Fin m := finCongr hkm
  have htransport :
      (‚àë i : Fin (k + (m - k)), if ((e i : Fin m) : ‚Ñï) < k then lam (e i) else 0) =
        (‚àë j : Fin m, if (j : ‚Ñï) < k then lam j else 0) := by
    simpa [e] using
      (Equiv.sum_comp e (fun j : Fin m => if (j : ‚Ñï) < k then lam j else 0))
  have htransport' :
      (‚àë i : Fin (k + (m - k)), if (i : ‚Ñï) < k then lam (castKM i) else 0) =
        (‚àë i : Fin (k + (m - k)), if ((e i : Fin m) : ‚Ñï) < k then lam (e i) else 0) := by
    simp [e, castKM]
  have hfilter_cast :
      (Finset.sum (Finset.univ.filter (fun i : Fin (k + (m - k)) => (i : ‚Ñï) < k))
        (fun i => lam (castKM i))) =
        (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
          (fun i => lam i)) := by
    calc
      (Finset.sum (Finset.univ.filter (fun i : Fin (k + (m - k)) => (i : ‚Ñï) < k))
        (fun i => lam (castKM i)))
          = (‚àë i : Fin (k + (m - k)), if (i : ‚Ñï) < k then lam (castKM i) else 0) := by
              simp [Finset.sum_filter]
      _ = (‚àë i : Fin (k + (m - k)), if ((e i : Fin m) : ‚Ñï) < k then lam (e i) else 0) :=
            htransport'
      _ = (‚àë j : Fin m, if (j : ‚Ñï) < k then lam j else 0) := htransport
      _ =
          (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
            (fun i => lam i)) := by
              simp [Finset.sum_filter]
  exact (hleft_from_cast.trans hfilter_cast).symm

/-- Helper for Corollary 19.1.2: summing over indices not `< k` in `Fin (k + m)` is the same
as summing over the right block via `Fin.natAdd`. -/
lemma helperForCorollary_19_1_2_sum_filter_not_lt_eq_sum_natAdd
    {k m : ‚Ñï} (g : Fin (k + m) ‚Üí ‚Ñù) :
    Finset.sum (Finset.univ.filter (fun i : Fin (k + m) => ¬¨ ((i : ‚Ñï) < k))) (fun i => g i) =
      ‚àë j : Fin m, g (Fin.natAdd k j) := by
  let h : Fin (k + m) ‚Üí ‚Ñù := fun i => if ¬¨ ((i : ‚Ñï) < k) then g i else 0
  have hfilter :
      Finset.sum (Finset.univ.filter (fun i : Fin (k + m) => ¬¨ ((i : ‚Ñï) < k))) (fun i => g i) =
        ‚àë i : Fin (k + m), h i := by
    simp [h, Finset.sum_filter]
  have hsplit :
      (‚àë i : Fin (k + m), h i) =
        (‚àë i : Fin k, h (Fin.castAdd m i)) + (‚àë j : Fin m, h (Fin.natAdd k j)) := by
    simpa using (Fin.sum_univ_add (f := h))
  have hleft_zero : (‚àë i : Fin k, h (Fin.castAdd m i)) = 0 := by
    refine Finset.sum_eq_zero ?_
    intro i hi
    simp [h]
  have hright : (‚àë j : Fin m, h (Fin.natAdd k j)) = ‚àë j : Fin m, g (Fin.natAdd k j) := by
    refine Finset.sum_congr rfl ?_
    intro j hj
    have hnot : ¬¨ ((Fin.natAdd k j : Fin (k + m)) : ‚Ñï) < k := by
      exact Nat.not_lt.mpr (Nat.le_add_right k (j : ‚Ñï))
    simp [h]
  calc
    Finset.sum (Finset.univ.filter (fun i : Fin (k + m) => ¬¨ ((i : ‚Ñï) < k))) (fun i => g i)
        = ‚àë i : Fin (k + m), h i := hfilter
    _ = (‚àë i : Fin k, h (Fin.castAdd m i)) + (‚àë j : Fin m, h (Fin.natAdd k j)) := hsplit
    _ = (‚àë j : Fin m, h (Fin.natAdd k j)) := by rw [hleft_zero, zero_add]
    _ = ‚àë j : Fin m, g (Fin.natAdd k j) := hright

/-- Helper for Corollary 19.1.2: transport the `¬¨(< k)` filtered sum on `Fin m` to the right
block of `Fin (k + (m - k))` via the canonical cast induced by `k ‚â§ m`. -/
lemma helperForCorollary_19_1_2_sum_filter_not_lt_eq_sum_rightBlock_cast
    {k m : ‚Ñï} (hk : k ‚â§ m) (lam : Fin m ‚Üí ‚Ñù) :
    (Finset.sum (Finset.univ.filter (fun i : Fin m => ¬¨ ((i : ‚Ñï) < k))) (fun i => lam i)) =
      ‚àë j : Fin (m - k), lam ((Fin.cast (Nat.add_sub_of_le hk)) (Fin.natAdd k j)) := by
  let hkm : k + (m - k) = m := Nat.add_sub_of_le hk
  let castKM : Fin (k + (m - k)) ‚Üí Fin m := Fin.cast hkm
  have hright_from_cast :
      (Finset.sum (Finset.univ.filter (fun i : Fin (k + (m - k)) => ¬¨ ((i : ‚Ñï) < k))
        ) (fun i => lam (castKM i))) =
        (‚àë j : Fin (m - k), lam (castKM (Fin.natAdd k j))) := by
    simpa using
      (helperForCorollary_19_1_2_sum_filter_not_lt_eq_sum_natAdd
        (k := k) (m := m - k) (g := fun i => lam (castKM i)))
  let e : Fin (k + (m - k)) ‚âÉ Fin m := finCongr hkm
  have htransport :
      (‚àë i : Fin (k + (m - k)), if ¬¨ (((e i : Fin m) : ‚Ñï) < k) then lam (e i) else 0) =
        (‚àë j : Fin m, if ¬¨ ((j : ‚Ñï) < k) then lam j else 0) := by
    simpa [e] using
      (Equiv.sum_comp e (fun j : Fin m => if ¬¨ ((j : ‚Ñï) < k) then lam j else 0))
  have htransport' :
      (‚àë i : Fin (k + (m - k)), if ¬¨ ((i : ‚Ñï) < k) then lam (castKM i) else 0) =
        (‚àë i : Fin (k + (m - k)), if ¬¨ (((e i : Fin m) : ‚Ñï) < k) then lam (e i) else 0) := by
    simp [e, castKM]
  have hfilter_cast :
      (Finset.sum (Finset.univ.filter (fun i : Fin (k + (m - k)) => ¬¨ ((i : ‚Ñï) < k))
        ) (fun i => lam (castKM i))) =
        (Finset.sum (Finset.univ.filter (fun i : Fin m => ¬¨ ((i : ‚Ñï) < k)))
          (fun i => lam i)) := by
    calc
      (Finset.sum (Finset.univ.filter (fun i : Fin (k + (m - k)) => ¬¨ ((i : ‚Ñï) < k))
        ) (fun i => lam (castKM i)))
          = (‚àë i : Fin (k + (m - k)), if ¬¨ ((i : ‚Ñï) < k) then lam (castKM i) else 0) := by
              simp [Finset.sum_filter]
      _ = (‚àë i : Fin (k + (m - k)), if ¬¨ (((e i : Fin m) : ‚Ñï) < k) then lam (e i) else 0) :=
            htransport'
      _ = (‚àë j : Fin m, if ¬¨ ((j : ‚Ñï) < k) then lam j else 0) := htransport
      _ =
          (Finset.sum (Finset.univ.filter (fun i : Fin m => ¬¨ ((i : ‚Ñï) < k)))
            (fun i => lam i)) := by
              simp [Finset.sum_filter]
  exact hfilter_cast.symm.trans hright_from_cast

/-- Helper for Corollary 19.1.2: transport both filtered coefficient sums from `Fin m`
to the left and right packed blocks in one statement via the canonical cast from `k ‚â§ m`. -/
lemma helperForCorollary_19_1_2_sum_filter_split_eq_pair_leftRight_cast
    {k m : ‚Ñï} (hk : k ‚â§ m) (lam : Fin m ‚Üí ‚Ñù) :
    ((Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k)) (fun i => lam i)) =
      ‚àë i : Fin k, lam ((Fin.cast (Nat.add_sub_of_le hk)) (Fin.castAdd (m - k) i))) ‚àß
      ((Finset.sum (Finset.univ.filter (fun i : Fin m => ¬¨ ((i : ‚Ñï) < k)))
        (fun i => lam i)) =
        ‚àë j : Fin (m - k), lam ((Fin.cast (Nat.add_sub_of_le hk)) (Fin.natAdd k j))) := by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact
      helperForCorollary_19_1_2_sum_filter_lt_eq_sum_leftBlock_cast
        (k := k) (m := m) hk lam
  ¬∑ exact
      helperForCorollary_19_1_2_sum_filter_not_lt_eq_sum_rightBlock_cast
        (k := k) (m := m) hk lam

/-- Helper for Corollary 19.1.2: the Text 19.0.10 normalization constraint transports to the
left packed block via the canonical cast induced by `k ‚â§ m`. -/
lemma helperForCorollary_19_1_2_transport_normalization_to_leftBlock
    {k m : ‚Ñï} (hk : k ‚â§ m) {lam : Fin m ‚Üí ‚Ñù}
    (hnorm :
      (Finset.sum (Finset.univ.filter (fun i : Fin m => (i : ‚Ñï) < k))
        (fun i => lam i)) = 1) :
    (‚àë i : Fin k, lam ((Fin.cast (Nat.add_sub_of_le hk)) (Fin.castAdd (m - k) i))) = 1 := by
  rw [‚Üê helperForCorollary_19_1_2_sum_filter_lt_eq_sum_leftBlock_cast
    (k := k) (m := m) hk lam]
  exact hnorm

/-- Helper for Corollary 19.1.2: decoding second coordinates after packing by `Fin.append`
and `prodLinearEquiv_append_coord` recovers the appended second-coordinate family. -/
lemma helperForCorollary_19_1_2_decodeSymmSecondCoord_of_appendPacked
    {n r : ‚Ñï}
    (uLeft : Fin 1 ‚Üí (Fin n ‚Üí ‚Ñù) √ó ‚Ñù)
    (uRight : Fin r ‚Üí (Fin n ‚Üí ‚Ñù) √ó ‚Ñù) :
    (fun j : Fin (1 + r) =>
      ((prodLinearEquiv_append_coord (n := n)).symm
        (Fin.append
          (fun i : Fin 1 => (prodLinearEquiv_append_coord (n := n)) (uLeft i))
          (fun i : Fin r => (prodLinearEquiv_append_coord (n := n)) (uRight i))
          j)).2) =
      Fin.append (fun i : Fin 1 => (uLeft i).2) (fun i : Fin r => (uRight i).2) := by
  funext j
  refine Fin.addCases ?_ ?_ j
  ¬∑ intro i
    simp
  ¬∑ intro i
    simp

/-- Helper for Corollary 19.1.2: split a packed-index sum into the left block,
the vertical singleton slot, and the right block. -/
lemma helperForCorollary_19_1_2_splitPackedIndexSums_atVertical
    {k m : ‚Ñï} (g : Fin (k + (1 + (m - k))) ‚Üí ‚Ñù) :
    (‚àë i, g i) =
      (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
        g (Fin.natAdd k (Fin.castAdd (m - k) (0 : Fin 1))) +
          (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j))) := by
  have hsplitOuter :
      (‚àë i, g i) =
        (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
          (‚àë u : Fin (1 + (m - k)), g (Fin.natAdd k u)) := by
    simpa using (Fin.sum_univ_add (f := g))
  have hsplitInner :
      (‚àë u : Fin (1 + (m - k)), g (Fin.natAdd k u)) =
        (‚àë u : Fin 1, g (Fin.natAdd k (Fin.castAdd (m - k) u))) +
          (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j))) := by
    simpa using
      (Fin.sum_univ_add (f := fun u : Fin (1 + (m - k)) => g (Fin.natAdd k u)))
  have hone :
      (‚àë u : Fin 1, g (Fin.natAdd k (Fin.castAdd (m - k) u))) =
        g (Fin.natAdd k (Fin.castAdd (m - k) (0 : Fin 1))) := by
    simp
  calc
    (‚àë i, g i)
        =
          (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
            ((‚àë u : Fin 1, g (Fin.natAdd k (Fin.castAdd (m - k) u))) +
              (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j)))) := by
            rw [hsplitOuter, hsplitInner]
    _ =
          (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
            (g (Fin.natAdd k (Fin.castAdd (m - k) (0 : Fin 1))) +
              (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j)))) := by
            rw [hone]
    _ =
          (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
            g (Fin.natAdd k (Fin.castAdd (m - k) (0 : Fin 1))) +
              (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j))) := by
            simpa [add_assoc]

/-- Helper for Corollary 19.1.2: decoding a packed three-block linear sum (left points,
vertical singleton, right directions) recovers the original first-coordinate linear sum,
since the vertical block contributes `0`. -/
lemma helperForCorollary_19_1_2_packedLinearSum_eq_originalLinearSum
    {n k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (uLeft : Fin k ‚Üí Fin n ‚Üí ‚Ñù)
    (uRight : Fin (m - k) ‚Üí Fin n ‚Üí ‚Ñù)
    (j0 : Fin n) :
    (‚àë i : Fin (k + (1 + (m - k))),
      (Fin.append aFix bFix i) *
        (Fin.append uLeft (Fin.append (fun _ : Fin 1 => (0 : Fin n ‚Üí ‚Ñù)) uRight) i) j0) =
      (‚àë i : Fin k, aFix i * uLeft i j0) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * uRight j j0) := by
  let g : Fin (k + (1 + (m - k))) ‚Üí ‚Ñù :=
    fun i =>
      (Fin.append aFix bFix i) *
        (Fin.append uLeft (Fin.append (fun _ : Fin 1 => (0 : Fin n ‚Üí ‚Ñù)) uRight) i) j0
  have hsplit :=
    helperForCorollary_19_1_2_splitPackedIndexSums_atVertical (k := k) (m := m) g
  calc
    (‚àë i : Fin (k + (1 + (m - k))),
      (Fin.append aFix bFix i) *
        (Fin.append uLeft (Fin.append (fun _ : Fin 1 => (0 : Fin n ‚Üí ‚Ñù)) uRight) i) j0)
        = (‚àë i, g i) := by rfl
    _ =
          (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
            g (Fin.natAdd k (Fin.castAdd (m - k) (0 : Fin 1))) +
              (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j))) := hsplit
    _ =
          (‚àë i : Fin k, aFix i * uLeft i j0) +
            (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * uRight j j0) := by
          simp [g]

/-- Helper for Corollary 19.1.2: decoding a packed three-block objective sum yields the
original objective plus the vertical coefficient contribution. -/
lemma helperForCorollary_19_1_2_packedObjectiveSum_eq_originalPlusVertical
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù) :
    (‚àë i : Fin (k + (1 + (m - k))),
      (Fin.append aFix bFix i) *
        (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) =
      (‚àë i : Fin k, aFix i * Œ±Left i) +
        bFix (Fin.castAdd (m - k) (0 : Fin 1)) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) := by
  let g : Fin (k + (1 + (m - k))) ‚Üí ‚Ñù :=
    fun i =>
      (Fin.append aFix bFix i) *
        (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)
  have hsplit :=
    helperForCorollary_19_1_2_splitPackedIndexSums_atVertical (k := k) (m := m) g
  calc
    (‚àë i : Fin (k + (1 + (m - k))),
      (Fin.append aFix bFix i) *
        (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i))
        = (‚àë i, g i) := by rfl
    _ =
          (‚àë i : Fin k, g (Fin.castAdd (1 + (m - k)) i)) +
            g (Fin.natAdd k (Fin.castAdd (m - k) (0 : Fin 1))) +
              (‚àë j : Fin (m - k), g (Fin.natAdd k (Fin.natAdd 1 j))) := hsplit
    _ =
          (‚àë i : Fin k, aFix i * Œ±Left i) +
            bFix (Fin.castAdd (m - k) (0 : Fin 1)) +
            (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) := by
          simp [g, add_assoc]

/-- Helper for Corollary 19.1.2: a packed-objective equality is equivalent to equality of the
decoded left-plus-vertical-plus-right objective decomposition. -/
lemma helperForCorollary_19_1_2_packedObjective_eq_iff_originalPlusVertical_eq
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù} :
    ((‚àë i : Fin (k + (1 + (m - k))),
      (Fin.append aFix bFix i) *
        (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº) ‚Üî
      ((‚àë i : Fin k, aFix i * Œ±Left i) +
        bFix (Fin.castAdd (m - k) (0 : Fin 1)) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) = Œº) := by
  constructor <;> intro hEq
  ¬∑
    simpa [helperForCorollary_19_1_2_packedObjectiveSum_eq_originalPlusVertical
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)] using hEq
  ¬∑
    simpa [helperForCorollary_19_1_2_packedObjectiveSum_eq_originalPlusVertical
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)] using hEq

/-- Helper for Corollary 19.1.2: a packed-objective upper bound and nonnegativity of the
vertical singleton coefficient imply the corresponding upper bound for the original objective,
both in `‚Ñù` and after coercion to `EReal`. -/
lemma helperForCorollary_19_1_2_originalObjective_le_of_packedObjective_le
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_le :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) ‚â§ Œº)
    (hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1))) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) ‚àß
      (((((‚àë i : Fin k, aFix i * Œ±Left i) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§ (Œº : EReal)) := by
  let qLeft : ‚Ñù := ‚àë i : Fin k, aFix i * Œ±Left i
  let qRight : ‚Ñù := ‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j
  let tVert : ‚Ñù := bFix (Fin.castAdd (m - k) (0 : Fin 1))
  let qCore : ‚Ñù := qLeft + qRight
  have hdecomp_raw :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) =
        qLeft + tVert + qRight := by
    simpa [qLeft, tVert, qRight] using
      helperForCorollary_19_1_2_packedObjectiveSum_eq_originalPlusVertical
        (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
  have hpacked_as : qLeft + tVert + qRight ‚â§ Œº := by
    simpa [hdecomp_raw] using hpacked_le
  have hqCore_plus_tVert : qCore + tVert ‚â§ Œº := by
    calc
      qCore + tVert = qLeft + tVert + qRight := by
        calc
          qCore + tVert = (qLeft + qRight) + tVert := by rfl
          _ = qLeft + (qRight + tVert) := by rw [add_assoc]
          _ = qLeft + (tVert + qRight) := by rw [add_comm qRight tVert]
          _ = qLeft + tVert + qRight := by rw [‚Üê add_assoc]
      _ ‚â§ Œº := hpacked_as
  have htVert_nonneg : 0 ‚â§ tVert := by
    simpa [tVert] using hvertical_nonneg
  have hdrop : qCore ‚â§ Œº ‚àß ((qCore : EReal) ‚â§ (Œº : EReal)) :=
    helperForCorollary_19_1_2_objective_dropVertical_le
      (qCore := qCore) (tVert := tVert) (Œº := Œº)
      hqCore_plus_tVert htVert_nonneg
  simpa [qCore, qLeft, qRight] using hdrop

/-- Helper for Corollary 19.1.2: if the packed objective equals `Œº` and the vertical singleton
coefficient is nonnegative, then the decoded original objective is at most `Œº` both in `‚Ñù` and,
after coercion, in `EReal`. -/
lemma helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1))) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) ‚àß
      (((((‚àë i : Fin k, aFix i * Œ±Left i) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§
          (Œº : EReal)) := by
  have hpacked_le :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) ‚â§ Œº := by
    simpa [hpacked_eq]
  exact
    helperForCorollary_19_1_2_originalObjective_le_of_packedObjective_le
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_le hvertical_nonneg

/-- Helper for Corollary 19.1.2: nonnegativity of all packed right-block coefficients yields
both nonnegativity of the distinguished vertical singleton and nonnegativity of every shifted
right-block coefficient. -/
lemma helperForCorollary_19_1_2_verticalAndRightBlock_nonneg_of_allPackedNonneg
    {k m : ‚Ñï}
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1)) ‚àß
      (‚àÄ j : Fin (m - k), 0 ‚â§ bFix (Fin.natAdd 1 j)) := by
  refine ‚ü®?_, ?_‚ü©
  ¬∑ exact hpacked_nonneg (Fin.castAdd (m - k) (0 : Fin 1))
  ¬∑ intro j
    exact hpacked_nonneg (Fin.natAdd 1 j)

/-- Helper for Corollary 19.1.2: if all packed right-block coefficients are nonnegative,
then the distinguished vertical singleton coefficient is nonnegative. -/
lemma helperForCorollary_19_1_2_verticalSingleton_nonneg_of_allPackedNonneg
    {k m : ‚Ñï}
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1)) := by
  exact
    (helperForCorollary_19_1_2_verticalAndRightBlock_nonneg_of_allPackedNonneg
      (k := k) (m := m) (bFix := bFix) hpacked_nonneg).1

/-- Helper for Corollary 19.1.2: a packed objective equality together with nonnegativity of
all packed right-block coefficients yields the decoded original-objective bounds in `‚Ñù` and
`EReal`. -/
lemma helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq_of_allPackedNonneg
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) ‚àß
      (((((‚àë i : Fin k, aFix i * Œ±Left i) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§
          (Œº : EReal)) := by
  have hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1)) :=
    helperForCorollary_19_1_2_verticalSingleton_nonneg_of_allPackedNonneg
      (bFix := bFix) hpacked_nonneg
  exact
    helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hvertical_nonneg

/-- Helper for Corollary 19.1.2: if the packed objective equals `Œº` and all packed
right-block coefficients are nonnegative, then the decoded original objective is at most `Œº`
in `‚Ñù`. -/
lemma helperForCorollary_19_1_2_originalObjective_le_of_packedObjective_eq_of_allPackedNonneg
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) := by
  exact
    (helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq_of_allPackedNonneg
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hpacked_nonneg).1

/-- Helper for Corollary 19.1.2: if the packed objective equals `Œº` and all packed right-block
coefficients are nonnegative, then the decoded original objective is at most `Œº` after coercion
to `EReal`. -/
lemma helperForCorollary_19_1_2_originalObjective_leEReal_of_packedObjective_eq_of_allPackedNonneg
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    (((((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§ (Œº : EReal)) := by
  exact
    (helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq_of_allPackedNonneg
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hpacked_nonneg).2

/-- Helper for Corollary 19.1.2: transporting a packed decoded objective equality and
nonnegative vertical singleton coefficient yields the decoded original-objective bound in
both `‚Ñù` and `EReal`. -/
lemma helperForCorollary_19_1_2_transport_originalCoeffs_of_packedDecode
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1))) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) ‚àß
      (((((‚àë i : Fin k, aFix i * Œ±Left i) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§
          (Œº : EReal)) := by
  exact
    helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hvertical_nonneg

/-- Helper for Corollary 19.1.2: transporting a packed decoded objective equality together
with nonnegativity of all packed right-block coefficients yields the decoded original-objective
bound in both `‚Ñù` and `EReal`. -/
lemma helperForCorollary_19_1_2_transport_originalCoeffs_of_packedDecode_of_allPackedNonneg
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) ‚àß
      (((((‚àë i : Fin k, aFix i * Œ±Left i) +
        (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§
          (Œº : EReal)) := by
  have hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1)) :=
    helperForCorollary_19_1_2_verticalSingleton_nonneg_of_allPackedNonneg
      (bFix := bFix) hpacked_nonneg
  exact
    helperForCorollary_19_1_2_transport_originalCoeffs_of_packedDecode
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hvertical_nonneg

/-- Helper for Corollary 19.1.2: transporting packed decoded objective data together
with nonnegativity of all packed right-block coefficients yields the decoded original-objective
bound in `‚Ñù`. -/
lemma helperForCorollary_19_1_2_transport_originalCoeffs_le_of_packedDecode_of_allPackedNonneg
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) := by
  exact
    (helperForCorollary_19_1_2_transport_originalCoeffs_of_packedDecode_of_allPackedNonneg
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hpacked_nonneg).1

/-- Helper for Corollary 19.1.2: transporting packed decoded objective data together
with nonnegativity of all packed right-block coefficients yields the decoded original-objective
bound after coercion to `EReal`. -/
lemma helperForCorollary_19_1_2_transport_originalCoeffs_leEReal_of_packedDecode_of_allPackedNonneg
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hpacked_nonneg : ‚àÄ i : Fin (1 + (m - k)), 0 ‚â§ bFix i) :
    (((((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§
        (Œº : EReal)) := by
  exact
    (helperForCorollary_19_1_2_transport_originalCoeffs_of_packedDecode_of_allPackedNonneg
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hpacked_nonneg).2

/-- Helper for Corollary 19.1.2: if the packed objective equals `Œº` and the vertical singleton
coefficient is nonnegative, then the decoded original objective is at most `Œº` in `‚Ñù`. -/
lemma helperForCorollary_19_1_2_originalObjective_le_of_packedObjective_eq
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1))) :
    ((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j) ‚â§ Œº) := by
  exact
    (helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hvertical_nonneg).1

/-- Helper for Corollary 19.1.2: if the packed objective equals `Œº` and the vertical singleton
coefficient is nonnegative, then the decoded original objective is at most `Œº` after coercion to
`EReal`. -/
lemma helperForCorollary_19_1_2_originalObjective_leEReal_of_packedObjective_eq
    {k m : ‚Ñï}
    (aFix : Fin k ‚Üí ‚Ñù)
    (bFix : Fin (1 + (m - k)) ‚Üí ‚Ñù)
    (Œ±Left : Fin k ‚Üí ‚Ñù)
    (Œ±Right : Fin (m - k) ‚Üí ‚Ñù)
    {Œº : ‚Ñù}
    (hpacked_eq :
      (‚àë i : Fin (k + (1 + (m - k))),
        (Fin.append aFix bFix i) *
          (Fin.append Œ±Left (Fin.append (fun _ : Fin 1 => (1 : ‚Ñù)) Œ±Right) i)) = Œº)
    (hvertical_nonneg : 0 ‚â§ bFix (Fin.castAdd (m - k) (0 : Fin 1))) :
    (((((‚àë i : Fin k, aFix i * Œ±Left i) +
      (‚àë j : Fin (m - k), bFix (Fin.natAdd 1 j) * Œ±Right j)) : ‚Ñù) : EReal) ‚â§ (Œº : EReal)) := by
  exact
    (helperForCorollary_19_1_2_originalObjective_le_pair_of_packedObjective_eq
      (aFix := aFix) (bFix := bFix) (Œ±Left := Œ±Left) (Œ±Right := Œ±Right)
      (Œº := Œº) hpacked_eq hvertical_nonneg).2


end Section19
end Chap19
