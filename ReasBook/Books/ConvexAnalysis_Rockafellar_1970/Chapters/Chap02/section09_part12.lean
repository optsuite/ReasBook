import Mathlib
import ConvexAnalysis_Rockafellar_1970.Chapters.Chap02.section09_part11

noncomputable section
open scoped Pointwise
open scoped BigOperators
open scoped Topology
open scoped RealInnerProductSpace
open Filter

section Chap02
section Section09
set_option maxHeartbeats 800000 in
/-- Theorem 9.7. Let `f` be a closed proper convex function on `â„^n` with `f(0) > 0`,
and let `k` be the positively homogeneous convex function generated by `f`. Then `k` is
proper and `(convexFunctionClosure k)(x)` is the infimum of `(f Î»)(x)` over `Î» > 0`
together with `Î» = 0^+` (encoded here as `f0_plus`), the infimum being attained for each
`x`. If `0 âˆˆ dom f`, then `k` is closed and the `Î» = 0^+` term can be omitted
(but the infimum might not be attained). -/
theorem closure_posHomogeneousGenerated_infimum_rightScalarMultiple {n : Nat}
    {f f0_plus : (Fin n â†’ Real) â†’ EReal}
    (hfclosed : ClosedConvexFunction f)
    (hfproper : ProperConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) f)
    (hf0 : f (0 : Fin n â†’ Real) > (0 : EReal))
    (hrec :
      Set.recessionCone (epigraph (Set.univ : Set (Fin n â†’ Real)) f) =
        epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus) :
    let k := positivelyHomogeneousConvexFunctionGenerated f
    (ProperConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) k) âˆ§
      (âˆ€ x : Fin n â†’ Real,
        convexFunctionClosure k x =
          sInf
            (Set.insert (f0_plus x)
              { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x })) âˆ§
      (âˆ€ x : Fin n â†’ Real,
        âˆƒ z âˆˆ
            Set.insert (f0_plus x)
              { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x },
          convexFunctionClosure k x = z) âˆ§
      ((0 : Fin n â†’ Real) âˆˆ effectiveDomain (Set.univ : Set (Fin n â†’ Real)) f â†’
        ClosedConvexFunction k âˆ§
          (âˆ€ x : Fin n â†’ Real,
            k x =
              sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x })) := by
  classical
  -- Unfold the `let`-binding to work with `k`.
  dsimp
  set k := positivelyHomogeneousConvexFunctionGenerated f with hk
  have hfconv : ConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) f := hfproper.1
  have hfinite : âˆƒ x, f x â‰  (âŠ¤ : EReal) := by
    rcases hfproper.2.1 with âŸ¨âŸ¨x, Î¼âŸ©, hxâŸ©
    have hle : f x â‰¤ (Î¼ : EReal) := (mem_epigraph_univ_iff (f := f)).1 hx
    refine âŸ¨x, ?_âŸ©
    intro htop
    have hle' : False := by
      refine (not_top_le_coe (r := Î¼) ?_)
      rw [â† htop]
      exact hle
    exact hle'
  have hk_formula :
      âˆ€ x : Fin n â†’ Real,
        k x = sInf { z : EReal | âˆƒ lam : Real, 0 â‰¤ lam âˆ§ z = rightScalarMultiple f lam x } := by
    rw [hk]
    exact (infimumRepresentation_posHomogeneousHull (h := f) hfconv hfinite).1
  set C : Set (Fin (n + 1) â†’ Real) :=
    (prodLinearEquiv_append_coord (n := n)) '' epigraph (Set.univ : Set (Fin n â†’ Real)) f
  have hCne : Set.Nonempty C := by
    rcases hfproper.2.1 with âŸ¨p, hpâŸ©
    exact âŸ¨(prodLinearEquiv_append_coord (n := n)) p, âŸ¨p, hp, rflâŸ©âŸ©
  have hCclosed : IsClosed C := by
    have hclosed_sub :
        âˆ€ Î± : Real, IsClosed {x : Fin n â†’ Real | f x â‰¤ (Î± : EReal)} :=
      (lowerSemicontinuous_iff_closed_sublevel_iff_closed_epigraph (f := f)).1.mp hfclosed.2
    have hclosed_epi :
        IsClosed (epigraph (Set.univ : Set (Fin n â†’ Real)) f) :=
      (lowerSemicontinuous_iff_closed_sublevel_iff_closed_epigraph (f := f)).2.mp hclosed_sub
    let hhome := (prodLinearEquiv_append_coord (n := n)).toAffineEquiv.toHomeomorphOfFiniteDimensional
    have hclosed' :
        IsClosed ((hhome : _ â†’ _) '' epigraph (Set.univ : Set (Fin n â†’ Real)) f) :=
      (hhome.isClosed_image (s := epigraph (Set.univ : Set (Fin n â†’ Real)) f)).2 hclosed_epi
    simpa [C, hhome, AffineEquiv.coe_toHomeomorphOfFiniteDimensional] using hclosed'
  have hCconv : Convex Real C := by
    have hconv_epi :
        Convex Real (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
      simpa [ConvexFunction] using
        (convex_epigraph_of_convexFunctionOn (f := f) (hf := hfconv))
    simpa [C] using hconv_epi.linear_image (prodLinearEquiv_append_coord (n := n)).toLinearMap
  have hC0 : (0 : Fin (n + 1) â†’ Real) âˆ‰ C := by
    intro h0
    rcases h0 with âŸ¨p, hp, hp0âŸ©
    have hp0' : p = 0 := by
      apply (prodLinearEquiv_append_coord (n := n)).injective
      simpa using hp0
    subst hp0'
    have hle : f (0 : Fin n â†’ Real) â‰¤ (0 : EReal) := by
      simpa using (mem_epigraph_univ_iff (f := f)).1 hp
    exact (not_lt_of_ge hle) hf0
  have hclosure_union :
      closure (convexConeGenerated (n + 1) C) =
        (â‹ƒ (lam : Real) (_ : 0 < lam),
          (prodLinearEquiv_append_coord (n := n)) ''
            epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f lam)) âˆª
        (prodLinearEquiv_append_coord (n := n)) '' epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
    simpa [C] using
      (closure_convexConeGenerated_embedded_epigraph_eq_union
        (n := n) (f := f) (f0_plus := f0_plus) hfconv hrec hCne hCclosed hCconv hC0)
  have hcone_img :
      (prodLinearEquiv_append_coord (n := n)) '' convexConeGeneratedEpigraph f =
        convexConeGenerated (n + 1) C := by
    simpa [C] using
      (convexConeGenerated_embedded_epigraph_eq_image_convexConeGeneratedEpigraph
        (n := n) (f := f) hfconv)
  have hclosure_union' :
      closure ((prodLinearEquiv_append_coord (n := n)) '' convexConeGeneratedEpigraph f) =
        (â‹ƒ (lam : Real) (_ : 0 < lam),
          (prodLinearEquiv_append_coord (n := n)) ''
            epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f lam)) âˆª
        (prodLinearEquiv_append_coord (n := n)) '' epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
    calc
      closure ((prodLinearEquiv_append_coord (n := n)) '' convexConeGeneratedEpigraph f) =
          closure (convexConeGenerated (n + 1) C) := by
        simp [hcone_img]
      _ = _ := hclosure_union
  -- The generated cone sits inside the epigraph of `k`.
  have hcone_subset :
      convexConeGeneratedEpigraph f âŠ†
        epigraph (Set.univ : Set (Fin n â†’ Real)) k := by
    rw [hk]
    exact (convexConeGeneratedEpigraph_subset_epigraph_posHom (f := f))
  have hclosure_cone_subset :
      closure ((prodLinearEquiv_append_coord (n := n)) '' convexConeGeneratedEpigraph f) âŠ†
        closure ((prodLinearEquiv_append_coord (n := n)) ''
          epigraph (Set.univ : Set (Fin n â†’ Real)) k) := by
    have hsubset :
        (prodLinearEquiv_append_coord (n := n)) '' convexConeGeneratedEpigraph f âŠ†
          (prodLinearEquiv_append_coord (n := n)) ''
            epigraph (Set.univ : Set (Fin n â†’ Real)) k := by
      intro y hy
      rcases hy with âŸ¨p, hp, rflâŸ©
      exact âŸ¨p, hcone_subset hp, rflâŸ©
    exact closure_mono hsubset
  have hclosure_union'' :
      closure (convexConeGeneratedEpigraph f) =
        (â‹ƒ (lam : Real) (_ : 0 < lam),
          epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f lam)) âˆª
        epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
    exact
      closure_convexConeGeneratedEpigraph_eq_union
        (n := n) (f := f) (f0_plus := f0_plus) hclosure_union'
  have hk_conv_ne :
      ConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) k âˆ§
        Set.Nonempty (epigraph (Set.univ : Set (Fin n â†’ Real)) k) := by
    rw [hk]
    exact (posHomGenerated_convex_and_nonempty (n := n) (f := f) hfconv)
  have hk_conv : ConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) k := hk_conv_ne.1
  have hk_ne_epi : Set.Nonempty (epigraph (Set.univ : Set (Fin n â†’ Real)) k) := hk_conv_ne.2
  -- The epigraph of `k` sits in the closed cone generated by the epigraph of `f`.
  have h_epi_subset :
      epigraph (Set.univ : Set (Fin n â†’ Real)) k âŠ†
        closure (convexConeGeneratedEpigraph f) := by
    intro p hp
    rcases p with âŸ¨x, Î¼âŸ©
    have hle : k x â‰¤ (Î¼ : EReal) := (mem_epigraph_univ_iff (f := k)).1 hp
    -- First handle the strict inequality case via the `sInf` formula.
    by_cases hlt : k x < (Î¼ : EReal)
    Â· set S0 : Set EReal :=
        { z : EReal | âˆƒ lam : Real, 0 â‰¤ lam âˆ§ z = rightScalarMultiple f lam x }
      have hlt' : sInf S0 < (Î¼ : EReal) := by
        simpa [hk_formula x, S0] using hlt
      rcases (sInf_lt_iff).1 hlt' with âŸ¨z, hzS0, hzltâŸ©
      rcases hzS0 with âŸ¨lam, hlam, rflâŸ©
      have hmem_union :
          (x, Î¼) âˆˆ
              (â‹ƒ (t : Real) (_ : 0 < t),
                epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
        by_cases hpos : 0 < lam
        Â· have hle' : rightScalarMultiple f lam x â‰¤ (Î¼ : EReal) :=
            le_of_lt hzlt
          have hmem :
              (x, Î¼) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real))
                (rightScalarMultiple f lam) :=
            (mem_epigraph_univ_iff (f := rightScalarMultiple f lam)).2 hle'
          refine Or.inl ?_
          refine Set.mem_iUnion.2 âŸ¨lam, ?_âŸ©
          refine Set.mem_iUnion.2 âŸ¨hpos, ?_âŸ©
          exact hmem
        Â· have hlam0 : lam = 0 := le_antisymm (le_of_not_gt hpos) hlam
          subst hlam0
          have hne_epi :
              Set.Nonempty (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := hfproper.2.1
          have hval :=
            rightScalarMultiple_zero_eval (f := f) hne_epi x
          by_cases hx0 : x = 0
          Â· subst hx0
            have hÎ¼pos : (0 : EReal) < (Î¼ : EReal) := by
              simpa [hval] using hzlt
            have hzero :
                ((0 : Fin n â†’ Real), (0 : Real)) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              have h0mem :
                  (0 : (Fin n â†’ Real) Ã— Real) âˆˆ
                    Set.recessionCone
                      (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                intro y hy t ht
                simpa using hy
              simpa [hrec] using h0mem
            have hle0 :
                f0_plus (0 : Fin n â†’ Real) â‰¤ (0 : EReal) :=
              (mem_epigraph_univ_iff (f := f0_plus)).1 hzero
            have hleÎ¼ : f0_plus (0 : Fin n â†’ Real) â‰¤ (Î¼ : EReal) :=
              le_trans hle0 (le_of_lt hÎ¼pos)
            have hmem :
                ((0 : Fin n â†’ Real), Î¼) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus :=
              (mem_epigraph_univ_iff (f := f0_plus)).2 hleÎ¼
            exact Or.inr hmem
          Â· have htop := hval
            simp [hx0] at htop
            have hnot : Â¬ rightScalarMultiple f 0 x < (Î¼ : EReal) := by
              simp [htop]
            exact (hnot hzlt).elim
      have hmem_closure :
          (x, Î¼) âˆˆ closure (convexConeGeneratedEpigraph f) := by
        rw [hclosure_union'']
        exact hmem_union
      exact hmem_closure
    Â· -- Equality case: approximate by a decreasing sequence from above.
      have hEq : k x = (Î¼ : EReal) := by
        exact le_antisymm hle (not_lt.mp hlt)
      have hclosed : IsClosed (closure (convexConeGeneratedEpigraph f)) := isClosed_closure
      have hmem_seq :
          âˆ€ m : â„•,
            (x, Î¼ + (1 : Real) / (m + 1)) âˆˆ closure (convexConeGeneratedEpigraph f) := by
        intro m
        have hlt' :
            k x < ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) := by
          have hpos :
              (0 : Real) < (1 : Real) / (m + 1) := by
            have : 0 < (m + 1 : Real) := by
              exact_mod_cast (Nat.succ_pos m)
            exact one_div_pos.mpr this
          have hpos' : (Î¼ : EReal) < ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) := by
            have hpos'' : (Î¼ : Real) < Î¼ + (1 : Real) / (m + 1) := by linarith
            exact (EReal.coe_lt_coe_iff).2 hpos''
          simpa [hEq] using hpos'
        have hmem' : (x, Î¼ + (1 : Real) / (m + 1)) âˆˆ
            closure (convexConeGeneratedEpigraph f) := by
          -- apply the strict case to `Î¼ + 1/(n+1)`
          have hle' :
              k x â‰¤ ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) :=
            le_of_lt hlt'
          have hmem_epi :
              (x, Î¼ + (1 : Real) / (m + 1)) âˆˆ
                epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
            (mem_epigraph_univ_iff (f := k)).2 hle'
          -- reuse the strict-case proof by calling it directly
          have hmem'' :
              (x, Î¼ + (1 : Real) / (m + 1)) âˆˆ
                closure (convexConeGeneratedEpigraph f) := by
              -- re-run the strict case using the same argument as above
              -- with `Î¼ + 1/(n+1)` in place of `Î¼`.
              have : k x < ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) := hlt'
              -- short-circuit by reusing the earlier branch
              -- (the proof above is not packaged as a lemma, so we redo a small part)
              set S0 : Set EReal :=
                { z : EReal | âˆƒ lam : Real, 0 â‰¤ lam âˆ§ z = rightScalarMultiple f lam x }
              have hlt'' : sInf S0 < ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) := by
                simpa [hk_formula x, S0] using hlt'
              rcases (sInf_lt_iff).1 hlt'' with âŸ¨z, hzS0, hzltâŸ©
              rcases hzS0 with âŸ¨lam, hlam, rflâŸ©
              have hmem_union :
                  (x, Î¼ + (1 : Real) / (m + 1)) âˆˆ
                      (â‹ƒ (t : Real) (_ : 0 < t),
                        epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                        epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                by_cases hpos : 0 < lam
                Â· have hle' :
                    rightScalarMultiple f lam x â‰¤
                      ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) :=
                    le_of_lt hzlt
                  have hmem :
                      (x, Î¼ + (1 : Real) / (m + 1)) âˆˆ
                        epigraph (Set.univ : Set (Fin n â†’ Real))
                          (rightScalarMultiple f lam) :=
                    (mem_epigraph_univ_iff (f := rightScalarMultiple f lam)).2 hle'
                  refine Or.inl ?_
                  refine Set.mem_iUnion.2 âŸ¨lam, ?_âŸ©
                  refine Set.mem_iUnion.2 âŸ¨hpos, ?_âŸ©
                  exact hmem
                Â· have hlam0 : lam = 0 := le_antisymm (le_of_not_gt hpos) hlam
                  subst hlam0
                  have hne_epi :
                      Set.Nonempty (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := hfproper.2.1
                  have hval :=
                    rightScalarMultiple_zero_eval (f := f) hne_epi x
                  by_cases hx0 : x = 0
                  Â· subst hx0
                    have hÎ¼pos :
                        (0 : EReal) <
                          ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) := by
                      simpa [hval] using hzlt
                    have hzero :
                        ((0 : Fin n â†’ Real), (0 : Real)) âˆˆ
                          epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                      have h0mem :
                          (0 : (Fin n â†’ Real) Ã— Real) âˆˆ
                            Set.recessionCone
                              (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                        intro y hy t ht
                        simpa using hy
                      simpa [hrec] using h0mem
                    have hle0 :
                        f0_plus (0 : Fin n â†’ Real) â‰¤ (0 : EReal) :=
                      (mem_epigraph_univ_iff (f := f0_plus)).1 hzero
                    have hleÎ¼ :
                        f0_plus (0 : Fin n â†’ Real) â‰¤
                          ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) :=
                      le_trans hle0 (le_of_lt hÎ¼pos)
                    have hmem :
                        ((0 : Fin n â†’ Real), Î¼ + (1 : Real) / (m + 1)) âˆˆ
                          epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus :=
                      (mem_epigraph_univ_iff (f := f0_plus)).2 hleÎ¼
                    exact Or.inr hmem
                  Â· have htop := hval
                    simp [hx0] at htop
                    have : Â¬ (rightScalarMultiple f 0 x) <
                        ((Î¼ + (1 : Real) / (m + 1) : Real) : EReal) := by
                      simp [htop]
                    exact (this hzlt).elim
              simpa [hclosure_union''] using hmem_union
          exact hmem''
        exact hmem'
      have hlim :
          Filter.Tendsto
            (fun n : â„• => (x, Î¼ + (1 : Real) / (n + 1))) Filter.atTop (ğ“ (x, Î¼)) := by
        have h1 :
            Filter.Tendsto (fun _ : â„• => x) Filter.atTop (ğ“ x) :=
          tendsto_const_nhds
        have h2' :
            Filter.Tendsto (fun n : â„• => (1 : Real) / (n + 1)) Filter.atTop
              (ğ“ (0 : Real)) :=
          tendsto_one_div_add_atTop_nhds_zero_nat
        have h2 :
            Filter.Tendsto
              (fun n : â„• => Î¼ + (1 : Real) / (n + 1)) Filter.atTop (ğ“ Î¼) := by
          simpa using (tendsto_const_nhds.add h2')
        exact Filter.Tendsto.prodMk_nhds h1 h2
      exact hclosed.mem_of_tendsto hlim (eventually_of_forall hmem_seq)
  have hkproper : ProperConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) k := by
    refine âŸ¨hk_conv, hk_ne_epi, ?_âŸ©
    intro x hx hbot
    -- Use the closed cone description to rule out `k x = âŠ¥`.
    have hxbot : k x = (âŠ¥ : EReal) := hbot
    have hmem_epi : (x, (-1 : Real)) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) k := by
      have hle : k x â‰¤ ((-1 : Real) : EReal) := by
        simp [hxbot]
      exact (mem_epigraph_univ_iff (f := k)).2 hle
    have hmem_closure : (x, (-1 : Real)) âˆˆ closure (convexConeGeneratedEpigraph f) :=
      h_epi_subset hmem_epi
    -- Scaling the vertical line gives a negative vertical at the origin.
    have hmem_union :
        (x, (-1 : Real)) âˆˆ
            (â‹ƒ (t : Real) (_ : 0 < t),
              epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
            epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
      rw [hclosure_union''] at hmem_closure
      exact hmem_closure
    have hclosed_union :
        IsClosed
          ((â‹ƒ (t : Real) (_ : 0 < t),
            epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
            epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus) := by
      simpa [hclosure_union''] using
        (isClosed_closure (s := convexConeGeneratedEpigraph f))
    -- For any `t > 0`, the point `(t â€¢ x, -1)` lies in the union.
    have hmem_scaled :
        âˆ€ t : Real, 0 < t â†’
          (t â€¢ x, (-1 : Real)) âˆˆ
            (â‹ƒ (s : Real) (_ : 0 < s),
              epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f s)) âˆª
            epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
      intro t ht
      -- the union is a cone, so scale `(x, -1/t)`
      have hmem_vert :
          (x, (-1 : Real) / t) âˆˆ
            (â‹ƒ (s : Real) (_ : 0 < s),
              epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f s)) âˆª
            epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
        have hle : k x â‰¤ ((-1 : Real) / t : EReal) := by
          have hbot' : k x = (âŠ¥ : EReal) := hxbot
          simp [hbot']
        have hmem_epi :
            (x, (-1 : Real) / t) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
          (mem_epigraph_univ_iff (f := k)).2 hle
        have hmem_closure' := h_epi_subset hmem_epi
        rw [hclosure_union''] at hmem_closure'
        exact hmem_closure'
      -- scale within the union
      rcases hmem_vert with hmem_vert | hmem_vert
      Â· rcases (Set.mem_iUnion).1 hmem_vert with âŸ¨s, hmem_vertâŸ©
        rcases (Set.mem_iUnion).1 hmem_vert with âŸ¨hspos, hmem_vertâŸ©
        have hle' :
            rightScalarMultiple f s x â‰¤ ((-1 : Real) / t : EReal) :=
          (mem_epigraph_univ_iff (f := rightScalarMultiple f s)).1 hmem_vert
        have hle'' :
            rightScalarMultiple f (t * s) (t â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
          -- scale the inequality
          have hmul :=
            ereal_mul_le_mul_of_pos_left_general (t := t) (ht := ht) hle'
          have hright :
              ((t : Real) : EReal) * ((-1 : Real) / t : EReal) = (-1 : EReal) := by
            have hdiv : ((-1 : Real) / t : EReal) = (tâ»Â¹ : EReal) * (-1 : EReal) := by
              simp [div_eq_mul_inv, mul_comm]
            calc
              (t : EReal) * ((-1 : Real) / t : EReal) =
                  (t : EReal) * ((tâ»Â¹ : EReal) * (-1 : EReal)) := by
                    rw [hdiv]
              _ = (-1 : EReal) := by
                    simpa using
                      (ereal_mul_inv_smul (t := t) (ht := ht) (x := (-1 : EReal)))
          have hmul' :
              ((t : Real) : EReal) * rightScalarMultiple f s x â‰¤ ((-1 : Real) : EReal) := by
            calc
              ((t : Real) : EReal) * rightScalarMultiple f s x â‰¤
                  ((t : Real) : EReal) * ((-1 : Real) / t : EReal) := hmul
              _ = (-1 : EReal) := hright
          have hspos' : 0 < t * s := mul_pos ht hspos
          have hpos_ts :=
            rightScalarMultiple_pos (f := f) (lam := t * s) hfconv hspos' (t â€¢ x)
          have hpos_s :=
            rightScalarMultiple_pos (f := f) (lam := s) hfconv hspos x
          have hsmul : (t * s)â»Â¹ â€¢ (t â€¢ x) = sâ»Â¹ â€¢ x := by
            have ht0 : t â‰  0 := ne_of_gt ht
            have hs0 : s â‰  0 := ne_of_gt hspos
            have hscale : (t * s)â»Â¹ * t = sâ»Â¹ := by
              field_simp [ht0, hs0]
            calc
              (t * s)â»Â¹ â€¢ (t â€¢ x) = ((t * s)â»Â¹ * t) â€¢ x := by
                rw [smul_smul]
              _ = sâ»Â¹ â€¢ x := by
                rw [hscale]
          have hsmul' : (sâ»Â¹ * tâ»Â¹) â€¢ t â€¢ x = sâ»Â¹ â€¢ x := by
            have ht0 : t â‰  0 := ne_of_gt ht
            calc
              (sâ»Â¹ * tâ»Â¹) â€¢ t â€¢ x = ((sâ»Â¹ * tâ»Â¹) * t) â€¢ x := by
                rw [smul_smul]
              _ = sâ»Â¹ â€¢ x := by
                simp [ht0]
          have hmul1 :
              ((t * s : Real) : EReal) * f (sâ»Â¹ â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
            have hmul1' :
                ((t : EReal) * ((s : EReal) * f (sâ»Â¹ â€¢ x))) â‰¤ ((-1 : Real) : EReal) := by
              simpa [hpos_s, mul_assoc] using hmul'
            simpa [mul_comm, mul_left_comm, mul_assoc, EReal.coe_mul] using hmul1'
          have hmul2 :
              ((t * s : Real) : EReal) * f ((t * s)â»Â¹ â€¢ (t â€¢ x)) â‰¤ ((-1 : Real) : EReal) := by
            simpa [hsmul'] using hmul1
          rw [hpos_ts]
          exact hmul2
        have hmem' :
            (t â€¢ x, (-1 : Real)) âˆˆ
              epigraph (Set.univ : Set (Fin n â†’ Real))
                (rightScalarMultiple f (t * s)) :=
          (mem_epigraph_univ_iff (f := rightScalarMultiple f (t * s))).2 hle''
        refine Or.inl ?_
        refine Set.mem_iUnion.2 âŸ¨t * s, ?_âŸ©
        refine Set.mem_iUnion.2 âŸ¨mul_pos ht hspos, ?_âŸ©
        exact hmem'
      Â· -- scaling a recession direction stays in the recession cone
        have hmem' :
            (t â€¢ x, (-1 : Real)) âˆˆ
              epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
          have hle' : f0_plus x â‰¤ ((-1 : Real) / t : EReal) :=
            (mem_epigraph_univ_iff (f := f0_plus)).1 hmem_vert
          have hle'' :=
            ereal_mul_le_mul_of_pos_left_general (t := t) (ht := ht) hle'
          have hne : (t : Real) â‰  0 := ne_of_gt ht
          have hle''' : f0_plus (t â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
            -- use that epigraph of `f0_plus` is a cone
            have hrec' :
                (x, (-1 : Real) / t) âˆˆ
                  Set.recessionCone
                    (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
              simpa [hrec] using hmem_vert
            have hrec'' :
                (t â€¢ x, (-1 : Real)) âˆˆ
                  Set.recessionCone
                    (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
              intro y hy s hs
              have hrec_mem := hrec' (x := y) hy (t := s * t) (by nlinarith)
              have ht0 : t â‰  0 := ne_of_gt ht
              have hmul : s * (t * (-1 / t)) = -s := by
                field_simp [ht0, mul_comm, mul_left_comm, mul_assoc]
              simpa [smul_smul, mul_assoc, hmul] using hrec_mem
            have hmem' :
                (t â€¢ x, (-1 : Real)) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              simpa [hrec] using hrec''
            exact (mem_epigraph_univ_iff (f := f0_plus)).1 hmem'
          exact (mem_epigraph_univ_iff (f := f0_plus)).2 hle'''
        exact Or.inr hmem'
    have hmem_limit :
        ((0 : Fin n â†’ Real), (-1 : Real)) âˆˆ
          (â‹ƒ (t : Real) (_ : 0 < t),
            epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
          epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
      have hmem_seq :
          âˆ€ m : â„•,
            (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
              (â‹ƒ (t : Real) (_ : 0 < t),
                epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
              epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
        intro m
        have hpos : 0 < (1 : Real) / (m + 1) := by
          have : 0 < (m + 1 : Real) := by
            exact_mod_cast (Nat.succ_pos m)
          exact one_div_pos.mpr this
        simpa using (hmem_scaled ((1 : Real) / (m + 1)) hpos)
      have hlim :
          Filter.Tendsto
            (fun n : â„• => (((1 : Real) / (n + 1)) â€¢ x, (-1 : Real))) Filter.atTop
              (ğ“ ((0 : Fin n â†’ Real), (-1 : Real))) := by
        have h1 :
            Filter.Tendsto
              (fun n : â„• => (1 : Real) / (n + 1)) Filter.atTop (ğ“ (0 : Real)) :=
          tendsto_one_div_add_atTop_nhds_zero_nat
        have h1' :
            Filter.Tendsto (fun n : â„• => ((1 : Real) / (n + 1)) â€¢ x) Filter.atTop
              (ğ“ (0 : Fin n â†’ Real)) := by
          have h1' :=
            h1.smul
              (tendsto_const_nhds :
                Filter.Tendsto (fun _ : â„• => x) Filter.atTop (ğ“ x))
          have hzero : (0 : Real) â€¢ x = (0 : Fin n â†’ Real) := by
            simp
          simpa [hzero] using h1'
        have h2 : Filter.Tendsto (fun _ : â„• => (-1 : Real)) Filter.atTop (ğ“ (-1 : Real)) :=
          tendsto_const_nhds
        exact Filter.Tendsto.prodMk_nhds h1' h2
      exact hclosed_union.mem_of_tendsto hlim (eventually_of_forall hmem_seq)
    -- show that the union cannot contain negative verticals
    have hneg_not :
        ((0 : Fin n â†’ Real), (-1 : Real)) âˆ‰
          (â‹ƒ (t : Real) (_ : 0 < t),
            epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
          epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
      intro hmem
      rcases hmem with hmem | hmem
      Â· rcases (Set.mem_iUnion).1 hmem with âŸ¨t, hmemâŸ©
        rcases (Set.mem_iUnion).1 hmem with âŸ¨ht, hmemâŸ©
        have hle :
            rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal) :=
          (mem_epigraph_univ_iff (f := rightScalarMultiple f t)).1 hmem
        have hpos0 : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
          have hpos' : (0 : EReal) < (t : EReal) := by
            simpa using (EReal.coe_lt_coe_iff).2 ht
          have hpos0' : (0 : EReal) < f (0 : Fin n â†’ Real) := hf0
          have hright :=
            rightScalarMultiple_pos (f := f) (lam := t) hfconv ht (0 : Fin n â†’ Real)
          have hmul : (0 : EReal) < (t : EReal) * f (0 : Fin n â†’ Real) :=
            EReal.mul_pos hpos' hpos0'
          simp [hright, hmul]
        have hnot : Â¬ (rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal)) := by
          have hlt : ((-1 : Real) : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) :=
            lt_trans (by simp) hpos0
          exact not_le_of_gt hlt
        exact hnot hle
      Â· have hmem' :
            (0, (-1 : Real)) âˆˆ
              Set.recessionCone
                (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
          simpa [hrec] using hmem
        exact (no_neg_vertical_recession_epigraph (f := f) hfproper (Î¼ := (-1 : Real)) (by norm_num))
          hmem'
    exact (hneg_not hmem_limit).elim
  refine And.intro hkproper ?_
  Â·
    have hcl_formula :
        âˆ€ x : Fin n â†’ Real,
          convexFunctionClosure k x =
            sInf
              (Set.insert (f0_plus x)
                { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x }) := by
      intro x
      -- TODO: identify attaching closure with `convexFunctionClosure k`.
      -- identify the closed cone with the epigraph of `convexFunctionClosure k`
      have hnotbot : âˆ€ x : Fin n â†’ Real, k x â‰  (âŠ¥ : EReal) := by
        intro x
        by_contra hbot
        have hproper : False := by
          have hx := hbot
          -- reuse the previous argument
          have hbot' : k x = (âŠ¥ : EReal) := hbot
          have hmem_epi : (x, (-1 : Real)) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) k := by
            have hle : k x â‰¤ ((-1 : Real) : EReal) := by
              simp [hbot']
            exact (mem_epigraph_univ_iff (f := k)).2 hle
          have hmem_closure : (x, (-1 : Real)) âˆˆ closure (convexConeGeneratedEpigraph f) :=
            h_epi_subset hmem_epi
          have hmem_union :
              (x, (-1 : Real)) âˆˆ
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
            simpa [hclosure_union''] using hmem_closure
          -- the union has no negative verticals at the origin
          have hclosed_union :
              IsClosed
                ((â‹ƒ (t : Real) (_ : 0 < t),
                  epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus) := by
            simpa [hclosure_union''] using
              (isClosed_closure (s := convexConeGeneratedEpigraph f))
          have hmem_scaled :
              âˆ€ t : Real, 0 < t â†’
                (t â€¢ x, (-1 : Real)) âˆˆ
                  (â‹ƒ (s : Real) (_ : 0 < s),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f s)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
            intro t ht
            have hmem_vert :
                (x, (-1 : Real) / t) âˆˆ
                  (â‹ƒ (s : Real) (_ : 0 < s),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f s)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              have hle : k x â‰¤ ((-1 : Real) / t : EReal) := by
                simp [hbot']
              have hmem_epi :
                  (x, (-1 : Real) / t) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
                (mem_epigraph_univ_iff (f := k)).2 hle
              have hmem_closure' := h_epi_subset hmem_epi
              simpa [hclosure_union''] using hmem_closure'
            rcases hmem_vert with hmem_vert | hmem_vert
            Â· rcases (Set.mem_iUnion).1 hmem_vert with âŸ¨s, hmem_vertâŸ©
              rcases (Set.mem_iUnion).1 hmem_vert with âŸ¨hspos, hmem_vertâŸ©
              have hle' :
                  rightScalarMultiple f s x â‰¤ ((-1 : Real) / t : EReal) :=
                (mem_epigraph_univ_iff (f := rightScalarMultiple f s)).1 hmem_vert
              have hle'' :
                  rightScalarMultiple f (t * s) (t â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
                have hmul :=
                  ereal_mul_le_mul_of_pos_left_general (t := t) (ht := ht) hle'
                have hright :
                    ((t : Real) : EReal) * ((-1 : Real) / t : EReal) = (-1 : EReal) := by
                  have hdiv : ((-1 : Real) / t : EReal) = (tâ»Â¹ : EReal) * (-1 : EReal) := by
                    simp [div_eq_mul_inv, mul_comm]
                  calc
                    (t : EReal) * ((-1 : Real) / t : EReal) =
                        (t : EReal) * ((tâ»Â¹ : EReal) * (-1 : EReal)) := by
                          rw [hdiv]
                    _ = (-1 : EReal) := by
                          simpa using
                            (ereal_mul_inv_smul (t := t) (ht := ht) (x := (-1 : EReal)))
                have hmul' :
                    ((t : Real) : EReal) * rightScalarMultiple f s x â‰¤
                      ((-1 : Real) : EReal) := by
                  calc
                    ((t : Real) : EReal) * rightScalarMultiple f s x â‰¤
                        ((t : Real) : EReal) * ((-1 : Real) / t : EReal) := hmul
                    _ = (-1 : EReal) := hright
                have hspos' : 0 < t * s := mul_pos ht hspos
                have hpos_ts :=
                  rightScalarMultiple_pos (f := f) (lam := t * s) hfconv hspos' (t â€¢ x)
                have hpos_s :=
                  rightScalarMultiple_pos (f := f) (lam := s) hfconv hspos x
                have hsmul : (t * s)â»Â¹ â€¢ (t â€¢ x) = sâ»Â¹ â€¢ x := by
                  have ht0 : t â‰  0 := ne_of_gt ht
                  have hs0 : s â‰  0 := ne_of_gt hspos
                  have hscale : (t * s)â»Â¹ * t = sâ»Â¹ := by
                    field_simp [ht0, hs0]
                  calc
                    (t * s)â»Â¹ â€¢ (t â€¢ x) = ((t * s)â»Â¹ * t) â€¢ x := by
                      rw [smul_smul]
                    _ = sâ»Â¹ â€¢ x := by
                      rw [hscale]
                have hsmul' : (sâ»Â¹ * tâ»Â¹) â€¢ t â€¢ x = sâ»Â¹ â€¢ x := by
                  have ht0 : t â‰  0 := ne_of_gt ht
                  calc
                    (sâ»Â¹ * tâ»Â¹) â€¢ t â€¢ x = ((sâ»Â¹ * tâ»Â¹) * t) â€¢ x := by
                      rw [smul_smul]
                    _ = sâ»Â¹ â€¢ x := by
                      simp [ht0]
                have hmul1 :
                    ((t * s : Real) : EReal) * f (sâ»Â¹ â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
                  have hmul1' :
                      ((t : EReal) * ((s : EReal) * f (sâ»Â¹ â€¢ x))) â‰¤ ((-1 : Real) : EReal) := by
                    simpa [hpos_s, mul_assoc] using hmul'
                  simpa [mul_comm, mul_left_comm, mul_assoc, EReal.coe_mul] using hmul1'
                have hmul2 :
                    ((t * s : Real) : EReal) * f ((t * s)â»Â¹ â€¢ (t â€¢ x)) â‰¤ ((-1 : Real) : EReal) := by
                  simpa [hsmul'] using hmul1
                rw [hpos_ts]
                exact hmul2
              have hmem' :
                  (t â€¢ x, (-1 : Real)) âˆˆ
                    epigraph (Set.univ : Set (Fin n â†’ Real))
                      (rightScalarMultiple f (t * s)) :=
                (mem_epigraph_univ_iff (f := rightScalarMultiple f (t * s))).2 hle''
              refine Or.inl ?_
              refine Set.mem_iUnion.2 âŸ¨t * s, ?_âŸ©
              refine Set.mem_iUnion.2 âŸ¨mul_pos ht hspos, ?_âŸ©
              exact hmem'
            Â· have hrec' :
                (x, (-1 : Real) / t) âˆˆ
                  Set.recessionCone
                    (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                simpa [hrec] using hmem_vert
              have hrec'' :
                  (t â€¢ x, (-1 : Real)) âˆˆ
                    Set.recessionCone
                      (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                intro y hy s hs
                have hrec_mem := hrec' (x := y) hy (t := s * t) (by nlinarith)
                have ht0 : t â‰  0 := ne_of_gt ht
                have hmul : s * (t * (-1 / t)) = -s := by
                  field_simp [ht0, mul_comm, mul_left_comm, mul_assoc]
                simpa [smul_smul, mul_assoc, hmul] using hrec_mem
              have hmem' :
                  (t â€¢ x, (-1 : Real)) âˆˆ
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                simpa [hrec] using hrec''
              exact Or.inr hmem'
          have hmem_limit :
              ((0 : Fin n â†’ Real), (-1 : Real)) âˆˆ
                (â‹ƒ (t : Real) (_ : 0 < t),
                  epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
            have hmem_seq :
                âˆ€ m : â„•,
                  (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                    (â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              intro m
              have hpos : 0 < (1 : Real) / (m + 1) := by
                have : 0 < (m + 1 : Real) := by
                  exact_mod_cast (Nat.succ_pos m)
                exact one_div_pos.mpr this
              simpa using (hmem_scaled ((1 : Real) / (m + 1)) hpos)
            have hlim :
                Filter.Tendsto
                  (fun n : â„• => (((1 : Real) / (n + 1)) â€¢ x, (-1 : Real))) Filter.atTop
                    (ğ“ ((0 : Fin n â†’ Real), (-1 : Real))) := by
              have h1 :
                  Filter.Tendsto
                    (fun n : â„• => (1 : Real) / (n + 1)) Filter.atTop (ğ“ (0 : Real)) :=
                (tendsto_one_div_add_atTop_nhds_zero_nat :
                  Filter.Tendsto (fun n : â„• => (1 : Real) / (n + 1)) Filter.atTop (ğ“ (0 : Real)))
              have h1' :
                  Filter.Tendsto (fun n : â„• => ((1 : Real) / (n + 1)) â€¢ x) Filter.atTop
                    (ğ“ (0 : Fin n â†’ Real)) := by
                have h1' :=
                  h1.smul
                    (tendsto_const_nhds :
                      Filter.Tendsto (fun _ : â„• => x) Filter.atTop (ğ“ x))
                have hzero : (0 : Real) â€¢ x = (0 : Fin n â†’ Real) := by
                  simp
                simpa [hzero] using h1'
              have h2 :
                  Filter.Tendsto (fun _ : â„• => (-1 : Real)) Filter.atTop (ğ“ (-1 : Real)) :=
                tendsto_const_nhds
              exact Filter.Tendsto.prodMk_nhds h1' h2
            exact hclosed_union.mem_of_tendsto hlim (eventually_of_forall hmem_seq)
          -- show the union has no negative verticals
          have hneg_not :
              ((0 : Fin n â†’ Real), (-1 : Real)) âˆ‰
                (â‹ƒ (t : Real) (_ : 0 < t),
                  epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
            intro hmem
            rcases hmem with hmem | hmem
            Â· rcases (Set.mem_iUnion).1 hmem with âŸ¨t, hmemâŸ©
              rcases (Set.mem_iUnion).1 hmem with âŸ¨ht, hmemâŸ©
              have hle :
                  rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal) :=
                (mem_epigraph_univ_iff (f := rightScalarMultiple f t)).1 hmem
              have hpos0 : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
                have hpos' : (0 : EReal) < (t : EReal) := by
                  simpa using (EReal.coe_lt_coe_iff).2 ht
                have hpos0' : (0 : EReal) < f (0 : Fin n â†’ Real) := hf0
                have hright :=
                  rightScalarMultiple_pos (f := f) (lam := t) hfconv ht (0 : Fin n â†’ Real)
                have hmul : (0 : EReal) < (t : EReal) * f (0 : Fin n â†’ Real) :=
                  EReal.mul_pos hpos' hpos0'
                have hmul' : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
                  rw [hright]
                  have hzero : (tâ»Â¹ : Real) â€¢ (0 : Fin n â†’ Real) = 0 := by simp
                  rw [hzero]
                  exact hmul
                exact hmul'
              have hnot : Â¬ (rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal)) := by
                have hlt :
                    ((-1 : Real) : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) :=
                  lt_trans (by simp) hpos0
                exact not_le_of_gt hlt
              exact hnot hle
            Â· have hmem' :
                  (0, (-1 : Real)) âˆˆ
                    Set.recessionCone
                      (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                simpa [hrec] using hmem
              exact
                (no_neg_vertical_recession_epigraph (f := f) hfproper (Î¼ := (-1 : Real))
                  (by norm_num)) hmem'
          exact (hneg_not hmem_limit).elim
        exact hproper
      -- closed epigraph identification
      have hclosure_epigraph :
          closure (epigraph (Set.univ : Set (Fin n â†’ Real)) k) =
            closure (convexConeGeneratedEpigraph f) := by
          apply subset_antisymm
          Â· have hsubset :
              epigraph (Set.univ : Set (Fin n â†’ Real)) k âŠ†
                closure (convexConeGeneratedEpigraph f) := h_epi_subset
            have hsubset' :
                closure (epigraph (Set.univ : Set (Fin n â†’ Real)) k) âŠ†
                  closure (closure (convexConeGeneratedEpigraph f)) :=
              closure_mono hsubset
            simpa [closure_closure] using hsubset'
          Â· have hsubset :
              convexConeGeneratedEpigraph f âŠ†
                epigraph (Set.univ : Set (Fin n â†’ Real)) k := hcone_subset
            exact closure_mono hsubset
      have h_epi :=
        (epigraph_convexFunctionClosure_eq_closure_epigraph (f := k) hnotbot).1
      have hEq :
          epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) =
            closure (convexConeGeneratedEpigraph f) := by
        simpa [hclosure_epigraph] using h_epi
      have hle :
          convexFunctionClosure k x â‰¤
            sInf
              (Set.insert (f0_plus x)
                { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x }) := by
        refine le_sInf ?_
        intro z hz
        rcases hz with rfl | hz
        Â· by_cases htop : f0_plus x = (âŠ¤ : EReal)
          Â· simp [htop]
          Â· have hle0 : f0_plus x â‰¤ ((f0_plus x).toReal : EReal) :=
              EReal.le_coe_toReal htop
            have hmem0 :
                (x, (f0_plus x).toReal) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus :=
              (mem_epigraph_univ_iff (f := f0_plus)).2 hle0
            have hmem0' :
                (x, (f0_plus x).toReal) âˆˆ
                    (â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := Or.inr hmem0
            have hmem_closure' :
                (x, (f0_plus x).toReal) âˆˆ closure (convexConeGeneratedEpigraph f) := by
              simpa [hclosure_union''] using hmem0'
            have hmem_closure :
                (x, (f0_plus x).toReal) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) := by
              simpa [hEq] using hmem_closure'
            have hle' :
                convexFunctionClosure k x â‰¤ ((f0_plus x).toReal : EReal) :=
              (mem_epigraph_univ_iff (f := convexFunctionClosure k)).1 hmem_closure
            by_cases hbot : f0_plus x = (âŠ¥ : EReal)
            Â· have hforall : âˆ€ Î¼ : â„, convexFunctionClosure k x â‰¤ (Î¼ : EReal) := by
                intro Î¼
                have hmemÎ¼ :
                    (x, Î¼) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                  have hleÎ¼ : f0_plus x â‰¤ (Î¼ : EReal) := by
                    simp [hbot]
                  exact (mem_epigraph_univ_iff (f := f0_plus)).2 hleÎ¼
                have hmemÎ¼' :
                    (x, Î¼) âˆˆ
                      (â‹ƒ (t : Real) (_ : 0 < t),
                        epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                      epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := Or.inr hmemÎ¼
                have hmemÎ¼'' :
                    (x, Î¼) âˆˆ closure (convexConeGeneratedEpigraph f) := by
                  simpa [hclosure_union''] using hmemÎ¼'
                have hmemÎ¼''' :
                    (x, Î¼) âˆˆ
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) := by
                  simpa [hEq] using hmemÎ¼''
                exact (mem_epigraph_univ_iff (f := convexFunctionClosure k)).1 hmemÎ¼'''
              have hbotc : convexFunctionClosure k x = (âŠ¥ : EReal) := by
                apply (EReal.eq_bot_iff_forall_lt _).2
                intro y
                have hleÎ¼ : convexFunctionClosure k x â‰¤ ((y - 1 : â„) : EReal) :=
                  hforall (y - 1)
                have hlt : (y - 1 : â„) < y := by linarith
                have hlt' : ((y - 1 : â„) : EReal) < (y : EReal) :=
                  (EReal.coe_lt_coe_iff).2 hlt
                exact lt_of_le_of_lt hleÎ¼ hlt'
              simp [hbotc, hbot]
            Â· have hle'' : ((f0_plus x).toReal : EReal) â‰¤ f0_plus x :=
                EReal.coe_toReal_le hbot
              exact le_trans hle' hle''
        Â· rcases hz with âŸ¨lam, hlam, rflâŸ©
          by_cases htop : rightScalarMultiple f lam x = (âŠ¤ : EReal)
          Â· simp [htop]
          Â· have hle0 :
                rightScalarMultiple f lam x â‰¤
                  ((rightScalarMultiple f lam x).toReal : EReal) :=
              EReal.le_coe_toReal htop
            have hmem :
                (x, (rightScalarMultiple f lam x).toReal) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real))
                    (rightScalarMultiple f lam) :=
              (mem_epigraph_univ_iff (f := rightScalarMultiple f lam)).2 hle0
            have hmem' :
                (x, (rightScalarMultiple f lam x).toReal) âˆˆ
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              refine Or.inl ?_
              refine Set.mem_iUnion.2 âŸ¨lam, ?_âŸ©
              refine Set.mem_iUnion.2 âŸ¨hlam, ?_âŸ©
              exact hmem
            have hmem_closure' :
                (x, (rightScalarMultiple f lam x).toReal) âˆˆ
                  closure (convexConeGeneratedEpigraph f) := by
              simpa [hclosure_union''] using hmem'
            have hmem_epi' :
                (x, (rightScalarMultiple f lam x).toReal) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) := by
              simpa [hEq] using hmem_closure'
            have hle' :
                convexFunctionClosure k x â‰¤
                  ((rightScalarMultiple f lam x).toReal : EReal) :=
              (mem_epigraph_univ_iff (f := convexFunctionClosure k)).1 hmem_epi'
            have hne_bot : rightScalarMultiple f lam x â‰  (âŠ¥ : EReal) := by
              have hpos :=
                rightScalarMultiple_pos (f := f) (lam := lam) hfconv hlam x
              have hbot : f (lamâ»Â¹ â€¢ x) â‰  (âŠ¥ : EReal) := hfproper.2.2 _ (by simp)
              simpa [hpos] using (ereal_mul_ne_bot_of_pos hlam hbot)
            have hle'' :
                ((rightScalarMultiple f lam x).toReal : EReal) â‰¤ rightScalarMultiple f lam x :=
              EReal.coe_toReal_le hne_bot
            exact le_trans hle' hle''
      have hge :
          sInf
              (Set.insert (f0_plus x)
                { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x })
            â‰¤ convexFunctionClosure k x := by
        by_cases htop : convexFunctionClosure k x = (âŠ¤ : EReal)
        Â· simp [htop]
        Â· have hset :
              (x, (convexFunctionClosure k x).toReal) âˆˆ
                epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) := by
            have hle0 :
                convexFunctionClosure k x â‰¤ ((convexFunctionClosure k x).toReal : EReal) :=
              EReal.le_coe_toReal htop
            exact (mem_epigraph_univ_iff (f := convexFunctionClosure k)).2 hle0
          have hmem_union :
              (x, (convexFunctionClosure k x).toReal) âˆˆ
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
            have hmem' :
                (x, (convexFunctionClosure k x).toReal) âˆˆ
                  closure (convexConeGeneratedEpigraph f) := by
              simpa [hEq] using hset
            simpa [hclosure_union''] using hmem'
          have hproper_cl :
              ProperConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) :=
            (convexFunctionClosure_closed_properConvexFunctionOn_and_agrees_on_ri (f := k)
              hkproper).1.2
          rcases hmem_union with hmem_union | hmem_union
          Â· rcases (Set.mem_iUnion).1 hmem_union with âŸ¨lam, hmem_unionâŸ©
            rcases (Set.mem_iUnion).1 hmem_union with âŸ¨hlam, hmem_unionâŸ©
            have hle' :
                rightScalarMultiple f lam x â‰¤ ((convexFunctionClosure k x).toReal : EReal) :=
              (mem_epigraph_univ_iff (f := rightScalarMultiple f lam)).1 hmem_union
            have hne_bot : convexFunctionClosure k x â‰  (âŠ¥ : EReal) :=
              hproper_cl.2.2 x (by simp)
            have hle_to :
                ((convexFunctionClosure k x).toReal : EReal) â‰¤ convexFunctionClosure k x :=
              EReal.coe_toReal_le hne_bot
            have hle'' :
                rightScalarMultiple f lam x â‰¤ convexFunctionClosure k x := le_trans hle' hle_to
            have hmem :
                rightScalarMultiple f lam x âˆˆ
                  Set.insert (f0_plus x)
                    { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x } :=
              by
                right
                exact âŸ¨lam, hlam, rflâŸ©
            have hle''' :
                sInf
                    (Set.insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) â‰¤
                  rightScalarMultiple f lam x := sInf_le hmem
            exact le_trans hle''' hle''
          Â· have hle' : f0_plus x â‰¤ ((convexFunctionClosure k x).toReal : EReal) :=
              (mem_epigraph_univ_iff (f := f0_plus)).1 hmem_union
            have hne_bot : convexFunctionClosure k x â‰  (âŠ¥ : EReal) :=
              hproper_cl.2.2 x (by simp)
            have hle_to :
                ((convexFunctionClosure k x).toReal : EReal) â‰¤ convexFunctionClosure k x :=
              EReal.coe_toReal_le hne_bot
            have hle'' : f0_plus x â‰¤ convexFunctionClosure k x := le_trans hle' hle_to
            have hmem :
                f0_plus x âˆˆ
                  Set.insert (f0_plus x)
                    { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x } :=
              by
                left
                rfl
            have hle''' :
                sInf
                    (Set.insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) â‰¤
                  f0_plus x := sInf_le hmem
            exact le_trans hle''' hle''
      exact le_antisymm hle hge
    refine And.intro hcl_formula ?_
    Â· refine And.intro ?_ ?_
      Â· -- TODO: extract attainment from the closed epigraph description.
        intro x
        by_cases htop : convexFunctionClosure k x = (âŠ¤ : EReal)
        Â·
          have hmem :
              f0_plus x âˆˆ
                Set.insert (f0_plus x)
                  { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x } :=
            by
              apply (Set.mem_insert_iff).2
              left
              rfl
          have hle : convexFunctionClosure k x â‰¤ f0_plus x := by
            have hclx := hcl_formula x
            have hle := sInf_le hmem
            rw [hclx]
            exact hle
          have hf0 : f0_plus x = (âŠ¤ : EReal) := by
            have : (âŠ¤ : EReal) â‰¤ f0_plus x := by
              simpa [htop] using hle
            exact (top_le_iff.mp this)
          refine âŸ¨f0_plus x, ?_, ?_âŸ©
          Â· exact (Set.mem_insert_iff).2 (Or.inl rfl)
          Â· simp [htop, hf0]
        Â·
          -- use the union membership for `(x, convexFunctionClosure k x)` to pick an attained value
          have hnotbot : âˆ€ x : Fin n â†’ Real, k x â‰  (âŠ¥ : EReal) := by
            intro x
            by_contra hbot
            have hle : k x â‰¤ ((-1 : Real) : EReal) := by
              simp [hbot]
            have hmem_epi :
                (x, (-1 : Real)) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
              (mem_epigraph_univ_iff (f := k)).2 hle
            have hmem_closure : (x, (-1 : Real)) âˆˆ closure (convexConeGeneratedEpigraph f) :=
              h_epi_subset hmem_epi
            have hmem_union :
                (x, (-1 : Real)) âˆˆ
                    (â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              simpa [hclosure_union''] using hmem_closure
            -- but the union cannot contain any negative verticals
            have hneg_not :
                ((0 : Fin n â†’ Real), (-1 : Real)) âˆ‰
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              intro hmem
              rcases hmem with hmem | hmem
              Â· rcases (Set.mem_iUnion).1 hmem with âŸ¨t, hmemâŸ©
                rcases (Set.mem_iUnion).1 hmem with âŸ¨ht, hmemâŸ©
                have hle' :
                    rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal) :=
                  (mem_epigraph_univ_iff (f := rightScalarMultiple f t)).1 hmem
                have hpos0 : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
                  have hpos' : (0 : EReal) < (t : EReal) := by
                    simpa using (EReal.coe_lt_coe_iff).2 ht
                  have hpos0' : (0 : EReal) < f (0 : Fin n â†’ Real) := hf0
                  have hright :=
                    rightScalarMultiple_pos (f := f) (lam := t) hfconv ht (0 : Fin n â†’ Real)
                  have hmul : (0 : EReal) < (t : EReal) * f (0 : Fin n â†’ Real) :=
                    EReal.mul_pos hpos' hpos0'
                  have hmul' : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
                    rw [hright]
                    have hzero : (tâ»Â¹ : Real) â€¢ (0 : Fin n â†’ Real) = 0 := by simp
                    rw [hzero]
                    exact hmul
                  exact hmul'
                have hnot :
                    Â¬ (rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal)) := by
                  have hlt :
                      ((-1 : Real) : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) :=
                    lt_trans (by simp) hpos0
                  exact not_le_of_gt hlt
                exact hnot hle'
              Â· have hmem' :
                    (0, (-1 : Real)) âˆˆ
                      Set.recessionCone
                        (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                  simpa [hrec] using hmem
                exact
                  (no_neg_vertical_recession_epigraph (f := f) hfproper (Î¼ := (-1 : Real))
                    (by norm_num)) hmem'
            -- use union equality to reach a contradiction
            have hmem0 :
                ((0 : Fin n â†’ Real), (-1 : Real)) âˆˆ
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              -- from `hmem_union`, scale down to the origin and close
              have hclosed_union :
                  IsClosed
                    ((â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                      epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus) := by
                simpa [hclosure_union''] using
                  (isClosed_closure (s := convexConeGeneratedEpigraph f))
              have hmem_seq :
                  âˆ€ m : â„•,
                    (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                      (â‹ƒ (t : Real) (_ : 0 < t),
                        epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                      epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                intro m
                have hpos : 0 < (1 : Real) / (m + 1) := by
                  have : 0 < (m + 1 : Real) := by
                    exact_mod_cast (Nat.succ_pos m)
                  exact one_div_pos.mpr this
                -- vertical line at `x` for `k x = âŠ¥`
                have hle' : k x â‰¤ ((-1 : Real) / ((1 : Real) / (m + 1)) : Real) := by
                  simp [hbot]
                have hmem_epi :
                    (x, (-1 : Real) / ((1 : Real) / (m + 1))) âˆˆ
                      epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
                  (mem_epigraph_univ_iff (f := k)).2 hle'
                have hmem_closure' := h_epi_subset hmem_epi
                have hmem_union' :
                    (x, (-1 : Real) / ((1 : Real) / (m + 1))) âˆˆ
                      (â‹ƒ (t : Real) (_ : 0 < t),
                        epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                      epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                  simpa [hclosure_union''] using hmem_closure'
                -- scale within the cone
                rcases hmem_union' with hmem_union' | hmem_union'
                Â· rcases (Set.mem_iUnion).1 hmem_union' with âŸ¨s, hmem_union'âŸ©
                  rcases (Set.mem_iUnion).1 hmem_union' with âŸ¨hspos, hmem_union'âŸ©
                  have hle'' :
                      rightScalarMultiple f s x â‰¤
                        ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) :=
                    (mem_epigraph_univ_iff (f := rightScalarMultiple f s)).1 hmem_union'
                  have hle''' :
                      rightScalarMultiple f ((1 : Real) / (m + 1) * s)
                        (((1 : Real) / (m + 1)) â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
                    have hpos' : 0 < (1 : Real) / (m + 1) := by
                      have : 0 < (m + 1 : Real) := by
                        exact_mod_cast (Nat.succ_pos m)
                      exact one_div_pos.mpr this
                    have hmul :=
                      ereal_mul_le_mul_of_pos_left_general (t := (1 : Real) / (m + 1))
                        (ht := hpos') hle''
                    have hright :
                        ((1 : Real) / (m + 1) : EReal) *
                            ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) =
                          (-1 : EReal) := by
                      have hdiv :
                          ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) =
                            (((1 : Real) / (m + 1))â»Â¹ : EReal) * (-1 : EReal) := by
                        simp [div_eq_mul_inv, mul_comm]
                      calc
                        ((1 : Real) / (m + 1) : EReal) *
                            ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) =
                            ((1 : Real) / (m + 1) : EReal) *
                              (((1 : Real) / (m + 1))â»Â¹ : EReal) * (-1 : EReal) := by
                                rw [hdiv, mul_assoc]
                        _ = (-1 : EReal) := by
                              simpa using
                                (ereal_mul_inv_smul (t := (1 : Real) / (m + 1)) (ht := hpos')
                                  (x := (-1 : EReal)))
                    have hmul' :
                        ((1 : Real) / (m + 1) : EReal) * rightScalarMultiple f s x â‰¤
                          ((-1 : Real) : EReal) := by
                      calc
                        ((1 : Real) / (m + 1) : EReal) * rightScalarMultiple f s x â‰¤
                            ((1 : Real) / (m + 1) : EReal) *
                              ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) := hmul
                        _ = (-1 : EReal) := hright
                    have hspos' : 0 < (1 : Real) / (m + 1) * s := mul_pos hpos' hspos
                    have hpos_ts :=
                      rightScalarMultiple_pos (f := f) (lam := (1 : Real) / (m + 1) * s)
                        hfconv hspos' (((1 : Real) / (m + 1)) â€¢ x)
                    have hpos_s :=
                      rightScalarMultiple_pos (f := f) (lam := s) hfconv hspos x
                    have hsmul :
                        ((1 : Real) / (m + 1) * s)â»Â¹ â€¢ (((1 : Real) / (m + 1)) â€¢ x) = sâ»Â¹ â€¢ x := by
                      have ht0 : (1 : Real) / (m + 1) â‰  0 := ne_of_gt hpos'
                      have hs0 : s â‰  0 := ne_of_gt hspos
                      have hscale :
                          ((1 : Real) / (m + 1) * s)â»Â¹ * ((1 : Real) / (m + 1)) = sâ»Â¹ := by
                        field_simp [ht0, hs0]
                      calc
                        ((1 : Real) / (m + 1) * s)â»Â¹ â€¢ (((1 : Real) / (m + 1)) â€¢ x) =
                            (((1 : Real) / (m + 1) * s)â»Â¹ * ((1 : Real) / (m + 1))) â€¢ x := by
                              rw [smul_smul]
                        _ = sâ»Â¹ â€¢ x := by
                              rw [hscale]
                    have hmul1 :
                        (((1 : Real) / (m + 1) * s : Real) : EReal) * f (sâ»Â¹ â€¢ x) â‰¤
                          ((-1 : Real) : EReal) := by
                      simpa [hpos_s, EReal.coe_mul, mul_assoc] using hmul'
                    have hsmul' :
                        (sâ»Â¹ * (m + 1 : Real)) â€¢ ((m + 1 : Real)â»Â¹ â€¢ x) = sâ»Â¹ â€¢ x := by
                      have hne : (m + 1 : Real) â‰  0 := by
                        exact_mod_cast (Nat.succ_ne_zero m)
                      calc
                        (sâ»Â¹ * (m + 1 : Real)) â€¢ ((m + 1 : Real)â»Â¹ â€¢ x) =
                            ((sâ»Â¹ * (m + 1 : Real)) * (m + 1 : Real)â»Â¹) â€¢ x := by
                              simp [smul_smul]
                        _ = sâ»Â¹ â€¢ x := by
                              simp [hne]
                    have hmul2 :
                        (((1 : Real) / (m + 1) * s : Real) : EReal) *
                            f (((1 : Real) / (m + 1) * s)â»Â¹ â€¢ (((1 : Real) / (m + 1)) â€¢ x)) â‰¤
                          ((-1 : Real) : EReal) := by
                      simpa [div_eq_mul_inv, smul_smul, hsmul'] using hmul1
                    rw [hpos_ts]
                    exact hmul2
                  have hmem'' :
                      (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                        epigraph (Set.univ : Set (Fin n â†’ Real))
                          (rightScalarMultiple f ((1 : Real) / (m + 1) * s)) :=
                    (mem_epigraph_univ_iff
                      (f := rightScalarMultiple f ((1 : Real) / (m + 1) * s))).2 hle'''
                  refine Or.inl ?_
                  refine Set.mem_iUnion.2 âŸ¨(1 : Real) / (m + 1) * s, ?_âŸ©
                  refine Set.mem_iUnion.2 âŸ¨mul_pos hpos hspos, hmem''âŸ©
                Â· have hmem'' :
                    (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                      epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                    have hrec' :
                        (x, (-1 : Real) / ((1 : Real) / (m + 1))) âˆˆ
                          Set.recessionCone
                            (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                      simpa [hrec] using hmem_union'
                    have hrec'' :
                        (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                          Set.recessionCone
                            (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                      intro y hy s hs
                      have hs0 : 0 â‰¤ s * (1 : Real) / (m + 1) := by
                        have hpos : 0 < (m + 1 : Real) := by
                          exact_mod_cast (Nat.succ_pos m)
                        have hpos' : 0 â‰¤ (1 : Real) / (m + 1) := by
                          exact le_of_lt (one_div_pos.mpr hpos)
                        have hs0' : 0 â‰¤ s * ((1 : Real) / (m + 1)) := mul_nonneg hs hpos'
                        simpa [div_eq_mul_inv, mul_assoc] using hs0'
                      have hrec_mem :=
                        hrec' (x := y) hy (t := s * (1 : Real) / (m + 1)) hs0
                      have hne : (m + 1 : Real) â‰  0 := by
                        exact_mod_cast (Nat.succ_ne_zero m)
                      have hmul :
                          s * ((m + 1 : Real)â»Â¹ * (-1 + -(m : Real))) = -s := by
                        field_simp [hne]
                        ring
                      simpa [div_eq_mul_inv, smul_smul, mul_comm, mul_left_comm, mul_assoc, hmul]
                        using hrec_mem
                    simpa [hrec] using hrec''
                  exact Or.inr hmem''
              have hlim :
                  Filter.Tendsto
                    (fun n : â„• => (((1 : Real) / (n + 1)) â€¢ x, (-1 : Real))) Filter.atTop
                      (ğ“ ((0 : Fin n â†’ Real), (-1 : Real))) := by
                have h1 :
                    Filter.Tendsto
                      (fun n : â„• => (1 : Real) / (n + 1)) Filter.atTop (ğ“ (0 : Real)) :=
                  tendsto_one_div_add_atTop_nhds_zero_nat
                have h1' :
                    Filter.Tendsto (fun n : â„• => ((1 : Real) / (n + 1)) â€¢ x) Filter.atTop
                      (ğ“ (0 : Fin n â†’ Real)) := by
                        have h1' :=
                          h1.smul
                            (tendsto_const_nhds :
                              Filter.Tendsto (fun _ : â„• => x) Filter.atTop (ğ“ x))
                        have hzero : (0 : Real) â€¢ x = (0 : Fin n â†’ Real) := by
                          simp
                        simpa [hzero] using h1'
                have h2 :
                    Filter.Tendsto (fun _ : â„• => (-1 : Real)) Filter.atTop (ğ“ (-1 : Real)) :=
                  tendsto_const_nhds
                exact Filter.Tendsto.prodMk_nhds h1' h2
              exact hclosed_union.mem_of_tendsto hlim (eventually_of_forall hmem_seq)
            exact (hneg_not hmem0).elim
          -- use the union membership at the closure value to pick a witness
          have hnotbot' : âˆ€ x : Fin n â†’ Real, k x â‰  (âŠ¥ : EReal) := hnotbot
          have h_epi :=
            (epigraph_convexFunctionClosure_eq_closure_epigraph (f := k) hnotbot').1
          have hclosure_epigraph :
              closure (epigraph (Set.univ : Set (Fin n â†’ Real)) k) =
                closure (convexConeGeneratedEpigraph f) := by
            apply subset_antisymm
            Â· have hsubset :
                epigraph (Set.univ : Set (Fin n â†’ Real)) k âŠ†
                  closure (convexConeGeneratedEpigraph f) := h_epi_subset
              have hsubset' :
                  closure (epigraph (Set.univ : Set (Fin n â†’ Real)) k) âŠ†
                    closure (closure (convexConeGeneratedEpigraph f)) :=
                closure_mono hsubset
              simpa [closure_closure] using hsubset'
            Â· have hsubset :
                convexConeGeneratedEpigraph f âŠ†
                  epigraph (Set.univ : Set (Fin n â†’ Real)) k := hcone_subset
              exact closure_mono hsubset
          have hEq :
              epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) =
                closure (convexConeGeneratedEpigraph f) := by
            simpa [hclosure_epigraph] using h_epi
          have hmem :
              (x, (convexFunctionClosure k x).toReal) âˆˆ
                epigraph (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) := by
            have hle :
                convexFunctionClosure k x â‰¤ ((convexFunctionClosure k x).toReal : EReal) :=
              EReal.le_coe_toReal htop
            exact (mem_epigraph_univ_iff (f := convexFunctionClosure k)).2 hle
          have hmem_union :
              (x, (convexFunctionClosure k x).toReal) âˆˆ
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
            have hmem' : (x, (convexFunctionClosure k x).toReal) âˆˆ
                closure (convexConeGeneratedEpigraph f) := by
              simpa [hEq] using hmem
            simpa [hclosure_union''] using hmem'
          have hproper_cl :
              ProperConvexFunctionOn (Set.univ : Set (Fin n â†’ Real)) (convexFunctionClosure k) :=
            (convexFunctionClosure_closed_properConvexFunctionOn_and_agrees_on_ri (f := k)
              hkproper).1.2
          have hne_bot : convexFunctionClosure k x â‰  (âŠ¥ : EReal) :=
            hproper_cl.2.2 x (by simp)
          have htoReal_le :
              ((convexFunctionClosure k x).toReal : EReal) â‰¤ convexFunctionClosure k x :=
            EReal.coe_toReal_le hne_bot
          rcases hmem_union with hmem_union | hmem_union
          Â· rcases (Set.mem_iUnion).1 hmem_union with âŸ¨lam, hmem_unionâŸ©
            rcases (Set.mem_iUnion).1 hmem_union with âŸ¨hlam, hmem_unionâŸ©
            have hle' :
                rightScalarMultiple f lam x â‰¤ ((convexFunctionClosure k x).toReal : EReal) :=
              (mem_epigraph_univ_iff (f := rightScalarMultiple f lam)).1 hmem_union
            have hle'' : rightScalarMultiple f lam x â‰¤ convexFunctionClosure k x :=
              le_trans hle' htoReal_le
            have hmem_set :
                rightScalarMultiple f lam x âˆˆ
                  Set.insert (f0_plus x)
                    { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x } := by
              apply (Set.mem_insert_iff).2
              right
              exact âŸ¨lam, hlam, rflâŸ©
            have hle_sInf : convexFunctionClosure k x â‰¤ rightScalarMultiple f lam x := by
              have hclx := hcl_formula x
              have hle := sInf_le hmem_set
              rw [hclx]
              exact hle
            have hEq : convexFunctionClosure k x = rightScalarMultiple f lam x :=
              le_antisymm hle_sInf hle''
            exact âŸ¨rightScalarMultiple f lam x, hmem_set, hEqâŸ©
          Â· have hle' : f0_plus x â‰¤ ((convexFunctionClosure k x).toReal : EReal) :=
              (mem_epigraph_univ_iff (f := f0_plus)).1 hmem_union
            have hle'' : f0_plus x â‰¤ convexFunctionClosure k x :=
              le_trans hle' htoReal_le
            have hmem_set :
                f0_plus x âˆˆ
                  Set.insert (f0_plus x)
                    { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x } :=
              by
                apply (Set.mem_insert_iff).2
                left
                rfl
            have hle_sInf : convexFunctionClosure k x â‰¤ f0_plus x := by
              have hclx := hcl_formula x
              have hle := sInf_le hmem_set
              rw [hclx]
              exact hle
            have hEq : convexFunctionClosure k x = f0_plus x :=
              le_antisymm hle_sInf hle''
            exact âŸ¨f0_plus x, hmem_set, hEqâŸ©
      Â· intro hdom0
        have hk_pos_formula :=
          posHomGenerated_formula_pos (n := n) (f := f) hfconv hfinite hdom0
        have hk_pos_formula' :
            âˆ€ x : Fin n â†’ Real,
              k x = sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§ z = rightScalarMultiple f lam x } := by
          rw [hk]
          exact hk_pos_formula
        refine And.intro ?_ ?_
        Â· -- TODO: show `k` is closed from the closure-cone identification.
          -- show `convexFunctionClosure k = k`
          have hnotbot : âˆ€ x : Fin n â†’ Real, k x â‰  (âŠ¥ : EReal) := by
            intro x
            by_contra hbot
            have hle : k x â‰¤ ((-1 : Real) : EReal) := by
              simp [hbot]
            have hmem_epi :
                (x, (-1 : Real)) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
              (mem_epigraph_univ_iff (f := k)).2 hle
            have hmem_closure : (x, (-1 : Real)) âˆˆ closure (convexConeGeneratedEpigraph f) :=
              h_epi_subset hmem_epi
            have hmem_union :
                (x, (-1 : Real)) âˆˆ
                    (â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              simpa [hclosure_union''] using hmem_closure
            -- no negative verticals
            have hneg_not :
                ((0 : Fin n â†’ Real), (-1 : Real)) âˆ‰
                  (â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              intro hmem
              rcases hmem with hmem | hmem
              Â· rcases (Set.mem_iUnion).1 hmem with âŸ¨t, hmemâŸ©
                rcases (Set.mem_iUnion).1 hmem with âŸ¨ht, hmemâŸ©
                have hle' :
                    rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal) :=
                  (mem_epigraph_univ_iff (f := rightScalarMultiple f t)).1 hmem
                have hpos0 : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
                  have hpos' : (0 : EReal) < (t : EReal) := by
                    simpa using (EReal.coe_lt_coe_iff).2 ht
                  have hpos0' : (0 : EReal) < f (0 : Fin n â†’ Real) := hf0
                  have hright :=
                    rightScalarMultiple_pos (f := f) (lam := t) hfconv ht (0 : Fin n â†’ Real)
                  have hmul : (0 : EReal) < (t : EReal) * f (0 : Fin n â†’ Real) :=
                    EReal.mul_pos hpos' hpos0'
                  have hmul' : (0 : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) := by
                    rw [hright]
                    have hzero : (tâ»Â¹ : Real) â€¢ (0 : Fin n â†’ Real) = 0 := by simp
                    rw [hzero]
                    exact hmul
                  exact hmul'
                have hnot :
                    Â¬ (rightScalarMultiple f t (0 : Fin n â†’ Real) â‰¤ ((-1 : Real) : EReal)) := by
                  have hlt :
                      ((-1 : Real) : EReal) < rightScalarMultiple f t (0 : Fin n â†’ Real) :=
                    lt_trans (by simp) hpos0
                  exact not_le_of_gt hlt
                exact hnot hle'
              Â· have hmem' :
                    (0, (-1 : Real)) âˆˆ
                      Set.recessionCone
                        (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                  simpa [hrec] using hmem
                exact
                  (no_neg_vertical_recession_epigraph (f := f) hfproper (Î¼ := (-1 : Real))
                    (by norm_num)) hmem'
            -- scale to the origin
            have hclosed_union :
                IsClosed
                  ((â‹ƒ (t : Real) (_ : 0 < t),
                    epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus) := by
              simpa [hclosure_union''] using
                (isClosed_closure (s := convexConeGeneratedEpigraph f))
            have hmem_seq :
                âˆ€ m : â„•,
                  (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                    (â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
              intro m
              have hpos : 0 < (1 : Real) / (m + 1) := by
                have : 0 < (m + 1 : Real) := by
                  exact_mod_cast (Nat.succ_pos m)
                exact one_div_pos.mpr this
              -- vertical line at `x` for `k x = âŠ¥`
              have hle' : k x â‰¤ ((-1 : Real) / ((1 : Real) / (m + 1)) : Real) := by
                simp [hbot]
              have hmem_epi :
                  (x, (-1 : Real) / ((1 : Real) / (m + 1))) âˆˆ
                    epigraph (Set.univ : Set (Fin n â†’ Real)) k :=
                (mem_epigraph_univ_iff (f := k)).2 hle'
              have hmem_closure' := h_epi_subset hmem_epi
              have hmem_union' :
                  (x, (-1 : Real) / ((1 : Real) / (m + 1))) âˆˆ
                    (â‹ƒ (t : Real) (_ : 0 < t),
                      epigraph (Set.univ : Set (Fin n â†’ Real)) (rightScalarMultiple f t)) âˆª
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                simpa [hclosure_union''] using hmem_closure'
              -- scale within the cone
              rcases hmem_union' with hmem_union' | hmem_union'
              Â· rcases (Set.mem_iUnion).1 hmem_union' with âŸ¨s, hmem_union'âŸ©
                rcases (Set.mem_iUnion).1 hmem_union' with âŸ¨hspos, hmem_union'âŸ©
                have hle'' :
                    rightScalarMultiple f s x â‰¤
                      ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) :=
                  (mem_epigraph_univ_iff (f := rightScalarMultiple f s)).1 hmem_union'
                have hle''' :
                    rightScalarMultiple f ((1 : Real) / (m + 1) * s)
                      (((1 : Real) / (m + 1)) â€¢ x) â‰¤ ((-1 : Real) : EReal) := by
                  have hpos' : 0 < (1 : Real) / (m + 1) := by
                    have : 0 < (m + 1 : Real) := by
                      exact_mod_cast (Nat.succ_pos m)
                    exact one_div_pos.mpr this
                  have hmul :=
                    ereal_mul_le_mul_of_pos_left_general (t := (1 : Real) / (m + 1))
                      (ht := hpos') hle''
                  have hne : (1 : Real) / (m + 1) â‰  0 := ne_of_gt hpos'
                  have hmul' :
                      ((1 : Real) / (m + 1) : EReal) * rightScalarMultiple f s x â‰¤
                        ((-1 : Real) : EReal) := by
                    have hright :
                        ((1 : Real) / (m + 1) : EReal) *
                            ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) = (-1 : EReal) := by
                      have hdiv :
                          ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) =
                            (((1 : Real) / (m + 1))â»Â¹ : EReal) * (-1 : EReal) := by
                        simp [div_eq_mul_inv, mul_comm]
                      calc
                        ((1 : Real) / (m + 1) : EReal) *
                            ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) =
                            ((1 : Real) / (m + 1) : EReal) *
                              (((1 : Real) / (m + 1))â»Â¹ : EReal) * (-1 : EReal) := by
                                rw [hdiv, mul_assoc]
                        _ = (-1 : EReal) := by
                              simpa using
                                (ereal_mul_inv_smul (t := (1 : Real) / (m + 1)) (ht := hpos')
                                  (x := (-1 : EReal)))
                    calc
                      ((1 : Real) / (m + 1) : EReal) * rightScalarMultiple f s x â‰¤
                          ((1 : Real) / (m + 1) : EReal) *
                            ((-1 : Real) / ((1 : Real) / (m + 1)) : EReal) := hmul
                      _ = (-1 : EReal) := hright
                  have hspos' : 0 < (1 : Real) / (m + 1) * s := mul_pos hpos' hspos
                  have hpos1 :=
                    rightScalarMultiple_pos (f := f) (lam := (1 : Real) / (m + 1) * s)
                      hfconv hspos' (((1 : Real) / (m + 1)) â€¢ x)
                  have hpos2 :=
                    rightScalarMultiple_pos (f := f) (lam := s) hfconv hspos x
                  have hsmul :
                      ((1 : Real) / (m + 1) * s)â»Â¹ â€¢ (((1 : Real) / (m + 1)) â€¢ x) = sâ»Â¹ â€¢ x := by
                    have ht0 : (1 : Real) / (m + 1) â‰  0 := ne_of_gt hpos'
                    have hs0 : s â‰  0 := ne_of_gt hspos
                    have hscale :
                        ((1 : Real) / (m + 1) * s)â»Â¹ * ((1 : Real) / (m + 1)) = sâ»Â¹ := by
                      field_simp [ht0, hs0]
                    calc
                      ((1 : Real) / (m + 1) * s)â»Â¹ â€¢ (((1 : Real) / (m + 1)) â€¢ x) =
                          (((1 : Real) / (m + 1) * s)â»Â¹ * ((1 : Real) / (m + 1))) â€¢ x := by
                            rw [smul_smul]
                      _ = sâ»Â¹ â€¢ x := by
                            rw [hscale]
                  have hmul1 :
                      (((1 : Real) / (m + 1) * s : Real) : EReal) * f (sâ»Â¹ â€¢ x) â‰¤
                        ((-1 : Real) : EReal) := by
                    simpa [hpos2, EReal.coe_mul, mul_assoc] using hmul'
                  have hsmul' :
                      (sâ»Â¹ * (m + 1 : Real)) â€¢ ((m + 1 : Real)â»Â¹ â€¢ x) = sâ»Â¹ â€¢ x := by
                    have hne : (m + 1 : Real) â‰  0 := by
                      exact_mod_cast (Nat.succ_ne_zero m)
                    calc
                      (sâ»Â¹ * (m + 1 : Real)) â€¢ ((m + 1 : Real)â»Â¹ â€¢ x) =
                          ((sâ»Â¹ * (m + 1 : Real)) * (m + 1 : Real)â»Â¹) â€¢ x := by
                            simp [smul_smul]
                      _ = sâ»Â¹ â€¢ x := by
                            simp [hne]
                  have hmul2 :
                      (((1 : Real) / (m + 1) * s : Real) : EReal) *
                          f (((1 : Real) / (m + 1) * s)â»Â¹ â€¢ (((1 : Real) / (m + 1)) â€¢ x)) â‰¤
                        ((-1 : Real) : EReal) := by
                    simpa [div_eq_mul_inv, smul_smul, hsmul'] using hmul1
                  rw [hpos1]
                  exact hmul2
                have hmem'' :
                    (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                      epigraph (Set.univ : Set (Fin n â†’ Real))
                        (rightScalarMultiple f ((1 : Real) / (m + 1) * s)) :=
                  (mem_epigraph_univ_iff
                    (f := rightScalarMultiple f ((1 : Real) / (m + 1) * s))).2 hle'''
                refine Or.inl ?_
                refine Set.mem_iUnion.2 âŸ¨(1 : Real) / (m + 1) * s, ?_âŸ©
                refine Set.mem_iUnion.2 âŸ¨mul_pos hpos hspos, hmem''âŸ©
              Â· have hmem'' :
                  (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                    epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus := by
                  have hrec' :
                      (x, (-1 : Real) / ((1 : Real) / (m + 1))) âˆˆ
                        Set.recessionCone
                          (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                    rw [hrec]
                    exact hmem_union'
                  have hrec'' :
                      (((1 : Real) / (m + 1)) â€¢ x, (-1 : Real)) âˆˆ
                        Set.recessionCone
                          (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                    intro y hy s hs
                    have hs0 : 0 â‰¤ s * (1 : Real) / (m + 1) := by
                      have hpos : 0 < (m + 1 : Real) := by
                        exact_mod_cast (Nat.succ_pos m)
                      have hpos' : 0 â‰¤ (1 : Real) / (m + 1) := by
                        exact le_of_lt (one_div_pos.mpr hpos)
                      have hs0' : 0 â‰¤ s * ((1 : Real) / (m + 1)) := mul_nonneg hs hpos'
                      simpa [div_eq_mul_inv, mul_assoc] using hs0'
                    have hrec_mem :=
                      hrec' (x := y) hy (t := s * (1 : Real) / (m + 1)) hs0
                    have hne : (m + 1 : Real) â‰  0 := by
                      exact_mod_cast (Nat.succ_ne_zero m)
                    have hmul :
                        s * ((m + 1 : Real)â»Â¹ * (-1 + -(m : Real))) = -s := by
                      field_simp [hne]
                      ring
                    simpa [div_eq_mul_inv, smul_smul, mul_assoc, hmul] using hrec_mem
                  rw [â† hrec]
                  exact hrec''
                exact Or.inr hmem''
            have hlim :
                Filter.Tendsto
                  (fun n : â„• => (((1 : Real) / (n + 1)) â€¢ x, (-1 : Real))) Filter.atTop
                    (ğ“ ((0 : Fin n â†’ Real), (-1 : Real))) := by
              have h1 :
                  Filter.Tendsto
                    (fun n : â„• => (1 : Real) / (n + 1)) Filter.atTop (ğ“ (0 : Real)) :=
                tendsto_one_div_add_atTop_nhds_zero_nat
              have h1' :
                  Filter.Tendsto (fun n : â„• => ((1 : Real) / (n + 1)) â€¢ x) Filter.atTop
                    (ğ“ (0 : Fin n â†’ Real)) := by
                      have h1' :=
                        h1.smul
                          (tendsto_const_nhds :
                            Filter.Tendsto (fun _ : â„• => x) Filter.atTop (ğ“ x))
                      rw [â† (zero_smul (Mâ‚€ := Real) (A := Fin n â†’ Real) (m := x))]
                      exact h1'
              have h2 :
                  Filter.Tendsto (fun _ : â„• => (-1 : Real)) Filter.atTop (ğ“ (-1 : Real)) :=
                tendsto_const_nhds
              exact Filter.Tendsto.prodMk_nhds h1' h2
            have hmem0 :=
              hclosed_union.mem_of_tendsto hlim (eventually_of_forall hmem_seq)
            exact (hneg_not hmem0).elim
        -- now compare the formulas to get closure equality
          have hle' :
              âˆ€ x : Fin n â†’ Real,
                k x â‰¤ f0_plus x := by
            intro x
            -- `f0_plus x` is a recession direction: use the recession cone property
            have hdom0' : f (0 : Fin n â†’ Real) â‰  (âŠ¤ : EReal) :=
              mem_effectiveDomain_imp_ne_top (x := (0 : Fin n â†’ Real)) hdom0
            have hbot0 : f (0 : Fin n â†’ Real) â‰  (âŠ¥ : EReal) := hfproper.2.2 _ (by simp)
            set r : Real := (f (0 : Fin n â†’ Real)).toReal
            have h0mem :
                ((0 : Fin n â†’ Real), r) âˆˆ
                  epigraph (Set.univ : Set (Fin n â†’ Real)) f := by
              have hle0 : f (0 : Fin n â†’ Real) â‰¤ (r : EReal) :=
                EReal.le_coe_toReal hdom0'
              exact (mem_epigraph_univ_iff (f := f)).2 hle0
            have hleÎ¼ :
                âˆ€ Î¼ : Real, f0_plus x â‰¤ (Î¼ : EReal) â†’ k x â‰¤ (Î¼ : EReal) := by
              intro Î¼ hÎ¼
              have hrec_mem :
                  (x, Î¼) âˆˆ Set.recessionCone
                    (epigraph (Set.univ : Set (Fin n â†’ Real)) f) := by
                have hmem' :
                    (x, Î¼) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) f0_plus :=
                  (mem_epigraph_univ_iff (f := f0_plus)).2 hÎ¼
                rw [hrec]
                exact hmem'
              have hbound :
                  âˆ€ t : Real, 0 â‰¤ t â†’
                    f (t â€¢ x) â‰¤ ((r + t * Î¼ : Real) : EReal) := by
                intro t ht
                have hmem := hrec_mem (x := ((0 : Fin n â†’ Real), r)) h0mem (t := t) ht
                have hmem' :
                    (t â€¢ x, r + t * Î¼) âˆˆ epigraph (Set.univ : Set (Fin n â†’ Real)) f := by
                  simpa [add_comm, add_left_comm, add_assoc] using hmem
                exact (mem_epigraph_univ_iff (f := f)).1 hmem'
              have hle_rs :
                  âˆ€ lam : Real, 0 < lam â†’
                    rightScalarMultiple f lam x â‰¤ ((Î¼ + lam * r : Real) : EReal) := by
                intro lam hlam
                have hbound' :
                    f (lamâ»Â¹ â€¢ x) â‰¤ ((r + lamâ»Â¹ * Î¼ : Real) : EReal) := by
                  have hbound0 := hbound (lamâ»Â¹) (by
                    have : 0 < lamâ»Â¹ := inv_pos.mpr hlam
                    exact le_of_lt this)
                  simpa [smul_smul, inv_mul_cancel, hlam.ne'] using hbound0
                have hmul :=
                  ereal_mul_le_mul_of_pos_left_general (t := lam) (ht := hlam) hbound'
                have hne : (lam : Real) â‰  0 := ne_of_gt hlam
                have hmul' :
                    rightScalarMultiple f lam x â‰¤ ((Î¼ + lam * r : Real) : EReal) := by
                  have hpos :=
                    rightScalarMultiple_pos (f := f) (lam := lam) hfconv hlam x
                  -- rewrite using the positive formula
                  have hpos' :
                      rightScalarMultiple f lam x =
                        ((lam : Real) : EReal) * f (lamâ»Â¹ â€¢ x) := by
                    simpa using hpos
                  -- simplify the right side
                  have hright :
                      ((lam : Real) : EReal) *
                        ((r + lamâ»Â¹ * Î¼ : Real) : EReal) =
                        ((Î¼ + lam * r : Real) : EReal) := by
                    have hreal : lam * (r + lamâ»Â¹ * Î¼) = Î¼ + lam * r := by
                      calc
                        lam * (r + lamâ»Â¹ * Î¼) = lam * r + lam * lamâ»Â¹ * Î¼ := by ring
                        _ = lam * r + Î¼ := by simp [hne]
                        _ = Î¼ + lam * r := by ring
                    calc
                      ((lam : Real) : EReal) * ((r + lamâ»Â¹ * Î¼ : Real) : EReal) =
                          ((lam * (r + lamâ»Â¹ * Î¼) : Real) : EReal) := by
                            simp [EReal.coe_mul]
                      _ = ((Î¼ + lam * r : Real) : EReal) := by
                            simp [hreal]
                  calc
                    rightScalarMultiple f lam x =
                        ((lam : Real) : EReal) * f (lamâ»Â¹ â€¢ x) := by
                          exact hpos'
                    _ â‰¤ ((lam : Real) : EReal) * ((r + lamâ»Â¹ * Î¼ : Real) : EReal) := hmul
                    _ = ((Î¼ + lam * r : Real) : EReal) := hright
                exact hmul'
              have hle_k :
                  k x â‰¤ ((Î¼ : Real) : EReal) := by
                have hform := hk_pos_formula' x
                -- k x is the infimum over positive scalings
                have hle' :
                    k x â‰¤ sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                      z = rightScalarMultiple f lam x } := by
                  exact le_of_eq hform
                have hle'' :
                    sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                      z = rightScalarMultiple f lam x } â‰¤ (Î¼ : EReal) := by
                  refine (EReal.le_of_forall_lt_iff_le (x := (Î¼ : EReal))
                    (y := sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                      z = rightScalarMultiple f lam x })).1 ?_
                  intro z hz
                  have hz' : Î¼ < z := by
                    exact (EReal.coe_lt_coe_iff).1 hz
                  have hÎµpos : 0 < z - Î¼ := by linarith
                  have hrpos : 0 < r := by
                    have hf0' : (0 : EReal) < f (0 : Fin n â†’ Real) := hf0
                    simpa [r] using
                      (EReal.toReal_pos (x := f (0 : Fin n â†’ Real)) hf0' hdom0')
                  have hpos : 0 < (z - Î¼) / r := by
                    exact div_pos hÎµpos hrpos
                  have hle_rs' :
                      rightScalarMultiple f ((z - Î¼) / r) x â‰¤ (z : EReal) := by
                    have hle' := hle_rs ((z - Î¼) / r) hpos
                    have hcalc : (Î¼ + ((z - Î¼) / r) * r : Real) = z := by
                      have hrne : r â‰  0 := ne_of_gt hrpos
                      calc
                        Î¼ + ((z - Î¼) / r) * r = Î¼ + (z - Î¼) := by
                          field_simp [hrne]
                        _ = z := by ring
                    simpa [hcalc] using hle'
                  have hmem :
                      rightScalarMultiple f ((z - Î¼) / r) x âˆˆ
                        { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x } := by
                    exact âŸ¨(z - Î¼) / r, hpos, rflâŸ©
                  have hle'' := sInf_le hmem
                  exact le_trans hle'' hle_rs'
                exact le_trans hle' hle''
              exact hle_k
            have hle_all :
                k x â‰¤ sInf { Î¼ : EReal | f0_plus x â‰¤ Î¼ } := by
              refine le_sInf ?_
              intro Î¼ hÎ¼
              cases Î¼ using EReal.rec with
              | bot =>
                  have hbot : f0_plus x = (âŠ¥ : EReal) := (le_bot_iff.mp hÎ¼)
                  have hforall : âˆ€ Î¼ : â„, k x â‰¤ (Î¼ : EReal) := by
                    intro Î¼
                    have hÎ¼' : f0_plus x â‰¤ (Î¼ : EReal) := by
                      simp [hbot]
                    exact hleÎ¼ Î¼ hÎ¼'
                  have hbotc : k x = (âŠ¥ : EReal) := by
                    apply (EReal.eq_bot_iff_forall_lt _).2
                    intro y
                    have hleÎ¼ : k x â‰¤ ((y - 1 : â„) : EReal) := hforall (y - 1)
                    have hlt : (y - 1 : â„) < y := by linarith
                    have hlt' : ((y - 1 : â„) : EReal) < (y : EReal) :=
                      (EReal.coe_lt_coe_iff).2 hlt
                    exact lt_of_le_of_lt hleÎ¼ hlt'
                  simp [hbotc]
              | top =>
                  exact le_top
              | coe r =>
                  exact hleÎ¼ r hÎ¼
            simpa [sInf_Ici_eq_self] using hle_all
          have hcl_eq : convexFunctionClosure k = k := by
            funext x
            -- use `sInf_insert` and the bound `k x â‰¤ f0_plus x`
            have hset :
                sInf
                  (Set.insert (f0_plus x)
                    { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                        z = rightScalarMultiple f lam x }) =
                  sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x } := by
              have hle0 : sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                z = rightScalarMultiple f lam x } â‰¤ f0_plus x := by
                have hle0' : k x â‰¤ f0_plus x := hle' x
                have hkx := hk_pos_formula' x
                simpa [hkx] using hle0'
              have hS := sInf_insert (s := { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                z = rightScalarMultiple f lam x }) (a := f0_plus x)
              -- `sInf_insert` gives `a âŠ“ sInf S`; use `hle0` to rewrite
              have hmin : (f0_plus x) âŠ“
                  sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x } =
                  sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x } := by
                exact inf_eq_right.mpr hle0
              have hS' :
                  sInf
                    (Set.insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) =
                    min (f0_plus x)
                      (sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                        z = rightScalarMultiple f lam x }) := by
                change
                  sInf
                    (insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) =
                    min (f0_plus x)
                      (sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                        z = rightScalarMultiple f lam x })
                exact hS
              calc
                sInf
                    (Set.insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) =
                    min (f0_plus x)
                      (sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                        z = rightScalarMultiple f lam x }) := hS'
                _ = sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x } := hmin
            -- now finish
            have hkx := hk_pos_formula' x
            -- use the derived formula for `convexFunctionClosure k`
            have hclx :
                convexFunctionClosure k x =
                  sInf
                    (Set.insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) := by
              exact hcl_formula x
            -- combine
            have hkx' :
                k x =
                  sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x } := by
              exact hkx
            calc
              convexFunctionClosure k x =
                  sInf
                    (Set.insert (f0_plus x)
                      { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                          z = rightScalarMultiple f lam x }) := hclx
              _ = sInf { z : EReal | âˆƒ lam : Real, 0 < lam âˆ§
                    z = rightScalarMultiple f lam x } := hset
              _ = k x := hkx'.symm
          have hk_closed :
              ClosedConvexFunction k := by
            -- `convexFunctionClosure k` is lower semicontinuous, and equals `k`.
            have hls : LowerSemicontinuous (convexFunctionClosure k) := by
              -- lower semicontinuous hull is lower semicontinuous
              by_cases hbot' : âˆ€ x, k x â‰  (âŠ¥ : EReal)
              Â· have hEq : convexFunctionClosure k = lowerSemicontinuousHull k := by
                  simp [convexFunctionClosure, hbot']
                have hls' : LowerSemicontinuous (lowerSemicontinuousHull k) := by
                  have hspec :=
                    Classical.choose_spec (exists_lowerSemicontinuousHull (n := n) k)
                  simpa using hspec.1
                simpa [hEq] using hls'
              Â·
                simpa [convexFunctionClosure, hbot'] using
                  (lowerSemicontinuous_const :
                    LowerSemicontinuous (fun _ : Fin n â†’ Real => (âŠ¥ : EReal)))
            have hconv : ConvexFunction k := by
              simpa [ConvexFunction] using hk_conv
            have hls' : LowerSemicontinuous k := by
              simpa [hcl_eq] using hls
            exact âŸ¨hconv, hls'âŸ©
          exact hk_closed
        Â· simpa using hk_pos_formula'

end Section09
end Chap02
