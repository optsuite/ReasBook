/-
Copyright (c) 2026 Zichen Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zichen Wang, Wanli Ma, Yunxi Duan, Zaiwen Wen
-/

import Mathlib
import Books.ConvexAnalysis_Rockafellar_1970.Chapters.Chap02.section06_part5

noncomputable section
open scoped Pointwise

section Chap02
section Section06

/-- Corollary 6.8.1: Let `C` be a non-empty convex set in `R^n`, and let `K` be the convex
cone in `R^{n+1}` generated by `{(1, x) | x âˆˆ C}`. Then `ri K` consists of the pairs
`(Î», x)` such that `Î» > 0` and `x âˆˆ Î» ri C`. -/
theorem euclideanRelativeInterior_convexConeGenerated_eq (n : Nat)
    (C : Set (EuclideanSpace Real (Fin n))) (hC : Convex Real C) (hCne : C.Nonempty) :
    let coords : EuclideanSpace Real (Fin (1 + n)) â†’ (Fin (1 + n) â†’ Real) :=
      EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin (1 + n))
    let first : EuclideanSpace Real (Fin (1 + n)) â†’ Real := fun v => coords v 0
    let tail : EuclideanSpace Real (Fin (1 + n)) â†’ EuclideanSpace Real (Fin n) :=
      fun v =>
        (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin n)).symm
          (fun i => coords v (Fin.natAdd 1 i))
    let S : Set (EuclideanSpace Real (Fin (1 + n))) := {v | first v = 1 âˆ§ tail v âˆˆ C}
    let K : Set (EuclideanSpace Real (Fin (1 + n))) :=
      (ConvexCone.hull Real S : Set (EuclideanSpace Real (Fin (1 + n))))
    euclideanRelativeInterior (1 + n) K =
      {v | 0 < first v âˆ§ tail v âˆˆ (first v) â€¢ euclideanRelativeInterior n C} := by
  classical
  let coords : EuclideanSpace Real (Fin (1 + n)) â†’ (Fin (1 + n) â†’ Real) :=
    EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin (1 + n))
  let first : EuclideanSpace Real (Fin (1 + n)) â†’ Real := fun v => coords v 0
  let tail : EuclideanSpace Real (Fin (1 + n)) â†’ EuclideanSpace Real (Fin n) :=
    fun v =>
      (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin n)).symm
        (fun i => coords v (Fin.natAdd 1 i))
  let S : Set (EuclideanSpace Real (Fin (1 + n))) := {v | first v = 1 âˆ§ tail v âˆˆ C}
  let K : Set (EuclideanSpace Real (Fin (1 + n))) :=
    (ConvexCone.hull Real S : Set (EuclideanSpace Real (Fin (1 + n))))
  let first1 : EuclideanSpace Real (Fin 1) â†’ Real :=
    fun y => (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin 1) y) 0
  let append :
      EuclideanSpace Real (Fin 1) â†’ EuclideanSpace Real (Fin n) â†’
        EuclideanSpace Real (Fin (1 + n)) :=
    fun y z =>
      (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin (1 + n))).symm
        ((Fin.appendIsometry 1 n)
          ((EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin 1)) y,
           (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin n)) z))
  let Cy : EuclideanSpace Real (Fin 1) â†’ Set (EuclideanSpace Real (Fin n)) :=
    fun y => {z | append y z âˆˆ K}
  let D : Set (EuclideanSpace Real (Fin 1)) := {y | (Cy y).Nonempty}
  have hmain :
      euclideanRelativeInterior (1 + n) K =
        {v | 0 < first v âˆ§ tail v âˆˆ (first v) â€¢ euclideanRelativeInterior n C} := by
    have hKconv : Convex Real K := by
      simpa [K] using (ConvexCone.convex (C := ConvexCone.hull Real S))
    have hmem :
        âˆ€ v, v âˆˆ K â†” 0 < first v âˆ§ tail v âˆˆ (first v) â€¢ C := by
      simpa [coords, first, tail, S, K] using
        (mem_K_iff_first_tail (n := n) (C := C) hC)
    have happend_first_tail :
        âˆ€ y z, first (append y z) = first1 y âˆ§ tail (append y z) = z := by
      intro y z
      simpa [coords, first, tail, append, first1] using
        (first_tail_append (n := n) (y := y) (z := z))
    have hCy :
        âˆ€ y, Cy y = {z | 0 < first1 y âˆ§ z âˆˆ first1 y â€¢ C} := by
      intro y
      ext z
      constructor
      Â· intro hz
        have hz' :
            0 < first (append y z) âˆ§ tail (append y z) âˆˆ (first (append y z)) â€¢ C :=
          (hmem (append y z)).1 hz
        rcases happend_first_tail y z with âŸ¨hfirst, htailâŸ©
        refine âŸ¨?_, ?_âŸ©
        Â· simpa [hfirst] using hz'.1
        Â· simpa [hfirst, htail] using hz'.2
      Â· intro hz
        rcases happend_first_tail y z with âŸ¨hfirst, htailâŸ©
        have hz' :
            0 < first (append y z) âˆ§ tail (append y z) âˆˆ (first (append y z)) â€¢ C := by
          refine âŸ¨?_, ?_âŸ©
          Â· simpa [hfirst] using hz.1
          Â· simpa [hfirst, htail] using hz.2
        exact (hmem (append y z)).2 hz'
    have hD : D = {y | 0 < first1 y} := by
      ext y; constructor
      Â· intro hy
        rcases hy with âŸ¨z, hzâŸ©
        have hz' : z âˆˆ {z | 0 < first1 y âˆ§ z âˆˆ first1 y â€¢ C} := by
          simpa [hCy y] using hz
        exact hz'.1
      Â· intro hy
        rcases hCne with âŸ¨x, hxCâŸ©
        have hz : first1 y â€¢ x âˆˆ {z | 0 < first1 y âˆ§ z âˆˆ first1 y â€¢ C} := by
          refine âŸ¨hy, ?_âŸ©
          exact âŸ¨x, hxC, rflâŸ©
        have hz' : first1 y â€¢ x âˆˆ Cy y := by
          simpa [hCy y] using hz
        exact âŸ¨first1 y â€¢ x, hz'âŸ©
    have hD_open : IsOpen D := by
      have hcont : Continuous first1 := by
        simpa [first1] using
          (continuous_apply 0).comp
            (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin 1)).continuous
      simpa [hD, Set.preimage, Set.mem_setOf_eq] using (isOpen_Ioi.preimage hcont)
    have hD_nonempty : D.Nonempty := by
      let y0 : EuclideanSpace Real (Fin 1) :=
        (EuclideanSpace.equiv (ð•œ := Real) (Î¹ := Fin 1)).symm (fun _ => 1)
      refine âŸ¨y0, ?_âŸ©
      have : 0 < first1 y0 := by
        simp [first1, y0]
      simpa [hD] using this
    have hD_span : (affineSpan Real D : Set (EuclideanSpace Real (Fin 1))) = Set.univ := by
      have hspan := IsOpen.affineSpan_eq_top hD_open hD_nonempty
      ext x
      simp [hspan]
    have hriD : euclideanRelativeInterior 1 D = D := by
      calc
        euclideanRelativeInterior 1 D = interior D :=
          euclideanRelativeInterior_eq_interior_of_affineSpan_eq_univ 1 D hD_span
        _ = D := hD_open.interior_eq
    have hriCy :
        âˆ€ y, 0 < first1 y â†’
          euclideanRelativeInterior n (Cy y) = first1 y â€¢ euclideanRelativeInterior n C := by
      intro y hy
      have hCy_eq : Cy y = first1 y â€¢ C := by
        ext z
        simp [hCy y, hy]
      simpa [hCy_eq] using (euclideanRelativeInterior_smul n C hC (first1 y))
    have hsection :
        âˆ€ y z,
          append y z âˆˆ euclideanRelativeInterior (1 + n) K â†”
            y âˆˆ euclideanRelativeInterior 1 D âˆ§ z âˆˆ euclideanRelativeInterior n (Cy y) := by
      intro y z
      simpa [append, Cy, D] using
        (euclideanRelativeInterior_mem_iff_relativeInterior_section (m := 1) (p := n) (C := K)
          hKconv y z)
    ext v; constructor
    Â· intro hv
      let yz := (appendAffineEquiv 1 n).symm v
      let y := yz.1
      let z := yz.2
      have hv_append : append y z = v := by
        have h1 : append y z = appendAffineEquiv 1 n (y, z) := by
          simp [append, appendAffineEquiv_apply]
        have h2 : appendAffineEquiv 1 n (y, z) = v := by
          simp [y, z, yz]
        exact h1.trans h2
      have hfirst_tail : first v = first1 y âˆ§ tail v = z := by
        simpa [hv_append] using (happend_first_tail y z)
      have hv' : append y z âˆˆ euclideanRelativeInterior (1 + n) K := by
        simpa [hv_append] using hv
      rcases (hsection y z).1 hv' with âŸ¨hyD, hzCyâŸ©
      have hyD' : y âˆˆ D := by
        simpa [hriD] using hyD
      have hypos : 0 < first1 y := by
        have : y âˆˆ {y | 0 < first1 y} := by
          simpa [hD] using hyD'
        simpa using this
      have hzCy' : z âˆˆ first1 y â€¢ euclideanRelativeInterior n C := by
        have hri := hriCy y hypos
        simpa [hri] using hzCy
      have hpos : 0 < first v := by
        simpa [hfirst_tail.1] using hypos
      have htail : tail v âˆˆ first v â€¢ euclideanRelativeInterior n C := by
        simpa [hfirst_tail.1, hfirst_tail.2] using hzCy'
      exact âŸ¨hpos, htailâŸ©
    Â· rintro âŸ¨hpos, htailâŸ©
      let yz := (appendAffineEquiv 1 n).symm v
      let y := yz.1
      let z := yz.2
      have hv_append : append y z = v := by
        have h1 : append y z = appendAffineEquiv 1 n (y, z) := by
          simp [append, appendAffineEquiv_apply]
        have h2 : appendAffineEquiv 1 n (y, z) = v := by
          simp [y, z, yz]
        exact h1.trans h2
      have hfirst_tail : first v = first1 y âˆ§ tail v = z := by
        simpa [hv_append] using (happend_first_tail y z)
      have hypos : 0 < first1 y := by
        simpa [hfirst_tail.1] using hpos
      have hyD : y âˆˆ euclideanRelativeInterior 1 D := by
        have : y âˆˆ D := by
          have : y âˆˆ {y | 0 < first1 y} := by
            simpa using hypos
          simpa [hD] using this
        simpa [hriD] using this
      have hzCy : z âˆˆ euclideanRelativeInterior n (Cy y) := by
        have hz' : z âˆˆ first1 y â€¢ euclideanRelativeInterior n C := by
          simpa [hfirst_tail.1, hfirst_tail.2] using htail
        have hri := hriCy y hypos
        simpa [hri] using hz'
      have hv' : append y z âˆˆ euclideanRelativeInterior (1 + n) K := by
        exact (hsection y z).2 âŸ¨hyD, hzCyâŸ©
      simpa [hv_append] using hv'
  simpa [coords, first, tail, S, K] using hmain

end Section06
end Chap02
