/-
Copyright (c) 2026 Zichen Wang. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Zichen Wang, Wanli Ma, Yijie Wang, Yuhao Jiang, Zaiwen Wen
-/

import Mathlib

import Books.ConvexAnalysis_Rockafellar_1970.Chapters.Chap03.section14_part2

section Chap03
section Section14

open scoped Pointwise
open scoped Topology

variable {E : Type*} [AddCommGroup E] [Module ‚Ñù E]

-- The weak topology on the algebraic dual induced by evaluation (see also `section14_part1`).
noncomputable local instance section14_instTopologicalSpace_dualWeak_part3 :
    TopologicalSpace (Module.Dual ‚Ñù E) :=
  WeakBilin.instTopologicalSpace
    (B := (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)).flip)

-- Basic topological vector space structure on the dual, induced by the weak topology above.
noncomputable local instance section14_instIsTopologicalAddGroup_dualWeak_part3 :
    IsTopologicalAddGroup (Module.Dual ‚Ñù E) :=
  WeakBilin.instIsTopologicalAddGroup
    (B := (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)).flip)

noncomputable local instance section14_instContinuousSMul_dualWeak_part3 :
    ContinuousSMul ‚Ñù (Module.Dual ‚Ñù E) :=
  WeakBilin.instContinuousSMul (B := (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)).flip)

noncomputable local instance section14_instLocallyConvexSpace_dualWeak_part3 :
    LocallyConvexSpace ‚Ñù (Module.Dual ‚Ñù E) :=
  WeakBilin.locallyConvexSpace (B := (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)).flip)

/-- If `y‚òÖ` is in the recession cone of `f*` and `f*` is finite somewhere, then `y‚òÖ` is
nonpositive on `erealDom f`. -/
lemma section14_le_zero_on_dom_of_mem_recessionCone_fenchelConjugate {f : E ‚Üí EReal}
    (hf : ProperERealFunction f) {yStar : Module.Dual ‚Ñù E}
    (hy :
      yStar ‚àà
        recessionConeEReal
          (F := Module.Dual ‚Ñù E)
          (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f))
    (hxStar0 :
      ‚àÉ xStar0 : Module.Dual ‚Ñù E,
        fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f xStar0 < ‚ä§) :
    ‚àÄ x, x ‚àà erealDom f ‚Üí yStar x ‚â§ 0 := by
  classical
  set p : E ‚Üí‚Çó[‚Ñù] (Module.Dual ‚Ñù E) ‚Üí‚Çó[‚Ñù] ‚Ñù :=
    (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))
  set g : Module.Dual ‚Ñù E ‚Üí EReal := fenchelConjugateBilin p f
  have hneBot : ‚àÄ xStar : Module.Dual ‚Ñù E, g xStar ‚â† ‚ä• := by
    intro xStar
    simpa [g, p] using (section14_fenchelConjugate_ne_bot (E := E) (f := f) hf xStar)

  rcases hxStar0 with ‚ü®xStar0, hxStar0lt‚ü©
  have hxStar0dom : xStar0 ‚àà erealDom g := by simpa [erealDom, g, p] using hxStar0lt

  have hind :
      ‚àÄ n : ‚Ñï,
        g (xStar0 + n ‚Ä¢ yStar) ‚â§ g xStar0 ‚àß xStar0 + n ‚Ä¢ yStar ‚àà erealDom g := by
    intro n
    induction n with
    | zero =>
        simp [hxStar0dom]
    | succ n ih =>
        have hxNdom : xStar0 + n ‚Ä¢ yStar ‚àà erealDom g := ih.2
        have hstep :
            g ((xStar0 + n ‚Ä¢ yStar) + yStar) ‚â§ g (xStar0 + n ‚Ä¢ yStar) ‚àß
              (xStar0 + n ‚Ä¢ yStar) + yStar ‚àà erealDom g := by
          simpa [g, p] using
            (section14_step_le_of_mem_recessionCone (g := g) (x := xStar0 + n ‚Ä¢ yStar)
                  (y := yStar) hy hxNdom)
        refine ‚ü®?_, ?_‚ü©
        ¬∑
          have : g ((xStar0 + n ‚Ä¢ yStar) + yStar) ‚â§ g xStar0 := hstep.1.trans ih.1
          simpa [succ_nsmul, add_assoc] using this
        ¬∑
          have : (xStar0 + n ‚Ä¢ yStar) + yStar ‚àà erealDom g := hstep.2
          simpa [succ_nsmul, add_assoc] using this

  intro x hx
  rcases section14_eq_coe_of_lt_top (z := f x) hx (hf.1 x) with ‚ü®rf, hrf‚ü©
  rcases section14_eq_coe_of_lt_top (z := g xStar0) (by simpa [g, p] using hxStar0lt)
      (hneBot xStar0) with ‚ü®rg, hrg‚ü©

  have hmul_le : ‚àÄ n : ‚Ñï, (n : ‚Ñù) * yStar x ‚â§ rg + rf - xStar0 x := by
    intro n
    have hle1 :
        (((xStar0 + n ‚Ä¢ yStar) x : EReal) - f x) ‚â§ g xStar0 := by
      have hleSup :
          (((xStar0 + n ‚Ä¢ yStar) x : EReal) - f x) ‚â§ g (xStar0 + n ‚Ä¢ yStar) := by
        -- Use the definition of the Fenchel conjugate at a single point.
        have :
            ((p x (xStar0 + n ‚Ä¢ yStar) : EReal) - f x) ‚â§
              sSup (Set.range fun z : E => (p z (xStar0 + n ‚Ä¢ yStar) : EReal) - f z) :=
          le_sSup ‚ü®x, rfl‚ü©
        simpa [g, fenchelConjugateBilin, p] using this
      exact hleSup.trans (hind n).1
    have hle2 :
        ((xStar0 x + (n : ‚Ñù) * yStar x - rf : ‚Ñù) : EReal) ‚â§ (rg : EReal) := by
      simpa [g, p, hrf, hrg, LinearMap.add_apply, nsmul_eq_mul, sub_eq_add_neg] using hle1
    have hreal : xStar0 x + (n : ‚Ñù) * yStar x - rf ‚â§ rg :=
      (EReal.coe_le_coe_iff).1 hle2
    linarith

  exact section14_real_nonpos_of_nat_mul_le (r := yStar x) (C := rg + rf - xStar0 x) hmul_le

/-- Theorem 14.2. Let `f` be a proper convex function. The polar of the convex cone generated by
`dom f` is the recession cone of the Fenchel conjugate `f*`. Dually, if `f` is closed, the polar
of the recession cone of `f` is the closure of the convex cone generated by `dom f*`. -/
theorem polar_coneGenerated_dom_eq_recessionCone_fenchelConjugate {f : E ‚Üí EReal}
    (hf : ProperConvexERealFunction (F := E) f)
    (hdom :
      ‚àÉ xStar0 : Module.Dual ‚Ñù E,
        fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f xStar0 < ‚ä§) :
    polarCone (E := E) ((ConvexCone.hull ‚Ñù (erealDom f) : ConvexCone ‚Ñù E) : Set E) =
      recessionConeEReal
        (F := Module.Dual ‚Ñù E)
        (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f) := by
  classical
  ext yStar
  constructor
  ¬∑ intro hy
    have hyDom : ‚àÄ x, x ‚àà erealDom f ‚Üí yStar x ‚â§ 0 :=
      (section14_mem_polarCone_hull_erealDom_iff (E := E) (f := f) (œÜ := yStar)).1 hy
    refine (section14_mem_recessionConeEReal_iff
          (g := fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)
          (y := yStar)).2 ?_
    intro xStar _
    have hle :
        fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f (xStar + yStar) ‚â§
          fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f xStar :=
      section14_fenchelConjugate_add_le_of_le_zero_on_dom (E := E) (f := f) (yStar := yStar)
        hyDom xStar
    -- `a - b ‚â§ 0 ‚Üî a ‚â§ b` on `EReal`.
    exact (EReal.sub_nonpos).2 hle
  ¬∑ intro hy
    have hyDom : ‚àÄ x, x ‚àà erealDom f ‚Üí yStar x ‚â§ 0 := by
      exact
        section14_le_zero_on_dom_of_mem_recessionCone_fenchelConjugate (E := E) (f := f)
          (hf := hf.1) (yStar := yStar) hy hdom
    exact (section14_mem_polarCone_hull_erealDom_iff (E := E) (f := f) (œÜ := yStar)).2 hyDom

/-- The polar cone of a set, packaged as a `ConvexCone`, so that we can use `ConvexCone.hull`
minimality arguments. -/
def section14_polarConeConvexCone (K : Set E) : ConvexCone ‚Ñù (Module.Dual ‚Ñù E) where
  carrier := polarCone (E := E) K
  smul_mem' a ha œÜ hœÜ := by
    refine (mem_polarCone_iff (E := E) (K := K) (œÜ := a ‚Ä¢ œÜ)).2 ?_
    intro x hx
    have hœÜx : œÜ x ‚â§ 0 := (mem_polarCone_iff (E := E) (K := K) (œÜ := œÜ)).1 hœÜ x hx
    simpa [LinearMap.smul_apply, smul_eq_mul] using
      mul_nonpos_of_nonneg_of_nonpos (le_of_lt ha) hœÜx
  add_mem' œÜ‚ÇÅ hœÜ‚ÇÅ œÜ‚ÇÇ hœÜ‚ÇÇ := by
    refine (mem_polarCone_iff (E := E) (K := K) (œÜ := œÜ‚ÇÅ + œÜ‚ÇÇ)).2 ?_
    intro x hx
    have h‚ÇÅ : œÜ‚ÇÅ x ‚â§ 0 := (mem_polarCone_iff (E := E) (K := K) (œÜ := œÜ‚ÇÅ)).1 hœÜ‚ÇÅ x hx
    have h‚ÇÇ : œÜ‚ÇÇ x ‚â§ 0 := (mem_polarCone_iff (E := E) (K := K) (œÜ := œÜ‚ÇÇ)).1 hœÜ‚ÇÇ x hx
    simpa [LinearMap.add_apply] using add_nonpos h‚ÇÅ h‚ÇÇ

/-- If `x‚òÖ` is in the effective domain of `f*`, then `x‚òÖ` lies in the polar cone of the recession
cone of `f`. -/
lemma section14_mem_polar_recessionCone_of_mem_dom_fenchelConjugate {f : E ‚Üí EReal}
    (hf : ProperERealFunction f) {xStar : Module.Dual ‚Ñù E}
    (hxStar :
      xStar ‚àà
        erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
    xStar ‚àà polarCone (E := E) (recessionConeEReal (F := E) f) := by
  classical
  -- Unpack polar membership: show `xStar y ‚â§ 0` for all recession directions `y`.
  refine (mem_polarCone_iff (E := E) (K := recessionConeEReal (F := E) f) (œÜ := xStar)).2 ?_
  intro y hy
  -- Choose a finite point `x0` of `f` from properness.
  rcases hf.2 with ‚ü®x0, hx0neTop‚ü©
  have hx0dom : x0 ‚àà erealDom f := lt_top_iff_ne_top.2 hx0neTop
  rcases section14_eq_coe_of_lt_top (z := f x0) hx0dom (hf.1 x0) with ‚ü®r0, hr0‚ü©

  set p : E ‚Üí‚Çó[‚Ñù] (Module.Dual ‚Ñù E) ‚Üí‚Çó[‚Ñù] ‚Ñù :=
    (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))
  set g : Module.Dual ‚Ñù E ‚Üí EReal := fenchelConjugateBilin p f
  have hneBot : ‚àÄ z : Module.Dual ‚Ñù E, g z ‚â† ‚ä• := by
    intro z
    simpa [g, p] using (section14_fenchelConjugate_ne_bot (E := E) (f := f) hf z)
  rcases section14_eq_coe_of_lt_top (z := g xStar) (by simpa [erealDom, g, p] using hxStar)
      (hneBot xStar) with ‚ü®rg, hrg‚ü©

  -- Iterate the recession step to get uniform bounds along `n ‚Ä¢ y`.
  have hind :
      ‚àÄ n : ‚Ñï, f (x0 + n ‚Ä¢ y) ‚â§ f x0 ‚àß x0 + n ‚Ä¢ y ‚àà erealDom f := by
    intro n
    induction n with
    | zero =>
        simp [hx0dom]
    | succ n ih =>
        have hstep :=
          section14_step_le_of_mem_recessionCone (g := f) (x := x0 + n ‚Ä¢ y) (y := y) hy ih.2
        refine ‚ü®?_, ?_‚ü©
        ¬∑
          have : f ((x0 + n ‚Ä¢ y) + y) ‚â§ f x0 := hstep.1.trans ih.1
          simpa [succ_nsmul, add_assoc] using this
        -- `x0 + (n+1)‚Ä¢y = (x0 + n‚Ä¢y) + y`.
        simpa [succ_nsmul, add_assoc] using hstep.2

  -- Use the Fenchel conjugate bound at `x0 + n‚Ä¢y` to bound `(n : ‚Ñù) * (xStar y)`.
  have hmul_le : ‚àÄ n : ‚Ñï, (n : ‚Ñù) * xStar y ‚â§ rg + r0 - xStar x0 := by
    intro n
    set xn : E := x0 + n ‚Ä¢ y
    have hxn_dom : xn ‚àà erealDom f := by simpa [xn] using (hind n).2
    -- `xStar xn - f xn ‚â§ g xStar`.
    have hle_xn : ((p xn xStar : EReal) - f xn) ‚â§ g xStar := by
      have :
          (p xn xStar : EReal) - f xn ‚â§ sSup (Set.range fun z : E => (p z xStar : EReal) - f z) :=
        le_sSup ‚ü®xn, rfl‚ü©
      simpa [g, fenchelConjugateBilin, p] using this
    -- Coerce `f xn` to a real `rn` and use `f xn ‚â§ f x0` to compare to `r0`.
    rcases section14_eq_coe_of_lt_top (z := f xn) hxn_dom (hf.1 xn) with ‚ü®rn, hrn‚ü©
    have hrn_le : rn ‚â§ r0 := by
      have : (f xn : EReal) ‚â§ f x0 := (hind n).1
      have : ((rn : ‚Ñù) : EReal) ‚â§ (r0 : EReal) := by simpa [hrn, hr0, xn] using this
      exact (EReal.coe_le_coe_iff).1 this
    -- Turn the Fenchel bound into a real inequality `xStar xn - rn ‚â§ rg`.
    have hreal_xn_rn : xStar xn - rn ‚â§ rg := by
      have hE : ((xStar xn - rn : ‚Ñù) : EReal) ‚â§ g xStar := by
        simpa [xn, p, hrn, LinearMap.apply‚Çó, sub_eq_add_neg] using hle_xn
      have hE' : ((xStar xn - rn : ‚Ñù) : EReal) ‚â§ (rg : EReal) := by
        simpa [hrg] using hE
      exact (EReal.coe_le_coe_iff).1 hE'
    -- Since `rn ‚â§ r0`, get `xStar xn - r0 ‚â§ rg`.
    have hreal_xn_r0 : xStar xn - r0 ‚â§ rg := by
      have : xStar xn - r0 ‚â§ xStar xn - rn := by
        -- Subtracting a larger number yields a smaller result.
        simpa [sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using
          (sub_le_sub_left hrn_le (xStar xn))
      exact this.trans hreal_xn_rn
    -- Expand `xStar xn` and solve for `(n : ‚Ñù) * xStar y`.
    have hxStar_xn : xStar xn = xStar x0 + (n : ‚Ñù) * xStar y := by
      simp [xn, map_add, map_nsmul, nsmul_eq_mul]
    linarith [hreal_xn_r0, hxStar_xn]

  -- Conclude `xStar y ‚â§ 0` from the uniform bound on natural multiples.
  exact section14_real_nonpos_of_nat_mul_le (r := xStar y) (C := rg + r0 - xStar x0) hmul_le

/-- The closed conic hull of `dom f*` is contained in the polar of the recession cone of `f`. -/
lemma section14_closure_coneHull_dom_fenchelConjugate_subset_polar_recessionCone [TopologicalSpace E]
    {f : E ‚Üí EReal} (hf : ProperConvexERealFunction (F := E) f) :
    closure
        ((ConvexCone.hull ‚Ñù
              (erealDom
                (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
              ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) ‚äÜ
      polarCone (E := E) (recessionConeEReal (F := E) f) := by
  classical
  -- First show the (non-closed) conic hull is contained.
  have hHull :
      ((ConvexCone.hull ‚Ñù
            (erealDom
              (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
          ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) ‚äÜ
        polarCone (E := E) (recessionConeEReal (F := E) f) := by
    -- Use the hull-minimality into the convex cone `polarConeConvexCone`.
    have :
        (ConvexCone.hull ‚Ñù
              (erealDom
                (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
            ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) ‚â§
          section14_polarConeConvexCone (E := E) (K := recessionConeEReal (F := E) f) := by
      refine (ConvexCone.hull_le_iff (C := section14_polarConeConvexCone (E := E)
          (K := recessionConeEReal (F := E) f))).2 ?_
      intro xStar hxStar
      exact
        section14_mem_polar_recessionCone_of_mem_dom_fenchelConjugate (E := E) (f := f) hf.1
          hxStar
    exact this
  -- Now use closedness of the polar cone in the weak topology to absorb the closure.
  have hclosed : IsClosed (polarCone (E := E) (recessionConeEReal (F := E) f)) :=
    section14_isClosed_polarCone (E := E) (K := recessionConeEReal (F := E) f)
  exact closure_minimal hHull hclosed

/-- Any continuous linear functional on `Module.Dual ‚Ñù E` equipped with the weak topology induced by
evaluation is itself an evaluation at some `y : E`. -/
lemma section14_exists_eval_of_continuousLinearMap_dualWeak
    (‚Ñì : (Module.Dual ‚Ñù E) ‚ÜíL[‚Ñù] ‚Ñù) :
    ‚àÉ y : E, ‚àÄ xStar : Module.Dual ‚Ñù E, ‚Ñì xStar = xStar y := by
  classical
  let evalLM : E ‚Üí‚Çó[‚Ñù] (Module.Dual ‚Ñù E ‚Üí‚Çó[‚Ñù] ‚Ñù) :=
    (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))
  have ht :
      (section14_instTopologicalSpace_dualWeak_part3 (E := E) : TopologicalSpace (Module.Dual ‚Ñù E)) =
        ‚®Ö y : E, TopologicalSpace.induced (evalLM y) inferInstance := by
    -- Expand the weak topology as the infimum of the induced topologies from the evaluations.
    simp [section14_instTopologicalSpace_dualWeak_part3, WeakBilin.instTopologicalSpace,
      Pi.topologicalSpace, evalLM, induced_iInf, induced_compose]
    refine iInf_congr fun y => ?_
    -- `Pi.topologicalSpace` uses the default topology on `‚Ñù`.
    change
      TopologicalSpace.induced
          ((fun f : E ‚Üí ‚Ñù => f y) ‚àò fun x : Module.Dual ‚Ñù E => fun z : E => x z)
          (inferInstance : TopologicalSpace ‚Ñù) =
        TopologicalSpace.induced (fun x : Module.Dual ‚Ñù E => x y) (inferInstance : TopologicalSpace ‚Ñù)
    rfl
  have hcont :
      @Continuous (Module.Dual ‚Ñù E) ‚Ñù
        (‚®Ö y : E, TopologicalSpace.induced (evalLM y) inferInstance) inferInstance
        (fun xStar : Module.Dual ‚Ñù E => ‚Ñì xStar) := by
    have h0 :
        @Continuous (Module.Dual ‚Ñù E) ‚Ñù
          (section14_instTopologicalSpace_dualWeak_part3 (E := E) : TopologicalSpace (Module.Dual ‚Ñù E))
          inferInstance (fun xStar : Module.Dual ‚Ñù E => ‚Ñì xStar) :=
      ‚Ñì.continuous
    simpa [ht] using h0
  have hmem :
      (‚Ñì : Module.Dual ‚Ñù E ‚Üí‚Çó[‚Ñù] ‚Ñù) ‚àà Submodule.span ‚Ñù (Set.range evalLM) := by
    -- Continuous linear maps for the weak topology lie in the span of the evaluations.
    exact
      (LinearMap.mem_span_iff_continuous (f := fun y : E => evalLM y)
            (œÜ := (‚Ñì : Module.Dual ‚Ñù E ‚Üí‚Çó[‚Ñù] ‚Ñù))).2 hcont
  have hspan_le_range : Submodule.span ‚Ñù (Set.range evalLM) ‚â§ LinearMap.range evalLM := by
    refine Submodule.span_le.2 ?_
    rintro _ ‚ü®y, rfl‚ü©
    exact ‚ü®y, rfl‚ü©
  have hrange : (‚Ñì : Module.Dual ‚Ñù E ‚Üí‚Çó[‚Ñù] ‚Ñù) ‚àà LinearMap.range evalLM :=
    hspan_le_range hmem
  rcases hrange with ‚ü®y, hy‚ü©
  refine ‚ü®y, ?_‚ü©
  intro xStar
  -- Unpack the identity `evalLM y = ‚Ñì` pointwise.
  have := congrArg (fun m : Module.Dual ‚Ñù E ‚Üí‚Çó[‚Ñù] ‚Ñù => m xStar) hy
  simpa [evalLM, LinearMap.apply‚Çó] using this.symm

/-- If `x‚òÖ` is not in the (weak) closure of the conic hull of `dom f*`, then one can separate it
from that cone by evaluation at some `y : E`. -/
lemma section14_exists_eval_sep_of_not_mem_closure_coneHull_dom_fenchelConjugate {f : E ‚Üí EReal}
    {xStar : Module.Dual ‚Ñù E}
    (hDom :
      (erealDom
          (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)).Nonempty)
    (hxStar :
      xStar ‚àâ
        closure
          ((ConvexCone.hull ‚Ñù
                (erealDom
                  (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
                ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E))) :
    ‚àÉ y : E,
      (‚àÄ z : Module.Dual ‚Ñù E,
          z ‚àà
              closure
                ((ConvexCone.hull ‚Ñù
                      (erealDom
                        (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
                    ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) ‚Üí
            z y ‚â§ 0) ‚àß
        0 < xStar y := by
  classical
  set K : ConvexCone ‚Ñù (Module.Dual ‚Ñù E) :=
    ConvexCone.hull ‚Ñù
      (erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f))
  have hKne : (K : Set (Module.Dual ‚Ñù E)).Nonempty := by
    rcases hDom with ‚ü®xStar0, hxStar0‚ü©
    refine ‚ü®xStar0, ?_‚ü©
    exact (ConvexCone.subset_hull (s :=
      erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f))) hxStar0
  have hKcl_ne : ((K.closure : ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)).Nonempty :=
    by simpa [ConvexCone.coe_closure] using hKne.closure
  have hKcl_closed :
      IsClosed ((K.closure : ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) := by
    simp [ConvexCone.coe_closure]
  rcases
      (ConvexCone.canLift (ùïú := ‚Ñù) (E := Module.Dual ‚Ñù E)).prf K.closure
        ‚ü®hKcl_ne, hKcl_closed‚ü© with
    ‚ü®C, hCeq‚ü©
  have hxC : xStar ‚àâ (C : Set (Module.Dual ‚Ñù E)) := by
    intro hxC
    have hxC' : xStar ‚àà ((‚ÜëC : ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) := by
      simpa using hxC
    have hxKcl : xStar ‚àà (K.closure : Set (Module.Dual ‚Ñù E)) := by
      simpa [hCeq] using hxC'
    have hxcl' : xStar ‚àà closure (K : Set (Module.Dual ‚Ñù E)) := by
      simpa [ConvexCone.coe_closure] using hxKcl
    exact hxStar (by simpa [K] using hxcl')
  obtain ‚ü®fSep, hfSepC, hfSepx‚ü© :=
    ProperCone.hyperplane_separation_point (C := C) (x‚ÇÄ := xStar) hxC
  -- Flip the sign so that the separator is nonpositive on the cone and strictly positive at `xStar`.
  let ‚Ñì : (Module.Dual ‚Ñù E) ‚ÜíL[‚Ñù] ‚Ñù := -fSep
  rcases section14_exists_eval_of_continuousLinearMap_dualWeak (E := E) (‚Ñì := ‚Ñì) with ‚ü®y, hy‚ü©
  refine ‚ü®y, ?_, ?_‚ü©
  ¬∑ intro z hz
    have hz' : z ‚àà (C : Set (Module.Dual ‚Ñù E)) := by
      have hzKcl : z ‚àà (K.closure : Set (Module.Dual ‚Ñù E)) := by
        -- `hz : z ‚àà closure (K : Set _)` by unfolding `K`.
        simpa [K] using hz
      have hzKcl' : z ‚àà ((K.closure : ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) :=
        hzKcl
      have : z ‚àà ((‚ÜëC : ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) := by
        simpa [hCeq] using hzKcl'
      simpa using this
    have hfnonneg : 0 ‚â§ fSep z := hfSepC z hz'
    have : ‚Ñì z ‚â§ 0 := by
      -- `‚Ñì z = - fSep z`.
      simpa [‚Ñì] using (neg_nonpos.2 hfnonneg)
    simpa [hy z, ‚Ñì] using this
  ¬∑ have : 0 < ‚Ñì xStar := by
      have : fSep xStar < 0 := hfSepx
      simpa [‚Ñì] using (neg_pos.2 this)
    simpa [hy xStar] using this

/-- A Hahn‚ÄìBanach separation gadget for a proper convex lower semicontinuous function: given a
point `(x0, Œº0)` strictly below the epigraph of `f`, produce a continuous affine minorant
`x ‚Ü¶ x‚òÖ x - Œ≤` that lies below `f` everywhere and is strictly above `Œº0` at `x0`. In particular,
the Fenchel conjugate is finite at `x‚òÖ`. -/
lemma section14_exists_affine_minorant_strict_of_lt [TopologicalSpace E] [IsTopologicalAddGroup E]
    [ContinuousSMul ‚Ñù E] [LocallyConvexSpace ‚Ñù E] {f : E ‚Üí EReal}
    (hf : ProperConvexERealFunction (F := E) f) (hf_closed : LowerSemicontinuous f) {x0 : E}
    {Œº0 : ‚Ñù} (hŒº0 : (Œº0 : EReal) < f x0) :
    ‚àÉ (xStar : Module.Dual ‚Ñù E) (Œ≤ : ‚Ñù),
      (‚àÄ x : E, ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ f x) ‚àß (Œº0 : ‚Ñù) < xStar x0 - Œ≤ ‚àß
        fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f xStar < ‚ä§ := by
  classical
  -- Work with the real epigraph of `f` in `E √ó ‚Ñù`.
  let epi : Set (E √ó ‚Ñù) := {p | f p.1 ‚â§ (p.2 : EReal)}
  have hEpiConvex : Convex ‚Ñù epi := by
    intro p hp q hq a b ha hb hab
    have hp' : f p.1 ‚â§ (p.2 : EReal) := hp
    have hq' : f q.1 ‚â§ (q.2 : EReal) := hq
    have hfconv : ConvexERealFunction (F := E) f := hf.2
    have hfconv' := hfconv (x := p.1) (y := q.1) (a := a) (b := b) ha hb hab
    have haE : (0 : EReal) ‚â§ (a : EReal) := by simpa [EReal.coe_nonneg] using ha
    have hbE : (0 : EReal) ‚â§ (b : EReal) := by simpa [EReal.coe_nonneg] using hb
    have hmul_p : (a : EReal) * f p.1 ‚â§ (a : EReal) * (p.2 : EReal) :=
      mul_le_mul_of_nonneg_left hp' haE
    have hmul_q : (b : EReal) * f q.1 ‚â§ (b : EReal) * (q.2 : EReal) :=
      mul_le_mul_of_nonneg_left hq' hbE
    have hsum :
        (a : EReal) * f p.1 + (b : EReal) * f q.1 ‚â§
          (a : EReal) * (p.2 : EReal) + (b : EReal) * (q.2 : EReal) :=
      add_le_add hmul_p hmul_q
    have hfst : (a ‚Ä¢ p + b ‚Ä¢ q).1 = a ‚Ä¢ p.1 + b ‚Ä¢ q.1 := by rfl
    have hsnd : (a ‚Ä¢ p + b ‚Ä¢ q).2 = a ‚Ä¢ p.2 + b ‚Ä¢ q.2 := by rfl
    have hle :
        f (a ‚Ä¢ p.1 + b ‚Ä¢ q.1) ‚â§ (a : EReal) * (p.2 : EReal) + (b : EReal) * (q.2 : EReal) :=
      hfconv'.trans hsum
    have hrhs :
        (a : EReal) * (p.2 : EReal) + (b : EReal) * (q.2 : EReal) =
          ((a ‚Ä¢ p.2 + b ‚Ä¢ q.2 : ‚Ñù) : EReal) := by
      simp [smul_eq_mul]
    have hle' : f (a ‚Ä¢ p.1 + b ‚Ä¢ q.1) ‚â§ ((a ‚Ä¢ p.2 + b ‚Ä¢ q.2 : ‚Ñù) : EReal) :=
      hle.trans_eq hrhs
    have : f ((a ‚Ä¢ p + b ‚Ä¢ q).1) ‚â§ ((a ‚Ä¢ p + b ‚Ä¢ q).2 : EReal) := by
      simpa [hfst, hsnd] using hle'
    simpa [epi] using this
  have hEpiClosed : IsClosed epi := by
    -- Use the closedness of the epigraph of `f : E ‚Üí EReal` and pull back along `‚Ñù ‚Üí EReal`.
    let epi' : Set (E √ó EReal) := {p | f p.1 ‚â§ p.2}
    have hEpi'Closed : IsClosed epi' := hf_closed.isClosed_epigraph
    have hcont :
        Continuous (fun p : E √ó ‚Ñù => (p.1, (p.2 : EReal))) :=
      Continuous.prodMk continuous_fst (continuous_coe_real_ereal.comp continuous_snd)
    have hpre :
        epi = (fun p : E √ó ‚Ñù => (p.1, (p.2 : EReal))) ‚Åª¬π' epi' := by
      ext p
      rfl
    simpa [hpre, epi'] using hEpi'Closed.preimage hcont

  have hx0not : (x0, Œº0) ‚àâ epi := by
    intro hx0
    have hx0' : f x0 ‚â§ (Œº0 : EReal) := by simpa [epi] using hx0
    exact (not_le_of_gt hŒº0) hx0'

  -- Separate the point `(x0, Œº0)` from the epigraph.
  obtain ‚ü®L0, u0, hL0u0, hu0‚ü© :=
    geometric_hahn_banach_closed_point (E := E √ó ‚Ñù) (s := epi) (x := (x0, Œº0)) hEpiConvex
      hEpiClosed hx0not

  -- Pick a finite point `x1` of `f` from properness; it will control the vertical coefficients.
  rcases hf.1.2 with ‚ü®x1, hx1neTop‚ü©
  have hx1dom : x1 ‚àà erealDom f := lt_top_iff_ne_top.2 hx1neTop
  rcases section14_eq_coe_of_lt_top (z := f x1) hx1dom (hf.1.1 x1) with ‚ü®r1, hr1‚ü©

  -- A separator bounded above on the epigraph must have nonpositive `‚Ñù`-coefficient.
  have ht_nonpos (L : StrongDual ‚Ñù (E √ó ‚Ñù)) (u : ‚Ñù) (hLu : ‚àÄ p ‚àà epi, L p < u) :
      L ((0 : E), (1 : ‚Ñù)) ‚â§ 0 := by
    by_contra ht
    have htpos : 0 < L ((0 : E), (1 : ‚Ñù)) := lt_of_not_ge ht
    have hx1mem : (x1, r1) ‚àà epi := by
      have : f x1 ‚â§ (r1 : EReal) := by simp [hr1]
      simpa [epi] using this
    have hbase : L (x1, r1) < u := hLu (x1, r1) hx1mem
    obtain ‚ü®n : ‚Ñï, hn‚ü© :
        ‚àÉ n : ‚Ñï, (u - L (x1, r1)) / L ((0 : E), (1 : ‚Ñù)) < n :=
      exists_nat_gt ((u - L (x1, r1)) / L ((0 : E), (1 : ‚Ñù)))
    have hmul : u - L (x1, r1) < (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) := by
      have : (u - L (x1, r1)) / L ((0 : E), (1 : ‚Ñù)) < (n : ‚Ñù) := by simpa using hn
      exact (div_lt_iff‚ÇÄ htpos).1 this
    have hn0 : (0 : ‚Ñù) ‚â§ (n : ‚Ñù) := by exact_mod_cast (Nat.cast_nonneg n)
    have hx1memn : (x1, r1 + (n : ‚Ñù)) ‚àà epi := by
      have : (r1 : EReal) ‚â§ ((r1 + (n : ‚Ñù) : ‚Ñù) : EReal) :=
        EReal.coe_le_coe (by linarith [hn0])
      have : f x1 ‚â§ ((r1 + (n : ‚Ñù) : ‚Ñù) : EReal) := by simpa [hr1] using this
      simpa [epi] using this
    have hlt : L (x1, r1 + (n : ‚Ñù)) < u := hLu (x1, r1 + (n : ‚Ñù)) hx1memn
    have hLr :
        L (x1, r1 + (n : ‚Ñù)) =
          L (x1, r1) + (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) := by
      have hr : (x1, r1 + (n : ‚Ñù)) = (x1, r1) + ((0 : E), (n : ‚Ñù)) := by
        ext <;> simp
      have hn : ((0 : E), (n : ‚Ñù)) = (n : ‚Ñù) ‚Ä¢ ((0 : E), (1 : ‚Ñù)) := by
        ext <;> simp [Prod.smul_mk, smul_eq_mul]
      have h0 : L ((0 : E), (n : ‚Ñù)) = (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) := by
        calc
          L ((0 : E), (n : ‚Ñù)) = L ((n : ‚Ñù) ‚Ä¢ ((0 : E), (1 : ‚Ñù))) := congrArg L hn
          _ = (n : ‚Ñù) ‚Ä¢ L ((0 : E), (1 : ‚Ñù)) := by
            simpa using (map_smul L (n : ‚Ñù) ((0 : E), (1 : ‚Ñù)))
          _ = (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) := by simp [smul_eq_mul]
      calc
        L (x1, r1 + (n : ‚Ñù)) = L ((x1, r1) + ((0 : E), (n : ‚Ñù))) := congrArg L hr
        _ = L (x1, r1) + L ((0 : E), (n : ‚Ñù)) := by
          simpa using (map_add L (x1, r1) ((0 : E), (n : ‚Ñù)))
        _ = L (x1, r1) + (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) := by simp [h0]
    have hlt' : L (x1, r1) + (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) < u := by
      simpa [hLr] using hlt
    have hgt' : u < L (x1, r1) + (n : ‚Ñù) * L ((0 : E), (1 : ‚Ñù)) := by
      linarith [hmul]
    exact (not_lt_of_gt hgt') hlt'

  have ht0_le : L0 ((0 : E), (1 : ‚Ñù)) ‚â§ 0 := ht_nonpos L0 u0 hL0u0

  -- Build a second separator with negative vertical coefficient, then scale it so `g(0,1)=-1`.
  set Œº1 : ‚Ñù := r1 - 1
  have hŒº1 : (Œº1 : EReal) < f x1 := by
    have : (Œº1 : ‚Ñù) < r1 := by linarith
    simpa [Œº1, hr1] using (EReal.coe_lt_coe this)
  have hx1not : (x1, Œº1) ‚àâ epi := by
    intro hx1mem
    have : f x1 ‚â§ (Œº1 : EReal) := by simpa [epi] using hx1mem
    exact (not_le_of_gt hŒº1) this
  obtain ‚ü®L1, u1, hL1u1, hu1‚ü© :=
    geometric_hahn_banach_closed_point (E := E √ó ‚Ñù) (s := epi) (x := (x1, Œº1)) hEpiConvex
      hEpiClosed hx1not
  have ht1_le : L1 ((0 : E), (1 : ‚Ñù)) ‚â§ 0 := ht_nonpos L1 u1 hL1u1
  have ht1_ne : L1 ((0 : E), (1 : ‚Ñù)) ‚â† 0 := by
    intro ht1
    have hx1mem : (x1, r1) ‚àà epi := by
      have : f x1 ‚â§ (r1 : EReal) := by simp [hr1]
      simpa [epi] using this
    have hL1x1r1 : L1 (x1, r1) < u1 := hL1u1 (x1, r1) hx1mem
    have hEq : L1 (x1, Œº1) = L1 (x1, r1) := by
      have hr : (x1, Œº1) = (x1, r1) + ((0 : E), (Œº1 - r1)) := by
        ext <;> simp [Œº1, sub_eq_add_neg, add_comm, add_left_comm]
      have hn : ((0 : E), (Œº1 - r1)) = (Œº1 - r1) ‚Ä¢ ((0 : E), (1 : ‚Ñù)) := by
        ext <;> simp [Prod.smul_mk, smul_eq_mul]
      have h0 : L1 ((0 : E), (Œº1 - r1)) = (Œº1 - r1) * L1 ((0 : E), (1 : ‚Ñù)) := by
        calc
          L1 ((0 : E), (Œº1 - r1)) = L1 ((Œº1 - r1) ‚Ä¢ ((0 : E), (1 : ‚Ñù))) := congrArg L1 hn
          _ = (Œº1 - r1) ‚Ä¢ L1 ((0 : E), (1 : ‚Ñù)) := by
            simpa using (map_smul L1 (Œº1 - r1) ((0 : E), (1 : ‚Ñù)))
          _ = (Œº1 - r1) * L1 ((0 : E), (1 : ‚Ñù)) := by simp [smul_eq_mul]
      calc
        L1 (x1, Œº1) = L1 ((x1, r1) + ((0 : E), (Œº1 - r1))) := congrArg L1 hr
        _ = L1 (x1, r1) + L1 ((0 : E), (Œº1 - r1)) := by
          simpa using (map_add L1 (x1, r1) ((0 : E), (Œº1 - r1)))
        _ = L1 (x1, r1) + (Œº1 - r1) * L1 ((0 : E), (1 : ‚Ñù)) := by simp [h0]
        _ = L1 (x1, r1) := by simp [ht1]
    have : u1 < u1 := lt_trans hu1 (by simpa [hEq] using hL1x1r1)
    exact (lt_irrefl _ this)
  have ht1 : L1 ((0 : E), (1 : ‚Ñù)) < 0 := lt_of_le_of_ne ht1_le ht1_ne

  set a : ‚Ñù := (-1) / L1 ((0 : E), (1 : ‚Ñù))
  have ha_pos : 0 < a := by
    have hnum : (-1 : ‚Ñù) < 0 := by norm_num
    simpa [a] using (div_pos_of_neg_of_neg hnum ht1)
  let g : StrongDual ‚Ñù (E √ó ‚Ñù) := a ‚Ä¢ L1
  set M : ‚Ñù := a * u1
  have hg_bound : ‚àÄ p ‚àà epi, g p ‚â§ M := by
    intro p hp
    have : L1 p < u1 := hL1u1 p hp
    have : a * L1 p < a * u1 := mul_lt_mul_of_pos_left this ha_pos
    have : g p < M := by simpa [g, M, smul_eq_mul, mul_assoc] using this
    exact le_of_lt this
  have hg01 : g ((0 : E), (1 : ‚Ñù)) = -1 := by
    have ht1ne : L1 ((0 : E), (1 : ‚Ñù)) ‚â† 0 := ht1_ne
    simp [g, a, smul_eq_mul, div_eq_mul_inv, ht1ne]

  -- Perturb `L0` in the direction `g` to ensure a strictly negative vertical coefficient.
  set x0Œº : E √ó ‚Ñù := (x0, Œº0)
  have hŒî : 0 < L0 x0Œº - u0 := sub_pos.2 hu0
  set denom : ‚Ñù := 2 * (|M - g x0Œº| + 1)
  have hdenom_pos : 0 < denom := by
    have : 0 < |M - g x0Œº| + 1 := by linarith [abs_nonneg (M - g x0Œº)]
    have : 0 < (2 : ‚Ñù) * (|M - g x0Œº| + 1) := mul_pos (by norm_num) this
    simpa [denom, mul_assoc] using this
  set Œµ : ‚Ñù := (L0 x0Œº - u0) / denom
  have hŒµ_pos : 0 < Œµ := div_pos hŒî hdenom_pos
  have hŒµ_nonneg : 0 ‚â§ Œµ := le_of_lt hŒµ_pos
  let L : StrongDual ‚Ñù (E √ó ‚Ñù) := L0 + Œµ ‚Ä¢ g
  let u : ‚Ñù := u0 + Œµ * M

  have hLuEpi : ‚àÄ p ‚àà epi, L p < u := by
    intro p hp
    have hL0 : L0 p < u0 := hL0u0 p hp
    have hg : g p ‚â§ M := hg_bound p hp
    have hgmul : Œµ * g p ‚â§ Œµ * M := mul_le_mul_of_nonneg_left hg hŒµ_nonneg
    have : L0 p + Œµ * g p < u0 + Œµ * M := add_lt_add_of_lt_of_le hL0 hgmul
    simpa [L, u, smul_eq_mul, add_assoc, add_left_comm, add_comm] using this

  have hu : u < L x0Œº := by
    have habs_lt : |M - g x0Œº| < |M - g x0Œº| + 1 := by
      linarith [abs_nonneg (M - g x0Œº)]
    have hmul_lt : Œµ * |M - g x0Œº| < Œµ * (|M - g x0Œº| + 1) :=
      mul_lt_mul_of_pos_left habs_lt hŒµ_pos
    have hmul_eq : Œµ * (|M - g x0Œº| + 1) = (L0 x0Œº - u0) / 2 := by
      have hne : 2 * (|M - g x0Œº| + 1) ‚â† 0 := by linarith
      calc
        Œµ * (|M - g x0Œº| + 1) = ((L0 x0Œº - u0) / denom) * (|M - g x0Œº| + 1) := by
          simp [Œµ]
        _ = (L0 x0Œº - u0) / 2 := by
          field_simp [denom, hne]
          ring
    have hmul_abs : Œµ * |M - g x0Œº| < L0 x0Œº - u0 := by
      have : (L0 x0Œº - u0) / 2 < (L0 x0Œº - u0) := by linarith [hŒî]
      exact (hmul_lt.trans_eq hmul_eq).trans this
    have hmul :
        Œµ * (M - g x0Œº) < L0 x0Œº - u0 := by
      have hle : Œµ * (M - g x0Œº) ‚â§ Œµ * |M - g x0Œº| :=
        mul_le_mul_of_nonneg_left (le_abs_self _) hŒµ_nonneg
      exact lt_of_le_of_lt hle hmul_abs
    have : u0 + Œµ * M < L0 x0Œº + Œµ * g x0Œº := by
      -- rearrange to `Œµ*(M - g x0Œº) < L0 x0Œº - u0`
      linarith [hmul]
    simpa [L, u, smul_eq_mul, add_assoc, add_left_comm, add_comm] using this

  have ht : L ((0 : E), (1 : ‚Ñù)) < 0 := by
    have htle : L ((0 : E), (1 : ‚Ñù)) ‚â§ -Œµ := by
      have hL01 :
          L ((0 : E), (1 : ‚Ñù)) =
            L0 ((0 : E), (1 : ‚Ñù)) + Œµ * g ((0 : E), (1 : ‚Ñù)) := by
        simp [L, smul_eq_mul]
      have hL01' : L ((0 : E), (1 : ‚Ñù)) = L0 ((0 : E), (1 : ‚Ñù)) - Œµ := by
        calc
          L ((0 : E), (1 : ‚Ñù)) = L0 ((0 : E), (1 : ‚Ñù)) + Œµ * g ((0 : E), (1 : ‚Ñù)) := hL01
          _ = L0 ((0 : E), (1 : ‚Ñù)) - Œµ := by simp [hg01, sub_eq_add_neg]
      have hle : L0 ((0 : E), (1 : ‚Ñù)) - Œµ ‚â§ -Œµ := by linarith [ht0_le]
      simpa [hL01'] using hle
    exact lt_of_le_of_lt htle (by linarith [hŒµ_pos])

  -- Decompose `L` into an `E`-part and a vertical coefficient.
  let œÜ : E ‚ÜíL[‚Ñù] ‚Ñù := (L : (E √ó ‚Ñù) ‚ÜíL[‚Ñù] ‚Ñù).comp (ContinuousLinearMap.inl ‚Ñù E ‚Ñù)
  set t : ‚Ñù := L ((0 : E), (1 : ‚Ñù))
  have ht' : t < 0 := by simpa [t] using ht
  have ht_ne : t ‚â† 0 := ne_of_lt ht'

  have hdecomp : ‚àÄ x r, L (x, r) = œÜ x + t * r := by
    intro x r
    have hr : (x, r) = (x, (0 : ‚Ñù)) + ((0 : E), r) := by
      ext <;> simp
    have h0 : L ((0 : E), r) = r * t := by
      have hr0 : ((0 : E), r) = r ‚Ä¢ ((0 : E), (1 : ‚Ñù)) := by
        ext <;> simp [Prod.smul_mk, smul_eq_mul]
      calc
        L ((0 : E), r) = L (r ‚Ä¢ ((0 : E), (1 : ‚Ñù))) := congrArg L hr0
        _ = r ‚Ä¢ L ((0 : E), (1 : ‚Ñù)) := by simpa using (map_smul L r ((0 : E), (1 : ‚Ñù)))
        _ = r * t := by simp [t, smul_eq_mul]
    calc
      L (x, r) = L ((x, (0 : ‚Ñù)) + ((0 : E), r)) := by
        exact congrArg L hr
      _ = L (x, (0 : ‚Ñù)) + L ((0 : E), r) := by
        simpa using (map_add L (x, (0 : ‚Ñù)) ((0 : E), r))
      _ = œÜ x + t * r := by
        -- `œÜ x = L (x,0)` by definition, and `L(0,r) = r*t`.
        simp [œÜ, h0, t]
        ring

  -- Use the positive constant `c = (-1)/t` to package the affine minorant.
  let c : ‚Ñù := (-1) / t
  have hc_pos : 0 < c := by
    have hnum : (-1 : ‚Ñù) < 0 := by norm_num
    simpa [c] using (div_pos_of_neg_of_neg hnum ht')
  let xStar : Module.Dual ‚Ñù E := c ‚Ä¢ (œÜ : E ‚Üí‚Çó[‚Ñù] ‚Ñù)
  let Œ≤ : ‚Ñù := c * u

  have hminor : ‚àÄ x : E, ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ f x := by
    intro x
    by_cases hx : f x < ‚ä§
    ¬∑ have hxDom : x ‚àà erealDom f := hx
      rcases section14_eq_coe_of_lt_top (z := f x) hxDom (hf.1.1 x) with ‚ü®rx, hrx‚ü©
      have hxmem : (x, rx) ‚àà epi := by
        have : f x ‚â§ (rx : EReal) := by simp [hrx]
        simpa [epi] using this
      have hlt : L (x, rx) < u := hLuEpi (x, rx) hxmem
      have hlt' : œÜ x + t * rx < u := by simpa [hdecomp] using hlt
      have hc_t : c * (-t) = 1 := by
        have htne : t ‚â† 0 := ht_ne
        dsimp [c]
        calc
          ((-1 : ‚Ñù) / t) * (-t) = ((-1 : ‚Ñù) * (-t)) / t := by
            simpa using (div_mul_eq_mul_div (-1 : ‚Ñù) t (-t))
          _ = t / t := by simp
          _ = (1 : ‚Ñù) := div_self htne
      have hxStarŒ≤ : xStar x - Œ≤ = c * (œÜ x - u) := by
        dsimp [xStar, Œ≤]
        simp [mul_sub]
      have hœÜ : œÜ x - u < (-t) * rx := by linarith [hlt']
      have : c * (œÜ x - u) < c * ((-t) * rx) := mul_lt_mul_of_pos_left hœÜ hc_pos
      have : c * (œÜ x - u) < rx := by
        -- Simplify the right-hand side using `c * (-t) = 1`.
        calc
          c * (œÜ x - u) < c * ((-t) * rx) := this
          _ = (c * (-t)) * rx := by simp [mul_assoc]
          _ = rx := by simp [hc_t]
      have hxlt : xStar x - Œ≤ < rx := by simpa [hxStarŒ≤] using this
      have hxle : (xStar x - Œ≤) ‚â§ rx := le_of_lt hxlt
      have hxleE : ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ (rx : EReal) := EReal.coe_le_coe hxle
      simpa [hrx] using hxleE
    ¬∑ have hxTop : f x = ‚ä§ := by
        -- `¬¨ f x < ‚ä§` means `f x = ‚ä§`.
        simpa [lt_top_iff_ne_top] using hx
      rw [hxTop]
      exact le_top
  have hstrict : (Œº0 : ‚Ñù) < xStar x0 - Œ≤ := by
    have hc_t : c * (-t) = 1 := by
      have htne : t ‚â† 0 := ht_ne
      dsimp [c]
      calc
        ((-1 : ‚Ñù) / t) * (-t) = ((-1 : ‚Ñù) * (-t)) / t := by
          simpa using (div_mul_eq_mul_div (-1 : ‚Ñù) t (-t))
        _ = t / t := by simp
        _ = (1 : ‚Ñù) := div_self htne
    have hxStarŒ≤ : xStar x0 - Œ≤ = c * (œÜ x0 - u) := by
      dsimp [xStar, Œ≤]
      simp [mul_sub]
    have hu' : u < L (x0, Œº0) := hu
    have hu'' : u < œÜ x0 + t * Œº0 := by simpa [hdecomp] using hu'
    have hœÜ : (-t) * Œº0 < œÜ x0 - u := by linarith [hu'']
    have : c * ((-t) * Œº0) < c * (œÜ x0 - u) := mul_lt_mul_of_pos_left hœÜ hc_pos
    have : Œº0 < c * (œÜ x0 - u) := by
      calc
        Œº0 = (c * (-t)) * Œº0 := by simp [hc_t]
        _ = c * ((-t) * Œº0) := by simp [mul_assoc]
        _ < c * (œÜ x0 - u) := this
    simpa [hxStarŒ≤] using this

  have hxStar_finite :
      fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f xStar < ‚ä§ := by
    set p : E ‚Üí‚Çó[‚Ñù] (Module.Dual ‚Ñù E) ‚Üí‚Çó[‚Ñù] ‚Ñù :=
      (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))
    have hle : fenchelConjugateBilin p f xStar ‚â§ (Œ≤ : EReal) := by
      unfold fenchelConjugateBilin
      refine sSup_le ?_
      rintro _ ‚ü®x, rfl‚ü©
      have hminor' : ((xStar x : ‚Ñù) : EReal) - (Œ≤ : EReal) ‚â§ f x := by
        simpa [EReal.coe_sub] using hminor x
      have hxle : ((xStar x : ‚Ñù) : EReal) ‚â§ f x + (Œ≤ : EReal) :=
        (EReal.sub_le_iff_le_add (h‚ÇÅ := Or.inl (by simp : (Œ≤ : EReal) ‚â† ‚ä•))
              (h‚ÇÇ := Or.inl (by simp : (Œ≤ : EReal) ‚â† ‚ä§))).1 hminor'
      have hxle' : ((xStar x : ‚Ñù) : EReal) ‚â§ (Œ≤ : EReal) + f x := by
        simpa [add_comm, add_left_comm, add_assoc] using hxle
      have : ((xStar x : ‚Ñù) : EReal) - f x ‚â§ (Œ≤ : EReal) :=
        (EReal.sub_le_iff_le_add (h‚ÇÅ := Or.inl (hf.1.1 x)) (h‚ÇÇ := Or.inr (by simp))).2
          (by simpa [add_comm] using hxle')
      simpa [p, LinearMap.apply‚Çó] using this
    have hŒ≤ : (Œ≤ : EReal) < ‚ä§ := by simp
    exact lt_of_le_of_lt hle hŒ≤

  exact ‚ü®xStar, Œ≤, hminor, hstrict, hxStar_finite‚ü©

/-- For a proper convex lower semicontinuous function, the Fenchel conjugate is finite somewhere. -/
lemma section14_exists_mem_dom_fenchelConjugate_of_properConvex_lsc [TopologicalSpace E]
    [IsTopologicalAddGroup E] [ContinuousSMul ‚Ñù E] [LocallyConvexSpace ‚Ñù E]
    {f : E ‚Üí EReal} (hf : ProperConvexERealFunction (F := E) f) (hf_closed : LowerSemicontinuous f) :
    (erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)).Nonempty := by
  rcases hf.1.2 with ‚ü®x0, hx0neTop‚ü©
  have hx0 : f x0 < ‚ä§ := lt_top_iff_ne_top.2 hx0neTop
  rcases section14_eq_coe_of_lt_top (z := f x0) hx0 (hf.1.1 x0) with ‚ü®r0, hr0‚ü©
  set Œº0 : ‚Ñù := r0 - 1
  have hŒº0 : (Œº0 : EReal) < f x0 := by
    have : (Œº0 : ‚Ñù) < r0 := by linarith
    simpa [Œº0, hr0] using (EReal.coe_lt_coe this)
  rcases
      section14_exists_affine_minorant_strict_of_lt (E := E) (f := f) hf hf_closed (x0 := x0)
        (Œº0 := Œº0) hŒº0 with
    ‚ü®xStar, Œ≤, -, -, hxStarFin‚ü©
  refine ‚ü®xStar, ?_‚ü©
  simpa [erealDom] using hxStarFin

/-- If `y` is nonpositive on `dom f*` and `f` is proper convex and closed, then `y` is a recession
direction of `f`. -/
lemma section14_mem_recessionConeEReal_of_forall_mem_dom_fenchelConjugate_le_zero
    [TopologicalSpace E] [IsTopologicalAddGroup E] [ContinuousSMul ‚Ñù E] [LocallyConvexSpace ‚Ñù E]
    {f : E ‚Üí EReal} (hf : ProperConvexERealFunction (F := E) f)
    (hf_closed : LowerSemicontinuous f) {y : E}
    (hy : ‚àÄ xStar : Module.Dual ‚Ñù E,
      xStar ‚àà erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f) ‚Üí
        xStar y ‚â§ 0) :
    y ‚àà recessionConeEReal (F := E) f := by
  classical
  refine (section14_mem_recessionConeEReal_iff (g := f) (y := y)).2 ?_
  intro x hxDom
  have hxBot : f x ‚â† ‚ä• := hf.1.1 x
  rcases section14_eq_coe_of_lt_top (z := f x) hxDom hxBot with ‚ü®rx, hrx‚ü©
  -- We show `f (x+y) ‚â§ f x` by contradiction using an affine minorant at `x+y`.
  have hxy_le : f (x + y) ‚â§ f x := by
    by_contra hnot
    have hlt : f x < f (x + y) := lt_of_not_ge hnot
    by_cases hxy : f (x + y) < ‚ä§
    ¬∑ rcases section14_eq_coe_of_lt_top (z := f (x + y)) hxy (hf.1.1 (x + y)) with
        ‚ü®rxy, hrxy‚ü©
      have hr_lt : rx < rxy := by
        have : (rx : EReal) < (rxy : EReal) := by simpa [hrx, hrxy] using hlt
        exact (EReal.coe_lt_coe_iff).1 this
      let Œº0 : ‚Ñù := (rx + rxy) / 2
      have hŒº0_gt : rx < Œº0 := by
        dsimp [Œº0]
        linarith [hr_lt]
      have hŒº0_lt : (Œº0 : EReal) < f (x + y) := by
        have : (Œº0 : ‚Ñù) < rxy := by
          dsimp [Œº0]
          linarith [hr_lt]
        simpa [Œº0, hrxy] using (EReal.coe_lt_coe this)
      rcases
          section14_exists_affine_minorant_strict_of_lt (E := E) (f := f) hf hf_closed
            (x0 := x + y) (Œº0 := Œº0) hŒº0_lt with
        ‚ü®xStar, Œ≤, hminor, hstrict, hxStarFin‚ü©
      have hxStarDom :
          xStar ‚àà
            erealDom
              (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f) := by
        simpa [erealDom] using hxStarFin
      have hyx : xStar y ‚â§ 0 := hy xStar hxStarDom
      have hle_xy : xStar (x + y) - Œ≤ ‚â§ xStar x - Œ≤ := by
        have : xStar (x + y) = xStar x + xStar y := by simp [map_add]
        have hle : xStar x + xStar y ‚â§ xStar x := add_le_of_nonpos_right hyx
        have : xStar x + xStar y - Œ≤ ‚â§ xStar x - Œ≤ := sub_le_sub_right hle Œ≤
        simpa [this, sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using this
      have hstrict' : (Œº0 : ‚Ñù) < xStar x - Œ≤ := lt_of_lt_of_le hstrict hle_xy
      have hxminor : (xStar x - Œ≤ : ‚Ñù) ‚â§ rx := by
        have : ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ f x := hminor x
        have : ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ (rx : EReal) := by simpa [hrx] using this
        exact (EReal.coe_le_coe_iff).1 this
      have : (Œº0 : ‚Ñù) < rx := lt_of_lt_of_le hstrict' hxminor
      exact (not_lt_of_gt hŒº0_gt) this
    ¬∑ have hxyTop : f (x + y) = ‚ä§ := by
        simpa [lt_top_iff_ne_top] using hxy
      set Œº0 : ‚Ñù := rx + 1
      have hŒº0_gt : rx < Œº0 := by linarith
      have hŒº0_lt : (Œº0 : EReal) < f (x + y) := by simp [hxyTop]
      rcases
          section14_exists_affine_minorant_strict_of_lt (E := E) (f := f) hf hf_closed
            (x0 := x + y) (Œº0 := Œº0) hŒº0_lt with
        ‚ü®xStar, Œ≤, hminor, hstrict, hxStarFin‚ü©
      have hxStarDom :
          xStar ‚àà
            erealDom
              (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f) := by
        simpa [erealDom] using hxStarFin
      have hyx : xStar y ‚â§ 0 := hy xStar hxStarDom
      have hle_xy : xStar (x + y) - Œ≤ ‚â§ xStar x - Œ≤ := by
        have : xStar (x + y) = xStar x + xStar y := by simp [map_add]
        have hle : xStar x + xStar y ‚â§ xStar x := add_le_of_nonpos_right hyx
        have : xStar x + xStar y - Œ≤ ‚â§ xStar x - Œ≤ := sub_le_sub_right hle Œ≤
        simpa [this, sub_eq_add_neg, add_assoc, add_left_comm, add_comm] using this
      have hstrict' : (Œº0 : ‚Ñù) < xStar x - Œ≤ := lt_of_lt_of_le hstrict hle_xy
      have hxminor : (xStar x - Œ≤ : ‚Ñù) ‚â§ rx := by
        have : ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ f x := hminor x
        have : ((xStar x - Œ≤ : ‚Ñù) : EReal) ‚â§ (rx : EReal) := by simpa [hrx] using this
        exact (EReal.coe_le_coe_iff).1 this
      have : (Œº0 : ‚Ñù) < rx := lt_of_lt_of_le hstrict' hxminor
      exact (not_lt_of_gt hŒº0_gt) this
  exact (EReal.sub_nonpos).2 hxy_le

/-- If `x‚òÖ` is in `polarCone (recessionConeEReal f)`, then `x‚òÖ` lies in the weak closure of the
conic hull of `dom f*` (dual part of Theorem 14.2). -/
lemma section14_polar_recessionCone_subset_closure_coneHull_dom_fenchelConjugate
    [TopologicalSpace E] [IsTopologicalAddGroup E] [ContinuousSMul ‚Ñù E] [LocallyConvexSpace ‚Ñù E]
    {f : E ‚Üí EReal} (hf : ProperConvexERealFunction (F := E) f) (hf_closed : LowerSemicontinuous f) :
    polarCone (E := E) (recessionConeEReal (F := E) f) ‚äÜ
      closure
        ((ConvexCone.hull ‚Ñù
              (erealDom
                (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
            ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) := by
  classical
  intro xStar hxStar
  by_contra hxStar_cl
  have hDom :
      (erealDom
          (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)).Nonempty :=
    section14_exists_mem_dom_fenchelConjugate_of_properConvex_lsc (E := E) (f := f) hf hf_closed
  rcases
      section14_exists_eval_sep_of_not_mem_closure_coneHull_dom_fenchelConjugate (E := E) (f := f)
        (xStar := xStar) hDom hxStar_cl with
    ‚ü®y, hy, hpos‚ü©
  have hyDom :
      ‚àÄ z : Module.Dual ‚Ñù E,
        z ‚àà erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f) ‚Üí
          z y ‚â§ 0 := by
    intro z hzDom
    have hzHull :
        z ‚àà
            ((ConvexCone.hull ‚Ñù
                    (erealDom
                      (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
                ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) :=
      (ConvexCone.subset_hull (s :=
        erealDom (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f))) hzDom
    have hzCl :
        z ‚àà
            closure
              ((ConvexCone.hull ‚Ñù
                    (erealDom
                      (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
                ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) :=
      subset_closure hzHull
    exact hy z hzCl
  have hyRec :
      y ‚àà recessionConeEReal (F := E) f :=
    section14_mem_recessionConeEReal_of_forall_mem_dom_fenchelConjugate_le_zero (E := E) (f := f)
      (hf := hf) hf_closed hyDom
  have hxStar_ineq : xStar y ‚â§ 0 :=
    (mem_polarCone_iff (E := E) (K := recessionConeEReal (F := E) f) (œÜ := xStar)).1 hxStar y hyRec
  exact (not_lt_of_ge hxStar_ineq) hpos

/-- Theorem 14.2 (dual statement). If `f` is closed, then the polar of the recession cone of `f`
is the closure of the convex cone generated by `dom f*`. -/
theorem polar_recessionCone_eq_closure_coneGenerated_dom_fenchelConjugate [TopologicalSpace E]
    [IsTopologicalAddGroup E] [ContinuousSMul ‚Ñù E] [LocallyConvexSpace ‚Ñù E]
    {f : E ‚Üí EReal} (hf : ProperConvexERealFunction (F := E) f) (hf_closed : LowerSemicontinuous f) :
    polarCone (E := E) (recessionConeEReal (F := E) f) =
      closure
        ((ConvexCone.hull ‚Ñù
              (erealDom
                (fenchelConjugateBilin (LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù)) f)) :
              ConvexCone ‚Ñù (Module.Dual ‚Ñù E)) : Set (Module.Dual ‚Ñù E)) := by
  classical
  refine subset_antisymm ?_ ?_
  ¬∑
    exact
      section14_polar_recessionCone_subset_closure_coneHull_dom_fenchelConjugate (E := E) (f := f)
        hf hf_closed
  ¬∑
    exact section14_closure_coneHull_dom_fenchelConjugate_subset_polar_recessionCone (E := E)
      (f := f) hf

/-- Membership in a dual cone with respect to the flipped evaluation pairing is exactly a
pointwise nonpositivity condition. -/
lemma section14_mem_dual_flip_eval_iff_forall_le_zero (S : Set (Module.Dual ‚Ñù E)) (x : E) :
    x ‚àà
        (PointedCone.dual (R := ‚Ñù)
              ((-LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))).flip S :
            Set E) ‚Üî
      ‚àÄ œÜ : Module.Dual ‚Ñù E, œÜ ‚àà S ‚Üí œÜ x ‚â§ 0 := by
  constructor
  ¬∑ intro hx œÜ hœÜ
    have hx' :
        ‚àÄ ‚¶Éœà : Module.Dual ‚Ñù E‚¶Ñ,
          œà ‚àà S ‚Üí
            0 ‚â§
              ((-LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))).flip œà x := by
      simpa [PointedCone.mem_dual] using hx
    have : 0 ‚â§ ((-LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))).flip œÜ x := hx' hœÜ
    have : 0 ‚â§ -(œÜ x) := by
      simpa [LinearMap.neg_apply, LinearMap.apply‚Çó] using this
    exact (neg_nonneg).1 this
  ¬∑ intro hx
    refine
      (PointedCone.mem_dual
            (p := ((-LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))).flip) (s := S)
            (y := x)).2 ?_
    intro œÜ hœÜ
    have hxle : œÜ x ‚â§ 0 := hx œÜ hœÜ
    have : 0 ‚â§ -(œÜ x) := (neg_nonneg).2 hxle
    simpa [LinearMap.neg_apply, LinearMap.apply‚Çó] using this

/-- Recession directions lie in the polar (with respect to flipped evaluation) of the barrier cone. -/
lemma section14_recessionCone_subset_polar_barrierCone {C : Set E} (hCne : C.Nonempty) :
    Set.recessionCone C ‚äÜ
      (PointedCone.dual (R := ‚Ñù)
            ((-LinearMap.apply‚Çó (R := ‚Ñù) (M := E) (M‚ÇÇ := ‚Ñù))).flip (Set.barrierCone (E := E) C) :
          Set E) := by
  classical
  intro y hy
  refine
    (section14_mem_dual_flip_eval_iff_forall_le_zero (E := E) (S := Set.barrierCone (E := E) C)
          (x := y)).2 ?_
  intro œÜ hœÜ
  rcases hœÜ with ‚ü®Œ≤, hŒ≤‚ü©
  rcases hCne with ‚ü®x0, hx0C‚ü©
  have hmul_le : ‚àÄ n : ‚Ñï, (n : ‚Ñù) * (œÜ y) ‚â§ Œ≤ - œÜ x0 := by
    intro n
    have hn : (0 : ‚Ñù) ‚â§ (n : ‚Ñù) := by exact_mod_cast (Nat.zero_le n)
    have hxny : x0 + (n : ‚Ñù) ‚Ä¢ y ‚àà C := hy (x := x0) hx0C (t := (n : ‚Ñù)) hn
    have hbound : œÜ (x0 + (n : ‚Ñù) ‚Ä¢ y) ‚â§ Œ≤ := hŒ≤ (x0 + (n : ‚Ñù) ‚Ä¢ y) hxny
    have hcalc : œÜ (x0 + (n : ‚Ñù) ‚Ä¢ y) = œÜ x0 + (n : ‚Ñù) * (œÜ y) := by
      simp [map_add, smul_eq_mul]
    have : œÜ x0 + (n : ‚Ñù) * (œÜ y) ‚â§ Œ≤ := by simpa [hcalc] using hbound
    linarith
  exact section14_real_nonpos_of_nat_mul_le (r := œÜ y) (C := Œ≤ - œÜ x0) hmul_le

end Section14
end Chap03
